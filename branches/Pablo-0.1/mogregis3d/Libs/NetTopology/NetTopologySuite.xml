<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NetTopologySuite</name>
    </assembly>
    <members>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1">
            <summary>
             Models a triangle formed from <see cref="!:QuadEdge&lt;TCoordinate, TData&gt;"/>s in a <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/>. Provides methods to
             access the topological and geometric properties of the triangle. Triangle edges are oriented CCW.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
            <typeparam name="TData"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.Contains(NetTopologySuite.Triangulate.Quadedge.Vertex{`0}[],`0)">
            <summary>
             Tests whether the point pt is contained in the triangle defined by 3 <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/>es.
            </summary>
            <param name="tri"> an array containing at least 3 Vertexes</param>
            <param name="pt">the point to test</param>
            <returns>true if the point is contained in the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.Contains(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0}[],`0)">
            <summary>
             Tests whether the point pt is contained in the triangle defined by 3 <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1"/>es.
            </summary>
            <param name="tri">an array containing at least 3 QuadEdges</param>
            <param name="pt">the point to test</param>
            <returns>true if the point is contained in the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.NextIndex(System.Int32)">
            <summary>
             Finds the next index around the triangle. Index may be an edge or vertex index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.GetVertices">
            <summary>
             Gets the vertices for this triangle.
            </summary>
            <returns>a new array containing the triangle vertices</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.GetEdgeIndex(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
             Gets the index for the given _edge of this triangle
            </summary>
            <param name="e">e a QuadEdge</param>
            <returns>the index of the _edge in this triangle</returns>
            <returns>-1 if the edge is not an _edge of this triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.GetEdgeIndex(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Gets the index for the _edge that starts at vertex v.
            </summary>
            <param name="v">the vertex to find the _edge for</param>
            <returns>the index of the _edge starting at the vertex</returns>
            <returns>-1 if the vertex is not in the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.IsBorder">
            <summary>
             Tests whether this triangle is adjacent to the outside of the subdivision.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.IsBorder(System.Int32)">
            <summary>
             Tests whether this triangle is adjacent to the outside of the subdivision.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1.GetNeighbours">
            <summary>
             Gets the neighbours of this triangle. If there is no neighbour triangle, the array element is <value>null</value>
            </summary>
            <returns>an array containing the 3 neighbours of this triangle</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateOp`1">
            <summary>
            Implements the <see cref="M:NetTopologySuite.Geometries.Geometry`1.Relate(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IntersectionMatrix)"/> operations
            on <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.GeometryGraphOperation`1">
            <summary>
            The base class for operations that require <see cref="T:NetTopologySuite.GeometriesGraph.GeometryGraph`1"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.GeometryGraphOperation`1.GetArgumentGeometry(System.Int32)">
            <summary>
            Gets the input geometry at the given <paramref name="index"/>.
            </summary>
            <param name="index"></param>
            <returns>
            The geometry at the given input index, or <see langword="null"/>
            if <c><paramref name="index"/> &lt; 0</c> or <c><paramref name="index"/> &gt; 1</c>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateOp`1.#ctor(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Operation.Relate.RelateOp`1"/> for the given input
            geometries.
            </summary>
            <param name="g0">The first geometry to relate.</param>
            <param name="g1">The second geometry to relate.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateOp`1.#ctor(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0},NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Operation.Relate.RelateOp`1"/> for the given input
            geometries.
            </summary>
            <param name="g0">The first geometry to relate.</param>
            <param name="g1">The second geometry to relate.</param>
            <param name="boundaryNodeRule"></param>
        </member>
        <member name="P:NetTopologySuite.Operation.Relate.RelateOp`1.IntersectionMatrix">
            <summary>
            Gets the computed intersection matrix for the input geometries.
            </summary>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LengthIndexedLine`1">
            <summary>
            Supports linear referencing along a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            using the length along the line as the index.
            </summary>
            <remarks>
            Negative length values are taken as measured in the reverse direction
            from the end of the geometry.
            Out-of-range index values are handled by clamping
            them to the valid range of values.
            Non-simple lines (i.e. which loop back to cross or touch
            themselves) are supported.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Constructs an object which allows a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            to be linearly referenced using length as an index.
            </summary>
            <param name="linearGeom">The linear geometry to reference along.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.ExtractPoint(System.Double)">
            <summary>
            Computes the <typeparamref name="TCoordinate"/> for the point
            on the line at the given index.
            If the index is out of range the first or last point on the
            line will be returned.
            </summary>
            <param name="index">The index of the desired point.</param>
            <returns>The <typeparamref name="TCoordinate" /> at the given index.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.ExtractPoint(System.Double,System.Double)">
            <summary>
             Computes the <see cref="!:TCoordinate"/> for the point
             on the line at the given index, offset by the given distance.
             If the index is out of range the first or last point on the
             line will be returned.
             The computed point is offset to the left of the line if the offset distance is
             positive, to the right if negative.
             
             The Z-ordinate of the computed point will be interpolated from
             the Z-ordinates of the line segment containing it, if they exist.
            </summary>
            <param name="index">the index of the desired point</param>
            <param name="offsetDistance">the distance the point is offset from the segment (positive is to the left, negative is to the right)</param>
            <returns>the Coordinate at the given index</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.ExtractLine(System.Double,System.Double)">
            <summary>
            Computes the <see cref="T:GeoAPI.Geometries.ILineString`1"/> for the interval
            on the line between the given indices.
            If the <paramref name="endIndex"/> lies before the <paramref name="startIndex"/>,
            the computed geometry is reversed.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.IndexOf(`0)">
            <summary>
            Computes the minimum index for a point on the line.
            If the line is not simple (i.e. loops back on itself)
            a single point may have more than one possible index.
            In this case, the smallest index is returned.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.Project(`0)"/> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The minimum index of the point.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.IndexOfAfter(`0,System.Double)">
            <summary>
            Finds the index for a point on the line
            which is greater than the given index.
            If no such index exists, returns <paramref name="minIndex"/>.
            This method can be used to determine all indexes for
            a point which occurs more than once on a non-simple line.
            It can also be used to disambiguate cases where the given point lies
            slightly off the line and is equidistant from two different
            points on the line.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.Project(`0)"/> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <param name="minIndex">The value the returned index must be greater than.</param>
            <returns>The index of the point greater than the given minimum index.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.IndicesOf(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Computes the indices for a subline of the line.
            (The subline must conform to the line; that is,
            all vertices in the subline (except possibly the first and last)
            must be vertices of the line and occcur in the same order).
            </summary>
            <param name="subLine">A subLine of the line.</param>
            <returns>A pair of indices for the start and end of the subline..</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.Project(`0)">
            <summary>
            Computes the index for the closest point on the line to the given point.
            If more than one point has the closest distance the first one along the line is returned.
            (The point does not necessarily have to lie precisely on the line.)
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.IsValidIndex(System.Double)">
            <summary>
            Tests whether an index is in the valid index range for the line.
            </summary>
            <param name="index">The index to test.</param>
            <returns><see langword="true"/> if the index is in the valid range.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.ClampIndex(System.Double)">
            <summary>
            Computes a valid index for this line
            by clamping the given index to the valid range of index values
            </summary>
            <param name="index"></param>
            <returns>A valid index value.</returns>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.StartIndex">
            <summary>
            Returns the index of the start of the line.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LengthIndexedLine`1.EndIndex">
            <summary>
            Returns the index of the end of the line.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.Node`2">
            <summary>
            Represents a node of a <c>Quadtree</c>.  Nodes contain
            items which have a spatial extent corresponding to the node's position
            in the quadtree.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.BaseQuadNode`2">
            <summary>
            The base class for nodes in a <see cref="T:NetTopologySuite.Index.Quadtree.Quadtree`2"/>.
            </summary>
            <summary>
            Subquads are numbered as follows:
            2 | 3
            --+--
            0 | 1
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.AbstractNode`2.#ctor(System.Int32)">
            <summary> 
            Constructs an <see cref="T:NetTopologySuite.Index.AbstractNode`2"/> at the 
            given level in the tree.
            </summary>
            <param name="level">
            0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
            root node will have the highest level.
            </param>
        </member>
        <member name="M:NetTopologySuite.Index.AbstractNode`2.ComputeBounds">
            <summary>
            Computes a representation of space that encloses this node,
            preferably not much bigger than the node's boundary yet fast to
            test for intersection with the bounds of other nodes and bounded items. 
            </summary>    
        </member>
        <member name="P:NetTopologySuite.Index.AbstractNode`2.Level">
            <summary>
            Returns 0 if this node is a leaf, 1 if a parent of a leaf, and so on; the
            root node will have the highest level.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.BaseQuadNode`2.GetSubnodeIndex(GeoAPI.Geometries.IExtents{`0},`0)">
            <summary> 
            Returns the index of the subquad that wholly contains the given envelope.
            If none does, returns -1.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.BaseQuadNode`2.Remove(GeoAPI.Geometries.IExtents{`0},`1)">
            <summary> 
            Removes a single item from this subtree.
            </summary>
            <param name="itemExtents">The <see cref="T:GeoAPI.Geometries.IExtents`1"/> containing the item.</param>
            <param name="item">The item to remove.</param>
            <returns><see langword="true"/> if the item was found and removed.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`2.GetNode(GeoAPI.Geometries.IExtents{`0})">
            <summary> 
            Returns the subquad containing the envelope.
            Creates the subquad if it does not already exist.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`2.Find(GeoAPI.Geometries.IExtents{`0})">
            <summary>
            Returns the smallest <i>existing</i> node containing the envelope.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Node`2.getSubnode(System.Int32)">
            <summary>
            Get the subquad for the index.
            If it doesn't exist, create it.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.NodeMap`1">
            <summary> 
            A map of nodes, indexed by the coordinate of the node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap`1.AddNode(`0)">
            <summary> 
            This method expects that a node has a coordinate value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap`1.Add(NetTopologySuite.GeometriesGraph.EdgeEnd{`0})">
            <summary> 
            Adds a node for the start point of this EdgeEnd
            (if one does not already exist in this map).
            Adds the EdgeEnd to the (possibly new) node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeMap`1.Find(`0)">
            <returns> 
            The node if found; null otherwise.
            </returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeList`1">
            <summary>
            An <see cref="T:NetTopologySuite.GeometriesGraph.EdgeList`1"/> is a list of 
            <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>s. It supports locating edges 
            that are pointwise equal to a target edge.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.EdgeList`1._index">
            <summary>
            An index of the edges, for fast lookup.
            a Quadtree is used, because this index needs to be dynamic
            (e.g. allow insertions after queries).
            An alternative would be to use an ordered set based on the values
            of the edge coordinates.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList`1.Add(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary> 
            Insert an edge unless it is already in the list.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList`1.Remove(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            Remove the selected Edge element from the list if present.
            </summary>
            <param name="e">Edge element to remove from list.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList`1.FindEqualEdge(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            If there is an edge equal to e already in the list, return it.
            Otherwise return null.
            </summary>
            <returns>  
            An equal edge, if there is one already in the list,
            <see langword="null"/> otherwise.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeList`1.FindEdgeIndex(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            If the edge e is already in the list, return its index.
            </summary>
            <returns>  
            Index, if e is already in the list,
            -1 otherwise.
            </returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Edge`1">
            <summary>
            Represents an edge in a <see cref="T:NetTopologySuite.GeometriesGraph.GeometryGraph`1"/>.
            </summary>
            <typeparam name="TCoordinate">The type of coordinate.</typeparam>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.GraphComponent`1">
            <summary>
            A GraphComponent is the parent class for the objects'
            that form a graph.  Each GraphComponent can carry a
            Label.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GraphComponent`1.ComputeIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Compute the contribution to an IM for this component.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GraphComponent`1.UpdateIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labeling for both 
            parent geometries.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent`1.IsInResult">
            <summary> 
            Indicates if this component has already been included 
            in the result.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent`1.Coordinate">
            <returns>
            A coordinate in this component (or null, if there are none).
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.GraphComponent`1.IsIsolated">
            <summary>
            An isolated component is one that does not intersect or touch any other
            component.  This is the case if the label has valid locations for
            only a single Geometry.
            </summary>
            <returns><see langword="true"/> if this component is isolated.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge`1.UpdateIntersectionMatrix(NetTopologySuite.GeometriesGraph.Label,GeoAPI.Geometries.IntersectionMatrix)">
            <summary> 
            Updates an <see cref="T:GeoAPI.Geometries.IntersectionMatrix"/> from the label for an edge.
            Handles edges from both L and A geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge`1.AddIntersections(NetTopologySuite.Algorithm.Intersection{`0},System.Int32,System.Int32)">
            <summary>
            Adds <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/>s for one or both
            intersections found for a segment of an edge to the edge intersection list.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge`1.AddIntersection(NetTopologySuite.Algorithm.Intersection{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/> for intersection 
            <paramref name="intersectionIndex"/>.
            An intersection that falls exactly on a vertex of the edge is normalized
            to use the higher of the two possible <paramref name="segmentIndex"/>es.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge`1.ComputeIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for this component.
            A component only contributes if it has a labeling for both parent geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge`1.IsPointwiseEqual(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            Computes whether the coordinate sequences of the 
            <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>s are identical.
            </summary>
            <returns> 
            <see langword="true"/> if the coordinate sequences of the 
            <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>s are identical.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge`1.Equals(System.Object)">
            <summary>
            Equals is defined to be:
            e1 equals e2
            iff
            the coordinates of e1 are the same or the reverse of the coordinates in e2.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Edge`1.Equals(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            Equals is defined to be:
            e1 equals e2
            iff
            the coordinates of e1 are the same or the reverse of the coordinates in e2.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge`1.DepthDelta">
            <summary>
            The <see cref="P:NetTopologySuite.GeometriesGraph.Edge`1.DepthDelta"/> is the change in depth as an edge is 
            crossed from R to L.
            </summary>
            <returns>The change in depth as the edge is crossed from R to L.</returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge`1.MaximumSegmentIndex">
            <summary>
            Gets the index of the last segment's endpoint.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge`1.EdgeIntersections">
            <summary>
            Gets an <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1"/> for 
            the <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge`1.MonotoneChainEdge">
            <summary>
            Gets a <see cref="!:MonotoneChainEdge&lt;TCoordinate&gt;"/> from 
            the <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/> instance.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge`1.IsClosed">
            <summary>
            Gets <see langword="true"/> if the first coordinate of the edge
            equals the last coordinate.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Edge`1.IsCollapsed">
            <summary> 
            An <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/> is collapsed if it is a
            <see cref="F:GeoAPI.Geometries.Dimensions.Surface"/> edge and it consists of 
            two segments which are equal and opposite (e.g. a zero-width 'V' shape).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects`1">
            <summary>
             <see cref="M:GeoAPI.Geometries.ISpatialRelation`1.Intersects(GeoAPI.Geometries.IGeometry{`0})"/> operation for <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedLineString`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects`1.#ctor(NetTopologySuite.Geometries.Prepared.PreparedLineString{`0})">
            <summary>
             Creates an instance of this operation.
            </summary>
            <param name="prepLine">the target PreparedLineString</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects`1.Intersects(NetTopologySuite.Geometries.Prepared.PreparedLineString{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Computes the intersects predicate between a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedLineString`1"/>
             and a <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="prep">the prepared linestring</param>
            <param name="geom">a test geometry</param>
            <returns>true if the linestring intersects the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects`1.Intersects(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Tests whether this geometry intersects a given geometry.
            </summary>
            <param name="geom">the test geometry</param>
            <returns>true if the test geometry intersects</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineStringIntersects`1.IsAnyTestPointInTarget(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Tests whether any representative point of the test Geometry intersects
             the target geometry.
             Only handles test geometries which are <see cref="F:GeoAPI.Geometries.Dimensions.Point"/>.
            </summary>
             <param name="testGeom"><see cref="F:GeoAPI.Geometries.Dimensions.Point"/> geometry to test</param>
             <returns>true if any point of the argument intersects the prepared geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.MultiLineString`1">
            <summary>
            Basic implementation of <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/>.
            </summary>    
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryCollection`1">
            <summary>
            Basic implementation of <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Geometry`1">
            <summary>  
            Basic implementation of <see cref="T:GeoAPI.Geometries.IGeometry`1"/>, the fundamental
            unit of spatial reasoning in NTS.
            </summary>
            <remarks>
            <para>
            <see cref="M:NetTopologySuite.Geometries.Geometry`1.Clone"/> returns a deep copy of the object.
            </para>
            <para>
            Binary Predicates: 
            Because it is not clear at this time what semantics for spatial
            analysis methods involving <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>s 
            would be useful, <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>s are not 
            supported as arguments to binary predicates 
            (other than <see cref="M:NetTopologySuite.Geometries.Geometry`1.ConvexHull"/>) or the 
            <see cref="M:NetTopologySuite.Geometries.Geometry`1.Relate(GeoAPI.Geometries.IGeometry{`0})"/> family of methods.
            </para>
            <para>
            Set-Theoretic Methods: 
            The spatial analysis methods will
            return the most specific class possible to represent the result. If the
            result is homogeneous, a <see cref="T:NetTopologySuite.Geometries.Point`1"/>, 
            <see cref="T:NetTopologySuite.Geometries.LineString`1"/>, or <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> 
            will be returned if the result contains a single element; 
            otherwise, a <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>, 
            <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>, or 
            <see cref="T:NetTopologySuite.Geometries.MultiPolygon`1"/> 
            will be returned. If the result is heterogeneous a 
            <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> will be returned.
            </para>
            <para>
            Representation of Computed Geometries:
            The SFS states that the result
            of a set-theoretic method is the "point-set" result of the usual
            set-theoretic definition of the operation (SFS 3.2.21.1). However, there are
            sometimes many ways of representing a point set as a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            The SFS does not specify an unambiguous representation of a given point set
            returned from a spatial analysis method. One goal of NTS is to make this
            specification precise and unambiguous. NTS will use a canonical form for
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s returned from spatial analysis methods. The canonical
            form is a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> which is simple and noded:
            Simple means that the Geometry returned will be simple according to
            the NTS definition of <see cref="P:NetTopologySuite.Geometries.Geometry`1.IsSimple"/>.
            Noded applies only to overlays involving <see cref="T:NetTopologySuite.Geometries.LineString`1"/>s. It
            means that all intersection points on <see cref="T:NetTopologySuite.Geometries.LineString`1"/>s will be
            present as endpoints of <see cref="T:NetTopologySuite.Geometries.LineString`1"/>s in the result.
            This definition implies that non-simple geometries which are arguments to
            spatial analysis methods must be subjected to a line-dissolve process to
            ensure that the results are simple.
            </para>
            <para>
            Constructed Points And The Precision Model: 
            The results computed by the set-theoretic methods may
            contain constructed points which are not present in the input <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s. 
            These new points arise from intersections between line segments in the
            edges of the input <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s. In the general case it is not
            possible to represent constructed points exactly. This is due to the fact
            that the coordinates of an intersection point may contain twice as many bits
            of precision as the coordinates of the input line segments. In order to
            represent these constructed points explicitly, NTS must truncate them to fit
            the <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/>. 
            Unfortunately, truncating coordinates moves them slightly. Line segments
            which would not be coincident in the exact result may become coincident in
            the truncated representation. This in turn leads to "topology collapses" --
            situations where a computed element has a lower dimension than it would in
            the exact result. 
            When NTS detects topology collapses during the computation of spatial
            analysis methods, it will throw a <see cref="T:NetTopologySuite.Geometries.TopologyException"/>. 
            If possible the exception will report the location of the collapse. 
            </para>
            <para>
            NOTE: <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> 
            are overridden, so that when two topologically equal Geometries are added 
            to collections and hash table implementations, they will collide. 
            This behavior is <strong>not</strong> desired in many cases, and is
            the opposite of JTS and previous versions of NTS. To get the desired behavior, 
            use <see cref="F:NetTopologySuite.Geometries.GeometryReferenceEqualityComparer`1.Default"/> as 
            the key equality comparer. The reasoning for this change is twofold. First, 
            <see cref="T:GeoAPI.Geometries.ISpatialRelation`1"/> includes 
            <see cref="T:System.IEquatable`1"/> to derive the Equals method. 
            The sematics for this interface imply that the type-specific equality is
            value-based, since if it was reference equality, the interface would not 
            be implemented. Given the semantics of spatial relations, where two 
            <see cref="T:GeoAPI.Geometries.IGeometry"/> are equal if their coordinate-by-coordinate values are equal,
            implementing this interface makes sense. Second, this version of NTS is moving
            geometry objects toward immutability. This will allow greater ability to do
            distributed spatial processing and use functional-programming constructs as NTS evolves.
            If a geometry instance is immutable, value-type equality is more meaningful and more 
            desired. The use of collections and hash table implementations which rely on reference
            equality become more of an implementation detail which can be effectively hidden
            in instances where it is needed by a 
            <see cref="T:NetTopologySuite.Geometries.GeometryReferenceEqualityComparer`1"/>. 
            </para>
            <para>
            DEVELOPER NOTE: should we implement a ReferenceGeometryCollection and ReferenceGeometryDictionary
            to alleviate the increase burden on NTS users?
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.CompareTo(System.Object)">
            <summary>
            Returns whether this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is greater than, 
            equal to, or less than another <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>. 
            </summary>
            <param name="other">
            A <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to 
            compare this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <paramref name="other"/>, 
            as defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
            <remarks>
            If their classes are different, they are compared using the following
            ordering:
                <see cref="T:NetTopologySuite.Geometries.Point`1"/> (lowest),
                <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>,
                <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>,
                <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiPolygon`1"/>,
                <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> (highest).
            If the two <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s have the same class, their first
            elements are compared. If those are the same, the second elements are
            compared, etc.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.CompareTo(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Returns whether this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is greater than, 
            equal to, or less than another <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>. 
            </summary>
            <param name="other">
            A <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to 
            compare this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <paramref name="other"/>, 
            as defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
            <remarks>
            If their classes are different, they are compared using the following
            ordering:
                <see cref="T:NetTopologySuite.Geometries.Point`1"/> (lowest),
                <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>,
                <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>,
                <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiPolygon`1"/>,
                <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> (highest).
            If the two <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s have the same class, their first
            elements are compared. If those are the same, the second elements are
            compared, etc.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Equals(GeoAPI.Geometries.IGeometry)">
            <summary>
            Returns <see langword="true"/> if the DE-9IM intersection matrix for the two
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s is T*F**FFF*.
            </summary>
            <param name="g">
            The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to compare this 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <returns>
            <see langword="true"/> if the two <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s are equal.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Normalize">
            <summary>
            Converts this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> to normal form (or 
            canonical form).
            </summary>
            <remarks>
            Normal form is a unique representation for 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s. It can be used to test whether two <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s are equal
            in a way that is independent of the ordering of the coordinates within
            them. Normal form equality is a stronger condition than topological
            equality, but weaker than pointwise equality. The definitions for normal
            form use the standard lexicographical ordering for coordinates. "Sorted in
            order of coordinates" means the obvious extension of this ordering to
            sequences of coordinates.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Distance(GeoAPI.Geometries.IGeometry{`0})">
            <summary>  
            Returns the minimum distance between this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            and the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> g.
            </summary>
            <param name="g">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> from which to compute the distance.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Buffer(System.Double)">
            <summary>
            Returns a buffer region around this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the Geometry with a disc of radius <c>distance</c>.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/> of the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <returns>
            All points whose distance from this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Buffer(System.Double,System.Int32)">
            <summary>
            Returns a buffer region around this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/> of the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <param name="quadrantSegments">The number of segments to use to approximate a quadrant of a circle.</param>
            <returns>
            All points whose distance from this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Buffer(System.Double,GeoAPI.Operations.Buffer.BufferStyle)">
            <summary>
            Returns a buffer region around this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> having the given width.
            The buffer of a Geometry is the Minkowski sum or difference of the Geometry with a disc of radius <c>distance</c>.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/> of the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            All points whose distance from this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Buffer(System.Double,System.Int32,GeoAPI.Operations.Buffer.BufferStyle)">
            <summary>
            Returns a buffer region around this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> having the given
            width and with a specified number of segments used to approximate curves.
            The buffer of a Geometry is the Minkowski sum of the Geometry with
            a disc of radius <c>distance</c>.  Curves in the buffer polygon are
            approximated with line segments.  This method allows specifying the
            accuracy of that approximation.
            </summary>
            <param name="distance">
            The width of the buffer, interpreted according to the
            <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/> of the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <param name="quadrantSegments">
            The number of segments to use to approximate a quadrant of a circle.
            </param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>
            All points whose distance from this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            are less than or equal to <c>distance</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Intersection(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Returns a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> representing the points shared by this
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> and <c>other</c>.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to compute the intersection.</param>
            <returns>The points common to the two <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Union(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Returns a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> representing all the points in this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            and <c>other</c>.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to compute the union.</param>
            <returns>A set combining the points of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> and the points of <c>other</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.Difference(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Returns a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> representing the points making up this
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> that do not make up <c>other</c>. This method
            returns the closure of the resultant <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to compute the difference.</param>
            <returns>The point set difference of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with <c>other</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.SymmetricDifference(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Returns a set combining the points in this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> not in
            <c>other</c>, and the points in <c>other</c> not in this
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>. This method returns the closure of the resultant
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to compute the symmetric difference.</param>
            <returns>The point set symmetric difference of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with <c>other</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.ConvexHull">
            <summary>
            Returns the smallest convex <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> that contains all the
            points in the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>. This obviously applies only to <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            s which contain 3 or more points.
            </summary>
            <returns>the minimum-area convex polygon containing this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>'s points.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.IsEquivalentClass(GeoAPI.Geometries.IGeometry)">
            <summary>
            Returns whether the two <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s are equal, 
            from the point of view of the <see cref="M:NetTopologySuite.Geometries.Geometry`1.EqualsExact(GeoAPI.Geometries.IGeometry{`0})"/> method. 
            Called by <c>EqualsExact</c>. In general, two 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> classes are considered to be
            "equivalent" only if they are the same class. 
            An exception is <c>LineString</c>, which is considered to be 
            equivalent to its subclasses.
            </summary>
            <param name="other">
            The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to compare 
            this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> for equality.
            </param>
            <returns>
            <see langword="true"/> if the classes of the two 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s are considered 
            to be equal by the <see cref="M:NetTopologySuite.Geometries.Geometry`1.EqualsExact(GeoAPI.Geometries.IGeometry{`0})"/> method.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.CheckNotNonEmptyGeometryCollection(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Throws an exception if <paramref name="g"/> 's type is 
            <see cref="T:GeoAPI.Geometries.IGeometryCollection`1"/> 
            (its subclasses do not trigger an exception).
            </summary>
            <param name="g">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> to check.</param>
            <exception cref="T:System.ArgumentException">
            if <paramref name="g"/> is a <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>, 
            but not one of its subclasses.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.ComputeExtentsInternal">
            <summary>
            Returns the minimum and maximum x and y values in this 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>, or a null <see cref="!:Extents&lt;TCoordinate&gt;"/> 
            if this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is empty.
            </summary>
            <remarks>
            Unlike <see cref="P:NetTopologySuite.Geometries.Geometry`1.Extents"/> or <see cref="P:NetTopologySuite.Geometries.Geometry`1.ExtentsInternal"/>, this method 
            calculates the <see cref="!:Extents&lt;TCoordinate&gt;"/>
            each time it is called; <see cref="P:NetTopologySuite.Geometries.Geometry`1.Extents"/> caches the result
            of this method.        
            </remarks>
            <returns>
            This <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s bounding box; 
            if the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            is empty, <see cref="!:Extents&lt;TCoordinate&gt;.IsEmpty"/> will return <see langword="true"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.CompareToSameClass(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Returns whether this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is greater than, equal to,
            or less than another <see cref="T:GeoAPI.Geometries.IGeometry`1"/> having the same class.
            </summary>
            <param name="other">
            A <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> having the same class as this 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <c>o</c>, as
            defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.isGeometryCollection(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Returns <see langword="true"/> if <c>g</c>'s class is <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>. 
            (its subclasses do not trigger an exception).
            </summary>
            <param name="g">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> to check.</param>
            <exception cref="T:System.ArgumentException">
            If <c>g</c> is a <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>, but not one of its subclasses.
            </exception>        
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.ToString">
            <summary>
            Returns the Well-Known Text representation of this 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <remarks>
            For a definition of the Well-Known Text format, see the OpenGIS Simple
            Features Specification.
            </remarks>
            <returns>
            The Well-Known Text representation of this 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Geometry`1.CompareTo(GeoAPI.Geometries.IGeometry)">
            <summary>
            Returns whether this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is greater than, 
            equal to, or less than another <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>. 
            </summary>
            <param name="other">
            A <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with which to 
            compare this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>
            <returns>
            A positive number, 0, or a negative number, depending on whether
            this object is greater than, equal to, or less than <paramref name="other"/>, 
            as defined in "Normal Form For Geometry" in the NTS Technical
            Specifications.
            </returns>
            <remarks>
            If their classes are different, they are compared using the following
            ordering:
                <see cref="T:NetTopologySuite.Geometries.Point`1"/> (lowest),
                <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>,
                <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>,
                <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
                <see cref="T:NetTopologySuite.Geometries.MultiPolygon`1"/>,
                <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> (highest).
            If the two <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s have the same class, their first
            elements are compared. If those are the same, the second elements are
            compared, etc.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.GeometryCount">
            <summary>
            Returns the number of Geometries in a GeometryCollection,
            or 1, if the geometry is not a collection.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Area">
            <summary>  
            Returns the area of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            Areal Geometries have a non-zero area.
            They override this function to compute the area.
            Others return 0.0
            </summary>
            <returns>The area of the Geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Length">
            <summary> 
            Returns the length of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            Linear geometries return their length.
            Areal geometries return their perimeter.
            They override this function to compute the length.
            Others return 0.0
            </summary>
            <returns>The length of the Geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.InteriorPoint">
            <summary>
            Computes an interior point of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            An interior point is guaranteed to lie in the interior of the Geometry,
            if it possible to calculate such a point exactly. Otherwise,
            the point may lie on the boundary of the point.
            </summary>
            <returns>
            An <see cref="T:GeoAPI.Geometries.IPoint`1"/> which is in the 
            interior of this Geometry.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Centroid">
            <summary> 
            Computes the centroid of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            The centroid is equal to the centroid of the set of component Geometries of highest
            dimension (since the lower-dimension geometries contribute zero "weight" to the centroid).
            </summary>
            <returns>A Point which is the centroid of this Geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Envelope">
            <summary>  
            Returns this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s bounding box. If this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            is the empty point, returns an empty <c>Point</c>. If the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            is a point, returns a non-empty <c>Point</c>. Otherwise, returns a
            <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> whose points are (minx, miny), (maxx, miny), (maxx,
            maxy), (minx, maxy), (minx, miny).
            </summary>
            <returns>    
            An empty <c>Point</c> (for empty <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s), a
            <c>Point</c> (for <c>Point</c>s) or a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>
            (in all other cases).
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Extents">
            <summary>
            Gets the bounding box of the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Factory">
            <summary> 
            Gets the factory which contains the context in which this point was created.
            </summary>
            <returns>The factory for this point.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.PrecisionModel">
            <summary>  
            Returns the <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/> 
            used by the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <returns>    
            The specification of the grid of allowable points, for this
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> and all other <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.BoundaryDimension">
            <summary> 
            Returns the dimension of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s inherent boundary.
            </summary>
            <returns>    
            The dimension of the boundary of the class implementing this
            interface, whether or not this object is the empty point. Returns
            <c>Dimension.False</c> if the boundary is the empty point.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Dimension">
            <summary> 
            Gets the dimension of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <returns>  
            The dimension of the class implementing this interface, whether
            or not this object is the empty point.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.IsEmpty">
            <summary> 
            Returns whether or not the set of points in this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is empty.
            </summary>
            <returns><see langword="true"/> if this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> equals the empty point.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.IsSimple">
            <summary> 
            Returns <see langword="false"/> if the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> not simple.
            Subclasses provide their own definition of "simple". If
            this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is empty, returns <see langword="true"/>. 
            </summary>
            <remarks>
            In general, the SFS specifications of simplicity seem to follow the
            following rule:
             A Geometry is simple if the only self-intersections are at boundary points.
            For all empty <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s, <c>IsSimple==true</c>.
            </remarks>
            <returns>    
            <see langword="true"/> if this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> has any points of
            self-tangency, self-intersection or other anomalous points.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.IsValid">
            <summary>  
            Tests the validity of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            Subclasses provide their own definition of "valid".
            </summary>
            <returns><see langword="true"/> if this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is valid.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.PointCount">
            <summary>  
            Returns the count of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s vertices.
            </summary>
            <remarks>
            The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s contained by composite 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s must be 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> instances; that is, 
            they must implement <see cref="!:IGeometry&lt;TCoordinate&gt;.PointCount"/>.
            </remarks>
            <returns>The number of vertices in this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.GeometryType">
            <summary>  
            Returns the name of this object's interface.
            </summary>
            <returns>The name of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s most specific interface.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Srid">
            <summary>  
            Gets or sets the ID of the Spatial Reference System used by the 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>   
            <remarks>
            NTS supports Spatial Reference System information in the simple way
            defined in the SFS. A Spatial Reference System ID (SRID) is present in
            each <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> object. 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> provides basic
            accessor operations for this field, but no others. 
            <para>
            The SRID is represented as a nullable <see cref="T:System.Int32"/>.
            </para>
            </remarks>     
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.UserData">
            <summary> 
            Gets or sets the user data object for this point, if any.
            </summary>
            <remarks>
            A simple scheme for applications to add their own custom data to a Geometry.
            Note that user data objects are not present in geometries created by
            construction methods.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.Boundary">
            <summary>  
            Gets the boundary, or the empty point if this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            is empty. For a discussion of this function, see the OpenGIS Simple
            Features Specification. As stated in SFS Section 2.1.13.1, "the boundary
            of a Geometry is a set of Geometries of the next lower dimension."
            </summary>
            <returns>The closure of the combinatorial boundary of this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Geometry`1.ExtentsInternal">
            <summary> 
            Returns the minimum and maximum x and y values in this 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>, or a null 
            <see cref="!:Extents&lt;TCoordinate&gt;"/> if this 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is empty.
            </summary>
            <returns>    
            This <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s bounding box; 
            if the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            is empty, <c>Envelope.IsNull</c> will return <see langword="true"/>.
            </returns>
        </member>
        <member name="F:NetTopologySuite.Geometries.GeometryCollection`1._geometries">
            <summary>
            Internal representation of this <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>.        
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <param name="geometries">
            The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s for this <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>,
            or <see langword="null"/> or an empty array to create the empty
            point. Elements may be empty <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s,
            but not <see langword="null"/>s.
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> 
            with <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/> <c> == </c> <see cref="!:PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}},GeoAPI.Geometries.IGeometryFactory{`0})">
            <param name="geometries">
            The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s for this <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>,
            or <see langword="null"/> or an empty array to create the empty
            point. Elements may be empty <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s,
            but not <see langword="null"/>s.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection`1.System#Collections#Generic#IList{GeoAPI#Geometries#IGeometry}#IndexOf(GeoAPI.Geometries.IGeometry)">
            <summary>
            Finds the index of a geometry is in the list.
            </summary>
            <param name="item">
            The <see cref="T:GeoAPI.Geometries.IGeometry"/> to find the index of.
            </param>
            <returns>
            The index of the geometry if it is in the list,
            <value>-1</value> otherwise.
            </returns>
            <remarks>
            The <paramref name="item"/> is treated as an 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> for purposes of 
            membership testing. If it isn't, this method returns 
            <value>-1</value>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection`1.System#Collections#Generic#ICollection{GeoAPI#Geometries#IGeometry}#Contains(GeoAPI.Geometries.IGeometry)">
            <summary>
            Determines if a geometry is present in the collection.
            </summary>
            <param name="item">
            The <see cref="T:GeoAPI.Geometries.IGeometry"/> to check.
            </param>
            <returns>
            <see langword="true"/> if the geometry is in the collection,
            <see langword="false"/> otherwise.
            </returns>
            <remarks>
            The <paramref name="item"/> is treated as an 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> for purposes of 
            membership testing. If it isn't, this method returns 
            <see langword="false"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection`1.System#Collections#Generic#ICollection{GeoAPI#Geometries#IGeometry}#Remove(GeoAPI.Geometries.IGeometry)">
            <summary>
            Removes a geometry from the collection if is present in the collection.
            </summary>
            <param name="item">
            The <see cref="T:GeoAPI.Geometries.IGeometry"/> to remove.
            </param>
            <returns>
            <see langword="true"/> if the geometry was removed from the collection,
            <see langword="false"/> otherwise.
            </returns>
            <remarks>
            The <paramref name="item"/> is treated as an 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> for purposes of 
            membership testing. If it isn't, this method returns 
            <see langword="false"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection`1.GetEnumerator">
            <summary>
            Returns a <see cref="T:NetTopologySuite.Geometries.GeometryCollectionEnumerator`1"/>:
            this IEnumerator returns the parent geometry as first element.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollection`1.HasNonEmptyElements``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Represents an empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection`1.Area">
            <summary>  
            Returns the area of this <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>.
            </summary>        
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection`1.Length">
            <summary>  
            Returns the length of this <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>.
            </summary>        
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection`1.Coordinates">
            <summary>
            Collects all coordinates of all subgeometries into an Array.
            Note that while changes to the coordinate objects themselves
            may modify the Geometries in place, the returned Array as such 
            is only a temporary container which is not synchronized back.
            </summary>
            <returns>The collected coordinates.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection`1.IsHomogeneous">
            <summary>
            Return <see langword="true"/> if all features in collection are of the same type.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection`1.Item(System.Int32)">
            <summary>
            Returns an element Geometry from a GeometryCollection.
            </summary>
            <param name="index">The index of the geometry element.</param>
            <returns>
            The geometry contained in this geometry at the given 
            <paramref name="index"/>.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollection`1.Count">
            <summary>
            Returns the number of geometries contained by this <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.ILineString{`0}},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>.
            </summary>
            <param name="lineStrings">
            The <see cref="T:NetTopologySuite.Geometries.LineString`1"/>s for this 
            <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>,
            or <see langword="null"/> or an empty array to create the empty
            point. Elements may be empty <see cref="T:NetTopologySuite.Geometries.LineString`1"/>s,
            but not <see langword="null"/>s.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs an empty <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiLineString`1.Reverse">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/> in the reverse order to this object.
            Both the order of the component LineStrings
            and the order of their coordinate sequences are reversed.
            </summary>
            <returns>a <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/> in the reverse order.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiLineString`1.IsClosed">
            <summary>
            Gets a value indicating whether this instance is closed.
            </summary>
            <value>
            <see langword="true"/> if this instance is closed; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="T:NetTopologySuite.Geometries.LineSegment`1">
            <summary> 
            Represents a line segment defined by two <typeparamref name="TCoordinate"/>s.
            Provides methods to compute various geometric properties
            and relationships of line segments.
            This class is designed to be easily mutable (to the extent of
            having its contained points public).
            This supports a common pattern of reusing a single LineSegment
            object as a way of computing segment properties on the
            segments defined by arrays or lists of <typeparamref name="TCoordinate"/>s.
            </summary>
            <typeparam name="TCoordinate">The coordinate type to use.</typeparam>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.PointAlong(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Double)">
            <summary>
             Computes the {@link Coordinate} that lies a given
             fraction along the line defined by this segment.
             A fraction of <code>0.0</code> returns the start point of the segment;
             a fraction of <code>1.0</code> returns the end point of the segment.
             If the fraction is &lt; 0.0 or &gt; 1.0 the point returned 
             will lie before the start or beyond the end of the segment. 
            </summary>
            <param name="coordFact">factory to create the point</param>
            <param name="segmentLengthFraction">the fraction of the segment length along the line</param>
            <returns>the point at that distance</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.PointAlongOffset(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Double,System.Double)">
             
             
             
             
             
             
             
            
             @param segmentLengthFraction 
             @param offsetDistance 
                
             @return 
            <summary>
             Computes the <see cref="!:TCoordinate"/> that lies a given
             fraction along the line defined by this segment and offset from 
             the segment by a given distance.
             A fraction of <code>0.0</code> offsets from the start point of the segment;
             a fraction of <code>1.0</code> offsets from the end point of the segment.
             The computed point is offset to the left of the line if the offset distance is
             positive, to the right if negative.
            </summary>
            <param name="coordFact">Factory to create the <see cref="!:TCoordinate"/></param>
            <param name="segmentLengthFraction">the fraction of the segment length along the line</param>
            <param name="offsetDistance">the distance the point is offset from the segment (positive is to the left, negative is to the right)</param>
            <returns>the point at that distance and offset</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.CompareTo(NetTopologySuite.Geometries.LineSegment{`0})">
            <summary>
            Compares this object with the specified object for order.
            Uses the standard lexicographic ordering for the points in the LineSegment.
            </summary>
            <param name="other">
            The <see cref="T:NetTopologySuite.Geometries.LineSegment`1"/> with which this <c>LineSegment</c>
            is being compared.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this <c>LineSegment</c>
            is less than, equal to, or greater than the specified <c>LineSegment</c>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.OrientationIndex(NetTopologySuite.Geometries.LineSegment{`0})">
            <summary> 
            Determines the orientation of a LineSegment relative to this segment.
            The concept of orientation is specified as follows:
            Given two line segments A and L,
            A is to the left of a segment L if A lies wholly in the
            closed half-plane lying to the left of L
            A is to the right of a segment L if A lies wholly in the
            closed half-plane lying to the right of L
            otherwise, A has indeterminate orientation relative to L. This
            happens if A is collinear with L or if A crosses the line determined by L.
            </summary>
            <param name="seg">The <c>LineSegment</c> to compare.</param>
            <returns>
            1 if <c>seg</c> is to the left of this segment,        
            -1 if <c>seg</c> is to the right of this segment,
            0 if <c>seg</c> has indeterminate orientation relative to this segment.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.Distance(NetTopologySuite.Geometries.LineSegment{`0})">
            <summary> 
            Computes the distance between this line segment and another one.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.Distance(`0)">
            <summary> 
            Computes the distance between this line segment and a point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.DistancePerpendicular(`0)">
            <summary> 
            Computes the perpendicular distance between the (infinite) line defined
            by this line segment and a point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.ProjectionFactor(`0)">
            <summary>
            Compute the projection factor for the projection of the point p
            onto this <c>LineSegment</c>. The projection factor is the constant k
            by which the vector for this segment must be multiplied to
            equal the vector for the projection of p.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.Project(`0,GeoAPI.Coordinates.ICoordinateFactory{`0})">
            <summary> 
            Compute the projection of a point onto the line determined
            by this line segment.
            Note that the projected point
            may lie outside the line segment.  If this is the case,
            the projection factor will lie outside the range [0.0, 1.0].
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.Project(NetTopologySuite.Geometries.LineSegment{`0},GeoAPI.Coordinates.ICoordinateFactory{`0})">
            <summary> 
            Project a line segment onto this line segment and return the resulting
            line segment.  The returned line segment will be a subset of
            the target line line segment.  This subset may be null, if
            the segments are oriented in such a way that there is no projection.
            Note that the returned line may have zero length (i.e. the same endpoints).
            This can happen for instance if the lines are perpendicular to one another.
            </summary>
            <param name="seg">The line segment to project.</param>
            <returns>The projected line segment, or <see langword="null" /> if there is no overlap.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.ClosestPoint(`0,GeoAPI.Coordinates.ICoordinateFactory{`0})">
            <summary> 
            Computes the closest point on this line segment to another point.
            </summary>
            <param name="p">The point to find the closest point to.</param>
            <returns>
            A Coordinate which is the closest point on the line segment to the point p.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.ClosestPoints(NetTopologySuite.Geometries.LineSegment{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Computes the closest points on a line segment.
            </summary>
            <returns>
            A pair of Coordinates which are the closest points on the line segments.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.Intersection(NetTopologySuite.Geometries.LineSegment{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Computes an intersection point between two segments, if there is one.
            </summary>
            <remarks>
            There may be 0, 1 or many intersection points between two segments.
            If there are 0, a default <typeparamref name="TCoordinate"/> is returned. 
            If there is 1 or more, a single one is returned (chosen at the discretion 
            of the algorithm).  If more information is required about the details of the 
            intersection, the <see cref="T:NetTopologySuite.Algorithm.RobustLineIntersector`1"/> class should 
            be used, which returns an <see cref="!:Intersection&lt;TCoordinate&gt;"/> instance,
            which contains a variety of contextual data about the intersection.
            </remarks>
            <returns>
            An intersection point, or a default 
            <typeparamref name="TCoordinate"/> if there is none.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.Equals(System.Object)">
            <summary>  
            Returns <see langword="true"/> if <paramref name="other"/> 
            has the same values for its points.
            </summary>
            <param name="other">A <see cref="T:NetTopologySuite.Geometries.LineSegment`1"/> with
            which to do the comparison.</param>
            <returns>
            <see langword="true"/> if <paramref name="other"/> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineSegment`1.EqualsTopologically(NetTopologySuite.Geometries.LineSegment{`0})">
            <summary>
            Returns <see langword="true"/> if <c>other</c> is
            topologically equal to this LineSegment (e.g. irrespective
            of orientation).
            </summary>
            <param name="other">
            A <c>LineSegment</c> with which to do the comparison.
            </param>
            <returns>
            <see langword="true"/> if <c>other</c> is a <c>LineSegment</c>
            with the same values for the x and y ordinates.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment`1.Length">
            <summary>
            Computes the length of the line segment.
            </summary>
            <returns>The length of the line segment.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment`1.IsHorizontal">
            <summary> 
            Tests whether the segment is horizontal.
            </summary>
            <returns><see langword="true"/> if the segment is horizontal.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment`1.IsVertical">
            <summary>
            Tests whether the segment is vertical.
            </summary>
            <returns><see langword="true"/> if the segment is vertical.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment`1.Reversed">
            <summary> 
            Reverses the direction of the line segment.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment`1.Normalized">
            <summary> 
            Puts the line segment into a normalized form.
            This is useful for using line segments in maps and indexes when
            topological equality rather than exact equality is desired.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineSegment`1.Angle">
            <returns> 
            The angle this segment makes with the x-axis (in radians).
            </returns>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Positions.On">
            <summary>
             An indicator that a Location is <c>on</c> a GraphComponent (0)
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Positions.Left">
            <summary>
            An indicator that a Location is to the <c>left</c> of a GraphComponent (1)
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Positions.Right">
            <summary> 
            An indicator that a Location is to the <c>right</c> of a GraphComponent (2)
            </summary> 
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.Positions.Parallel">
            <summary> 
            An indicator that a Location is <c>is parallel to x-axis</c> of a GraphComponent (-1)
            /// </summary> 
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1">
            <summary>
             Computes the raw offset curve for a
             single <see cref="T:GeoAPI.Geometries.IGeometry`1"/> component (ring, line or point).
             A raw offset curve line is not noded -
             it may contain self-intersections (and usually will).
             The final buffer polygon is computed by forming a topological graph
             of all the noded raw curves and tracing outside contours.
             The points in the raw curve are rounded to the required precision model.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.CurveVertexSnapDistanceFactor">
            <summary>
             Factor which controls how close curve vertices can be to be snapped
             </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.InsideTurnVertexSnapDistanceFactor">
            <summary>
             Factor which controls how close curve vertices on inside turns can be to be snapped 
             </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.MaxClosingSegFraction">
            <summary>
             Factor which determines how short closing segs can be for round buffers
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.SimplifyFactor">
            <summary>
             Use a value which results in a potential distance error which is
             significantly less than the error due to 
             the quadrant segment discretization.
             For QS = 8 a value of 400 is reasonable.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1._filletAngleQuantum">
            <summary>
             The angle quantum with which to approximate a fillet curve
             (based on the input # of quadrant segments)
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1._maxCurveSegmentError">
            <summary>
             the max error of approximation (distance) between a quad segment and the true fillet curve
             </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1._closingSegFactor">
            <summary>
             The Closing Segment Factor controls how long
             "closing segments" are.  Closing segments are added
             at the middle of inside corners to ensure a smoother
             boundary for the buffer offset curve. 
             In some cases (particularly for round joins with default-or-better
             quantization) the closing segments can be made quite short.
             This substantially improves performance (due to fewer intersections being created).
             
             A closingSegFactor of 0 results in lines to the corner vertex
             A closingSegFactor of 1 results in lines halfway to the corner vertex
             A closingSegFactor of 80 results in lines 1/81 of the way to the corner vertex
             (this option is reasonable for the very common default situation of round joins
             and quadrantSegs >= 8)
             </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},GeoAPI.Coordinates.IPrecisionModel{`0},GeoAPI.Operations.Buffer.BufferParameters)">
            <summary>
             Constructs an instance of this class
            </summary>
            <param name="geomFact">geometry factory to use</param>
            <param name="precisionModel">precision model</param>
            <param name="bufParams">paramters to compute the buffer</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.GetLineCurve(System.Collections.Generic.IEnumerable{`0},System.Double)">
            <summary>
            This method handles single points as well as lines.
            Lines are assumed to not be closed (the function will not
            fail for closed lines, but will generate superfluous line caps).
            </summary>
            <returns> A set of coordinate sets.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.GetRingCurve(System.Collections.Generic.IEnumerable{`0},NetTopologySuite.GeometriesGraph.Positions,System.Double)">
            <summary>
             This method handles the degenerate cases of single points and lines, as well as rings.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.SimplifyTolerance(System.Double)">
            <summary>
             Computes the distance tolerance to use during input line simplification.
            </summary>
             <param name="bufDistance">the buffer distance</param>
             <returns>the simplification tolerance</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddFirstSegment">
            <summary>
             Add first offset point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddLastSegment">
            <summary>
             Add last offset point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddOutsideTurn(NetTopologySuite.Algorithm.Orientation,System.Boolean)">
            Adds the offset points for an outside (convex) turn
            
            @param orientation
            @param addStartPoint
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddInsideTurn(NetTopologySuite.Algorithm.Orientation,System.Boolean)">
            <summary>
             Adds the offset points for an inside (concave) turn
            </summary>
             <param name="orientation"></param>
             <param name="addStartPoint"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.ComputeOffsetSegment(NetTopologySuite.Geometries.LineSegment{`0},NetTopologySuite.GeometriesGraph.Positions,System.Double)">
             Compute an offset segment for an input segment on a given side and at a given distance.
             The offset points are computed in full double precision, for accuracy.
            
             @param seg the segment to offset
             @param side the side of the segment ({@link Position}) the offset lies on
             @param distance the offset distance
             @param offset the points computed for the offset segment
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddLineEndCap(`0,`0)">
            Add an end cap around point p1, terminating a line segment coming from p0
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddMitreJoin(`0,NetTopologySuite.Geometries.LineSegment{`0},NetTopologySuite.Geometries.LineSegment{`0},System.Double)">
            Adds a mitre join connecting the two reflex offset segments.
            The mitre will be beveled if it exceeds the mitre ratio limit.
            
            @param offset0 the first offset segment
            @param offset1 the second offset segment
            @param distance the offset distance
            <summary>
             Adds a mitre join connecting the two reflex offset segments.
             The mitre will be beveled if it exceeds the mitre ratio limit.
            </summary>
             <param name="p"></param>
             <param name="offset0"></param>
             <param name="offset1"></param>
             <param name="distance"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddLimitedMitreJoin(NetTopologySuite.Geometries.LineSegment{`0},NetTopologySuite.Geometries.LineSegment{`0},System.Double,System.Double)">
            Adds a limited mitre join connecting the two reflex offset segments.
            A limited mitre is a mitre which is beveled at the distance
            determined by the mitre ratio limit.
            
            @param offset0 the first offset segment
            @param offset1 the second offset segment
            @param distance the offset distance
            @param mitreLimit the mitre limit ratio
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddBevelJoin(NetTopologySuite.Geometries.LineSegment{`0},NetTopologySuite.Geometries.LineSegment{`0})">
            Adds a bevel join connecting the two offset segments
            around a reflex corner.
            
            @param offset0 the first offset segment
            @param offset1 the second offset segment
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddFillet(`0,`0,`0,NetTopologySuite.Algorithm.Orientation,System.Double)">
            Add points for a circular fillet around a reflex corner.
            Adds the start and end points
            
            @param p base point of curve
            @param p0 start point of fillet curve
            @param p1 endpoint of fillet curve
            @param direction the orientation of the fillet
            @param radius the radius of the fillet
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddFillet(`0,System.Double,System.Double,NetTopologySuite.Algorithm.Orientation,System.Double)">
            <summary>
             Adds points for a circular fillet arc
             between two specified angles.
             The start and end point for the fillet are not added -
             the caller must add them if required.
            </summary>
             <param name="p">center of arc</param>
             <param name="startAngle"></param>
             <param name="endAngle"></param>
             <param name="direction">is -1 for a CW angle, 1 for a CCW angle</param>
             <param name="radius">the radius of the fillet</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddCircle(`0,System.Double)">
            <summary>
             Adds a CW circle around a point
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.AddSquare(`0,System.Double)">
            <summary>
             Adds a CW square around a point
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110`1.BufferParameters">
            <value>
            The parameters for buffer generation
            </value>
        </member>
        <member name="T:NetTopologySuite.Noding.ISegmentString`1">
            <summary>
             An interface for classes which represent a sequence of contiguous line segments.
             SegmentStrings can carry a context object, which is useful
             for preserving topological or parentage information.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentString`1.Context">
            <summary>
             Gets/Sets the user-defined data for this segment string.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentString`1.Coordinates">
            <summary>
             Points that make up SegmentString
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentString`1.Count">
            <summary>
             Size of Coordinate Sequence
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentString`1.IsClosed">
            <summary>
            States whether SegmentString is closed
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.INodableSegmentString`1">
            <summary>An interface for classes which support adding nodes to a segment string.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Noding.INodableSegmentString`1.AddIntersection(`0,System.Int32)">
            <summary>Adds an intersection node for a given point and segment to this segment string.
            </summary>
            <param name="intPt">the location of the intersection</param>
            <param name="segmentIndex">the index of the segment containing the intersection</param>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Orientation.Clockwise">
            <summary> 
            A value that indicates an orientation of clockwise, or a right turn.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Orientation.Right">
            <summary> 
            A value that indicates an orientation of clockwise, or a right turn.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Orientation.CounterClockwise">
            <summary>
            A value that indicates an orientation of counterclockwise, or a left turn.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Orientation.Left">
            <summary>
            A value that indicates an orientation of counterclockwise, or a left turn.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Orientation.Collinear">
            <summary>
            A value that indicates an orientation of collinear, or no turn (straight).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Orientation.Straight">
            <summary>
            A value that indicates an orientation of collinear, or no turn (straight).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.CGAlgorithms`1">
            <summary>
            Specifies and implements various fundamental computational geometric algorithms.
            The algorithms supplied in this class are robust for Double-precision floating point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.OrientationIndex(`0,`0,`0)">
            <summary> 
            Returns the index of the direction of the point <paramref name="q"/>
            relative to a vector specified by 
            <paramref name="p1"/><c>-</c><paramref name="p2"/>.
            </summary>
            <param name="p1">The origin point of the vector.</param>
            <param name="p2">The final point of the vector.</param>
            <param name="q">The point to compute the direction to.</param>
            <returns> 
            1 if q is counter-clockwise (left) from p1-p2,
            -1 if q is clockwise (right) from p1-p2,
            0 if q is collinear with p1-p2.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.LocatePointInRing(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Determines whether a point lies in the interior, on the boundary, or in the exterior
             of a ring. The ring may be oriented in either direction.
             This method does <i>not</i> first check the point against the envelope
             of the ring.
            </summary>
            <param name="p">point to check for ring inclusion</param>
            <param name="ring">an array of coordinates representing the ring (which must have first point identical to last point)</param>
            <returns>the <see cref="T:GeoAPI.Geometries.Locations"/> of p relative to the ring</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.IsPointInRing(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Test whether a point lies inside a ring.
            The ring may be oriented in either direction.
            If the point lies on the ring boundary the result of this method is unspecified.
            This algorithm does not attempt to first check the point against the envelope
            of the ring.
            </summary>
            <param name="p">Point to check for ring inclusion.</param>
            <param name="ring">Assumed to have first point identical to last point.</param>
            <returns><see langword="true"/> if p is inside ring.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.IsOnLine(`0,System.Collections.Generic.IEnumerable{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary> 
            Test whether a point lies on the line segments defined by a
            list of coordinates.
            </summary>
            <returns> 
            <see langword="true"/> true if
            the point is a vertex of the line or lies in the interior of a line
            segment in the linestring.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.IsCCW(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Computes whether a ring defined by an array of <typeparamref name="TCoordinate"/>s 
            is oriented counter-clockwise.
            </summary>
            <remarks>
            <para>
            The list of points is assumed to have the first and last points equal.
            This will handle coordinates which contain repeated points.
            This algorithm is only guaranteed to work with valid rings.
            If the ring is invalid (e.g. self-crosses or touches),
            the computed result may not be correct.
            </para>
            <para>
            In NTS v2.0, this method was modified to handle enumerations of coordinates
            which allows clients to send it results of coordinate queries.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.ComputeOrientation(`0,`0,`0)">
            <summary>
            Computes the orientation of a point q to the directed line segment p1-p2.
            </summary>
            <remarks>
            The orientation of a point relative to a directed line segment indicates
            which way you turn to get to q after travelling from p1 to p2.
            </remarks>
            <returns> 
            1 if q is counter-clockwise from p1-p2,
            -1 if q is clockwise from p1-p2,
            0 if q is collinear with p1-p2-
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.DistancePointLine(`0,`0,`0)">
            <summary> 
            Computes the distance from a point p to a line segment AB.
            Note: NON-ROBUST!
            </summary>
            <param name="p">The point to compute the distance for.</param>
            <param name="A">One point of the line.</param>
            <param name="B">Another point of the line (must be different to A).</param>
            <returns> The distance from p to line segment AB.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.DistancePointLinePerpendicular(`0,`0,`0)">
            <summary> 
            Computes the perpendicular distance from a point p
            to the (infinite) line containing the points AB
            </summary>
            <param name="p">The point to compute the distance for.</param>
            <param name="A">One point of the line.</param>
            <param name="B">Another point of the line (must be different to A).</param>
            <returns>The perpendicular distance from p to line AB.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.DistanceLineLine(`0,`0,`0,`0)">
            <summary> 
            Computes the distance from a line segment AB to a line segment CD.
            Note: NON-ROBUST!
            </summary>
            <param name="a">A point of one line.</param>
            <param name="b">The second point of the line (must be different to A).</param>
            <param name="c">One point of the line.</param>
            <param name="d">Another point of the line (must be different to A).</param>
            <returns>The distance from line segment AB to line segment CD.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.SignedArea(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns the signed area for a ring.  The area is positive if
            the ring is oriented CW.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CGAlgorithms`1.Length(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary> 
            Computes the length of a linestring specified by a sequence of points.
            </summary>
            <param name="coordinates">The points specifying the linestring.</param>
            <returns>The length of the linestring.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1" -->
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Quadedge.Vertex{`0}},System.Double)">
            <summary>
             Creates a Conforming Delaunay Triangulation based on the given
             unconstrained initial vertices. The initial vertex set should not contain
             any vertices which appear in the constraint set.
            </summary>
             <param name="geometryFactory">a factory used to create geometries</param>
            <param name="initialVertices">a collection of <see cref="T:NetTopologySuite.Triangulate.ConstraintVertex`1"/></param>
            <param name="tolerance">the distance tolerance below which points are considered identical</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.SetConstraints(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Segment{`0}},System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Quadedge.Vertex{`0}})">
            <summary>
             Sets the constraints to be conformed to by the computed triangulation.
             The unique set of vertices (as {@link ConstraintVertex}es)
             forming the constraints must also be supplied.
             Supplying it explicitly allows the ConstraintVertexes to be initialized
             appropriately(e.g. with external data), and avoids re-computing the unique set
             if it is already available.
            </summary>
            <param name="segments">a list of the constraint <see cref="T:NetTopologySuite.Triangulate.Segment`1"/>s</param>
            <param name="segVertices">the set of unique <see cref="T:NetTopologySuite.Triangulate.ConstraintVertex`1"/>es referenced by the segments</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.GetSubdivision">
            <summary>
             Gets the <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/> which represents the triangulation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.CreateVertex(`0,NetTopologySuite.Triangulate.Segment{`0})">
            <summary>Creates a vertex on a constraint segment</summary>
             <param name="p">the location of the vertex to create</param>
             <param name="seg">the constraint segment it lies on</param>
             <returns>the new constraint vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.InsertSites(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Quadedge.Vertex{`0}})">
            <summary>Inserts all sites in a collection</summary>
             <param name="vertices">a collection of ConstraintVertex</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.InsertSite(`0)">
            <summary>
             Inserts a site into the triangulation, maintaining the conformal Delaunay property.
             This can be used to further refine the triangulation if required
             (e.g. to approximate the medial axis of the constraints,
             or to improve the grading of the triangulation).
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.FormInitialDelaunay">
            <summary>
             Computes the Delaunay triangulation of the initial sites.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.EnforceConstraints">
            
            
            @throws ConstraintEnforcementException
                      
            <summary>
             Enforces the supplied constraints into the triangulation.
            </summary>
            <exception cref="T:NetTopologySuite.Triangulate.ConstraintEnforcementException`1">if the constraints cannot be enforced</exception>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.FindNonGabrielPoint(NetTopologySuite.Triangulate.Segment{`0})">
            Given a set of points stored in the kd-tree and a line segment defined by
            two points in this set, finds a {@link Coordinate} in the circumcircle of
            the line segment, if one exists. This is called the Gabriel point - if none
            exists then the segment is said to have the Gabriel condition. Uses the
            heuristic of finding the non-Gabriel point closest to the midpoint of the
            segment.
            
            @param p
                     start of the line segment
            @param q
                     end of the line segment
            @return a point which is non-Gabriel
            @return null if no point is non-Gabriel
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.SplitPointFinder">
            <summary>
             Gets/Sets the <see cref="T:NetTopologySuite.Triangulate.IConstraintSplitPointFinder`1"/> to be used during constraint enforcement.
             Different splitting strategies may be appropriate for special situations. 
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.Tolerance">
            <summary>
             Gets the tolerance value used to construct the triangulation.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.VertexFactory">
            <summary>
             Gets the <see cref="T:NetTopologySuite.Triangulate.IConstraintVertexFactory`1"/> used to create new constraint vertices at split points.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.KdTree">
            <summary>
             Gets the <see cref="!:KdTree&lt;TCoordinate&gt;"/> which contains the vertices of the triangulation.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.InitialVertices">
            <summary>
             Gets the sites (vertices) used to initialize the triangulation.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.ConstraintSegments">
            <summary>
             Gets the <see cref="T:NetTopologySuite.Triangulate.Segment`1"/>{@link Segment}s which represent the constraints.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulator`1.ConvexHull">
            <summary> 
             Gets the convex hull of all the sites in the triangulation, including constraint vertices. Only valid after the constraints have been enforced.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.PlanarGraph`1">
            <summary>
            Represents a directed graph which is embeddable in a planar surface.
            </summary>
            <remarks>
            This class and the other classes in this package serve as a framework for
            building planar graphs for specific algorithms. This class must be
            subclassed to expose appropriate methods to construct the graph. This allows
            controlling the types of graph components (<see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s,
            <see cref="T:NetTopologySuite.Planargraph.Edge`1"/>s and <see cref="T:NetTopologySuite.Planargraph.Node`1"/>s) which can be added to the graph. An
            application which uses the graph framework will almost always provide
            subclasses for one or more graph components, which hold application-specific
            data and graph algorithms.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.FindNode(`0)">
            <summary>
            Returns the Node at the given location, or null if no Node is there.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.Contains(NetTopologySuite.Planargraph.Edge{`0})">
            <summary>
            Tests whether an <see cref="T:NetTopologySuite.Planargraph.Edge`1"/> 
            is contained in this graph.
            </summary>
            <param name="e">The <see cref="T:NetTopologySuite.Planargraph.Edge`1"/> to test.</param>
            <returns>
            <see langword="true"/> if the <see cref="T:NetTopologySuite.Planargraph.Edge`1"/> 
            is contained in this graph.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.Remove(NetTopologySuite.Planargraph.Edge{`0})">
            <summary>
            Removes an Edge and its associated DirectedEdges from their from-Nodes and
            from this PlanarGraph. Note: This method does not remove the Nodes associated
            with the Edge, even if the removal of the Edge reduces the degree of a
            Node to zero.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.Remove(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary> 
            Removes DirectedEdge from its from-Node and from this PlanarGraph. Note:
            This method does not remove the Nodes associated with the DirectedEdge,
            even if the removal of the DirectedEdge reduces the degree of a Node to
            zero.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.Remove(NetTopologySuite.Planargraph.Node{`0})">
            <summary>
            Removes a node from the graph, along with any associated DirectedEdges and
            Edges.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.FindNodesOfDegree(System.Int32)">
            <summary>
            Returns all <see cref="T:NetTopologySuite.Planargraph.Node`1"/>s with the 
            given number of <see cref="T:NetTopologySuite.Planargraph.Edge`1"/>s around it.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.Add(NetTopologySuite.Planargraph.Node{`0})">
            <summary>
            Adds a node to the map, replacing any that is already at that location.
            Only subclasses can add Nodes, to ensure Nodes are of the right type.
            </summary>
            <returns>The added node.</returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.Add(NetTopologySuite.Planargraph.Edge{`0})">
            <summary>
            Adds the Edge and its DirectedEdges with this PlanarGraph.
            Assumes that the Edge has already been created with its associated DirectEdges.
            Only subclasses can add Edges, to ensure the edges added are of the right class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.PlanarGraph`1.Add(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Adds the Edge to this PlanarGraph; only subclasses can add DirectedEdges,
            to ensure the edges added are of the right class.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.PlanarGraph`1.Nodes">
            <summary>
            Returns the Nodes in this PlanarGraph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.PlanarGraph`1.DirectedEdges">
            <summary> 
            Returns a set of the <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s 
            in this <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/>, in the order in which they
            were added.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.PlanarGraph`1.Edges">
            <summary>
            Returns the Edges that have been added to this PlanarGraph.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.RectangleIntersects`1">
            <summary>
            Optimized implementation of spatial predicate "intersects"
            for cases where the first <see cref="T:GeoAPI.Geometries.IGeometry`1"/> is a rectangle.    
            As a further optimization, this class can be used directly 
            to test many geometries against a single rectangle.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Predicate.RectangleIntersects`1.MaximumScanSegmentCount">
            <summary>     
            Crossover size at which brute-force intersection scanning
            is slower than indexed intersection detection.
            Must be determined empirically.  Should err on the
            safe side by making value smaller rather than larger.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleIntersects`1.#ctor(GeoAPI.Geometries.IPolygon{`0})">
            <summary>
            Create a new intersects computer for a rectangle.
            </summary>
            <param name="rectangle">A rectangular geometry.</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.ShortCircuitedGeometryVisitor`1">
            <summary>
            A visitor to Geometry elements which can
            be short-circuited by a given condition.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.PolygonBuilder`1">
            <summary>
            Forms <see cref="T:GeoAPI.Geometries.IPolygon`1"/>s out of a graph of 
            <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/>s.
            The edges to use are marked as being in the result Area.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder`1.Add(NetTopologySuite.GeometriesGraph.PlanarGraph{`0})">
            <summary>
            Add a complete graph.
            The graph is assumed to contain one or more polygons,
            possibly with holes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder`1.Add(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeEnd{`0}},System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Node{`0}})">
            <summary> 
            Add a set of edges and nodes, which form a graph.
            The graph is assumed to contain one or more polygons,
            possibly with holes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder`1.ContainsPoint(`0)">
            <summary> 
            Checks the current set of shells (with their associated holes) to
            see if any of them contain the point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder`1.buildMaximalEdgeRings(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeEnd{`0}})">
            <summary> 
            For all <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/>s in result, 
            form them into MaximalEdgeRings.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder`1.findShell(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Overlay.MinimalEdgeRing{`0}})">
            <summary>
            This method takes a list of MinimalEdgeRings derived from a MaximalEdgeRing,
            and tests whether they form a Polygon.  This is the case if there is a single shell
            in the list.  In this case the shell is returned.
            The other possibility is that they are a series of connected holes, in which case
            no shell is returned.
            </summary>
            <returns>The shell EdgeRing, if there is one.</returns>
            <returns><see langword="null" />, if all the rings are holes.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder`1.placePolygonHoles(NetTopologySuite.GeometriesGraph.EdgeRing{`0},System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Overlay.MinimalEdgeRing{`0}})">
            <summary>
            This method assigns the holes for a Polygon (formed from a list of
            MinimalEdgeRings) to its shell.
            Determining the holes for a MinimalEdgeRing polygon serves two purposes:
            it is faster than using a point-in-polygon check later on.
            it ensures correctness, since if the PIP test was used the point
            chosen might lie on the shell, which might return an incorrect result from the
            PIP test.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder`1.sortShellsAndHoles(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing{`0}},System.Collections.Generic.ICollection{NetTopologySuite.GeometriesGraph.EdgeRing{`0}},System.Collections.Generic.ICollection{NetTopologySuite.GeometriesGraph.EdgeRing{`0}})">
            <summary> 
            For all rings in the input list,
            determine whether the ring is a shell or a hole
            and add it to the appropriate list.
            Due to the way the DirectedEdges were linked,
            a ring is a shell if it is oriented CW, a hole otherwise.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PolygonBuilder`1.placeFreeHoles(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing{`0}},System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing{`0}})">
            <summary>
            This method determines finds a containing shell for all holes
            which have not yet been assigned to a shell.
            These "free" holes should
            all be properly contained in their parent shells, so it is safe to use the
            <c>findEdgeRingContaining</c> method.
            (This is the case because any holes which are NOT
            properly contained (i.e. are connected to their
            parent shell) would have formed part of a MaximalEdgeRing
            and been handled in a previous step).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.SpatialFunctions">
            <summary>
            The spatial functions supported by this class.
            These operations implement various Boolean combinations 
            of the resultants of the overlay.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.OverlayOp`1">
            <summary>
            Computes the overlay of two <see cref="T:GeoAPI.Geometries.IGeometry`1"/>s.  
            The overlay can be used to determine any Boolean combination of the geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.IsResultOfOp(GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,NetTopologySuite.Operation.Overlay.SpatialFunctions)">
            <summary>
            This method will handle arguments of Location.NULL correctly.
            </summary>
            <returns><see langword="true"/> if the locations correspond to the opCode.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.IsCoveredByLineOrArea(`0)">
            <summary>
            This method is used to decide if a point node should be 
            included in the result or not.
            </summary>
            <returns>
            <see langword="true"/> if the coord point is covered by a result 
            Line or Area point.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.IsCoveredByArea(`0)">
            <summary>
            This method is used to decide if an 
            L edge should be included in the result or not.
            </summary>
            <returns>
            <see langword="true"/> if the coord point is covered by a result Area point.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.insertUniqueEdge(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            Insert an edge from one of the noded input graphs.
            Checks edges that are inserted to see if an
            identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.computeLabelsFromDepths">
            <summary>
            Update the labels for edges according to their depths.
            For each edge, the depths are first normalized.
            Then, if the depths for the edge are equal,
            this edge must have collapsed into a line edge.
            If the depths are not equal, update the label
            with the locations corresponding to the depths
            (i.e. a depth of 0 corresponds to a Location of Exterior,
            a depth of 1 corresponds to Interior)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.replaceCollapsedEdges">
            <summary>
            If edges which have undergone dimensional collapse are found,
            replace them with a new edge which is a L edge
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.copyPoints(System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a previously computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.computeLabeling">
            <summary> 
            Compute initial labeling for all DirectedEdges at each node.
            In this step, DirectedEdges will acquire a complete labeling
            (i.e. one with labels for both Geometries)
            only if they
            are incident on a node which has edges for both Geometries
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.mergeSymLabels">
            <summary> 
            For nodes which have edges from only one Geometry incident on them,
            the previous step will have left their dirEdges with no labeling for the other
            Geometry.  However, the sym dirEdge may have a labeling for the other
            Geometry, so merge the two labels.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.labelIncompleteNodes">
            <summary>
            Incomplete nodes are nodes whose labels are incomplete.
            (e.g. the location for one Geometry is null).
            These are either isolated nodes,
            or nodes which have edges from only a single Geometry incident on them.
            Isolated nodes are found because nodes in one graph which don't intersect
            nodes in the other are not completely labeled by the initial process
            of adding nodes to the nodeList.
            To complete the labeling we need to check for nodes that lie in the
            interior of edges, and in the interior of areas.
            When each node labeling is completed, the labeling of the incident
            edges is updated, to complete their labeling as well.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.labelIncompleteNode(NetTopologySuite.GeometriesGraph.Node{`0},System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.findResultAreaEdges(NetTopologySuite.Operation.Overlay.SpatialFunctions)">
            <summary>
            Find all edges whose label indicates that they are in the result area(s),
            according to the operation being performed.  Since we want polygon shells to be
            oriented CW, choose dirEdges with the interior of the result on the RHS.
            Mark them as being in the result.
            Interior Area edges are the result of dimensional collapses.
            They do not form part of the result area boundary.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.cancelDuplicateResultEdges">
            <summary>
            If both a <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/> and its 
            sym are marked as being in the result, cancel them out.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.OverlayOp`1.isCovered(`0,System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <returns>
            <see langword="true"/> if the coord is located in the interior or boundary of
            a point in the list.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentStringUtil`1">
            <summary>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Noding.SegmentStringUtil`1.ExtractSegmentStrings(GeoAPI.Geometries.IGeometry{`0})" -->
        <member name="T:NetTopologySuite.Noding.Octants">
            <summary>
            Octants in the Cartesian plane.
            </summary>
            <remarks>
            Octants are numbered as follows:
             <para>
              \2|1/
             3 \|/ 0
             ---+--
             4 /|\ 7
              /5|6\ 
            </para>
            If line segments lie along a coordinate axis, the octant is the 
            lower of the two possible values.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Noding.Octant">
            <summary>
            Methods for computing and working with <see cref="T:NetTopologySuite.Noding.Octants"/> 
            of the Cartesian plane.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Octant.GetOctant(System.Double,System.Double)">
            <summary>
            Returns the octant of a directed line segment 
            (specified as x and y displacements, which cannot both be 0).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Octant.GetOctant``1(NetTopologySuite.Geometries.LineSegment{``0})">
            <summary>
            Returns the octant of a directed line segment from p0 to p1.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Octant.GetOctant``1(``0,``0)">
            <summary>
            Returns the octant of a directed line segment from p0 to p1.
            </summary>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.ExtractLineByLocation`1">
            <summary>
            Extracts the subline of a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> between
            two <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>s on the line.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.ExtractLineByLocation`1"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation`1.Extract(GeoAPI.Geometries.IGeometry{`0},NetTopologySuite.LinearReferencing.LinearLocation{`0},NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Computes the subline of a <see cref="T:GeoAPI.Geometries.ILineString`1"/> between
            two LineStringLocations on the line.
            If the start location is after the end location,
            the computed geometry is reversed.
            </summary>
            <param name="line">The line to use as the baseline.</param>
            <param name="start">The start location.</param>
            <param name="end">The end location.</param>
            <returns>The extracted subline.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation`1.Extract(NetTopologySuite.LinearReferencing.LinearLocation{`0},NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Extracts a subline of the input.
            If <paramref name="end" /> is minor that <paramref name="start" />,
            the linear geometry computed will be reversed.
            </summary>
            <param name="start">The start location.</param>
            <param name="end">The end location.</param>
            <returns>A linear geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.ExtractLineByLocation`1.computeLinear(NetTopologySuite.LinearReferencing.LinearLocation{`0},NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Assumes input is valid 
            (e.g. <paramref name="start" /> minor or equals to <paramref name="end" />).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.ItemBoundable`2">
            <summary>
            Boundable wrapper for a non-boundable object. Used internally by
            AbstractStrTree.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.PlanarGraph`1">
            <summary> 
            The computation of the <see cref="T:GeoAPI.Geometries.IntersectionMatrix"/> relies on the use of a structure
            called a "topology graph". The topology graph contains nodes and edges
            corresponding to the vertexes and line segments of a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>. 
            Each node and edge in the graph is labeled with its topological location relative to
            the source point.
            </summary>
            <remarks>
            <para>
            Note that there is no requirement that points of self-intersection be a vertex.
            Thus to obtain a correct topology graph, <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> instances 
            must be self-noded before constructing their graphs.
            </para>
            <para>
            Two fundamental operations are supported by topology graphs:
            <list type="bullet">
            <item>
            <description>
            Computing the intersections between all the edges and nodes of a single graph.
            </description>
            </item>
            <item>
            <description>
            Computing the intersections between the edges and nodes of two different graphs.
            </description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.LinkResultDirectedEdges(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Node{`0}})">
            <summary> 
            For nodes in the enumeration, link the <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/>s 
            at the node that are in the result.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.AddEdges(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge{`0}})">
            <summary> 
            Add a set of edges to the graph.  For each edge two DirectedEdges
            will be created.  DirectedEdges are NOT linked by this method.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.AddNode(NetTopologySuite.GeometriesGraph.Node{`0})">
            <summary>
            Adds the given <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/> to the node map.
            </summary>
            <param name="node">The <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/> to add.</param>
            <returns>The added node.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.AddNode(`0)">
            <summary>
            Adds the given <typeparamref name="TCoordinate"/> as a <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/> 
            to the node map.
            </summary>
            <param name="coord">The <typeparamref name="TCoordinate"/> to add.</param>
            <returns>The added node.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.Find(`0)">
            <returns> 
            The node if found; null otherwise
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.FindEdge(`0,`0)">
            <summary>
            Returns the edge whose first two coordinates are p0 and p1.
            </summary>
            <returns> The edge, if found <see langword="null" /> if the edge was not found.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.FindEdgeEnd(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary> 
            Returns the <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/> which has edge e as its base edge.
            </summary>
            <param name="e">
            The <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/> to lookup the <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s
            for.
            </param>
            <returns>
            The <see cref="T:GeoAPI.DataStructures.Pair`1"/> of <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>, 
            if found; <see langword="null"/> if the edge was not found.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.FindEdgeInSameDirection(`0,`0)">
            <summary>
            Returns the edge which starts at <paramref name="p0"/> and whose first segment is
            parallel to <paramref name="p1"/>.
            </summary>
            <param name="p0">The coordinate where the sought edge starts.</param>
            <param name="p1">The direction of the edge to find.</param>
            <returns>The edge, if found; <see langword="null" /> if the edge was not found.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.IsBoundaryNode(System.Int32,`0)">
            <summary>
            Returns true if the node at <paramref name="coord"/> is on the boundary
            of the geometry.
            </summary>
            <param name="geomIndex">The index of the geometry to check.</param>
            <param name="coord">The coordinate of the node.</param>
            <returns><see langword="true"/> if the node at <paramref name="coord"/> is on the boundary,
            <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.LinkAllDirectedEdges">
            <summary> 
            Link the DirectedEdges at the nodes of the graph.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.LinkResultDirectedEdges">
            <summary> 
            Link the DirectedEdges at the nodes of the graph.
            This allows clients to link only a subset of nodes in the graph, for
            efficiency (because they know that only a subset is of interest).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.InsertEdge(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            Adds an <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/> to the graph.
            </summary>
            <param name="e">The <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/> to add.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.PlanarGraph`1.matchInSameDirection(`0,`0,`0,`0)">
            <summary>
            The coordinate pairs match if they define line segments lying in the same direction.
            E.g. the segments are parallel and in the same quadrant
            (as opposed to parallel and opposite!).
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.PlanarGraph`1.NodeMap">
            <summary>
            Gets the internal <see cref="T:NetTopologySuite.GeometriesGraph.NodeMap`1"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.PlanarGraph`1.Edges">
            <summary>
            Gets the set of <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>s in this graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.PlanarGraph`1.EdgeEnds">
            <summary>
            Gets the set of <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s in this graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.PlanarGraph`1.Nodes">
            <summary>
            Gets the set of <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/>s in this graph.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate`1">
            <summary>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate`1.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0})">
            <summary>
             Creates an instance of this operation.
            </summary>
             <param name="prepPoly">the prepared polygon</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate`1.IsAllTestComponentsInTarget(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Tests whether all components of the test Geometry  are contained in the target geometry.
             Handles both linear and point components.
            </summary>
             <param name="testGeom">a geometry to test</param>
             <returns>true if all componenta of the argument are contained in the target geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate`1.IsAllTestComponentsInTargetInterior(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether all components of the test Geometry are contained in the interior of the target geometry.
            Handles both linear and point components.
            </summary>
            <param name="testGeom">a geometry to test</param>
            <returns>true if all componenta of the argument are contained in the target geometry interior</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate`1.IsAnyTestComponentInTarget(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether any component of the test Geometry intersects 
            Handles test geometries with both linear and point components.
            </summary>
            <param name="testGeom">a geometry to test</param>
            <returns>true if any component of the argument intersects the prepared area geometry the area of the target geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate`1.IsAnyTestComponentInTargetInterior(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether any component of the test Geometry intersects the interior of the target geometry.
            Handles test geometries with both linear and point components.
            </summary>
            <param name="testGeom">a geometry to test</param>
            <returns>true if any component of the argument intersects the prepared area geometry interior</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonPredicate`1.IsAnyTargetComponentInAreaTest(GeoAPI.Geometries.IGeometry{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Tests whether any component of the target geometry intersects the test geometry (which must be an areal geometry) 
            </summary>
            <param name="testGeom">the test geometry</param>
            <param name="targetRepPts">the representative points of the target geometry</param>
            <returns>true if any component intersects the areal test geometry</returns>
        </member>
        <member name="F:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains`1.HasNonProperIntersection">
            This flag controls a difference between contains and covers.
            
            For contains the value is true.
            For covers the value is false.
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains`1.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0})">
            <summary>
             Creates an instance of this operation.
            </summary>
            <param name="prepPoly">the PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains`1.Eval(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Evaluate the <see cref="M:GeoAPI.Geometries.ISpatialRelation`1.Contains(GeoAPI.Geometries.IGeometry{`0})"/> or <see cref="M:GeoAPI.Geometries.ISpatialRelation.Covers(GeoAPI.Geometries.IGeometry)"/> relationship for a given geometry
            </summary>
             <param name="geom">the test geometry</param>
             <returns>true if the test geometry is contained/covered</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains`1.IsSingleShell(GeoAPI.Geometries.IGeometry{`0})">
            Tests whether a geometry consists of a single polygon with no holes.
             
            @return true if the geometry is a single polygon with no holes
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.AbstractPreparedPolygonContains`1.FullTopologicalPredicate(GeoAPI.Geometries.IGeometry{`0})">
            Computes the full topological predicate.
            Used when short-circuit tests are not conclusive.
            
            @param geom the test geometry
            @return true if this prepared polygon has the relationship with the test geometry
        </member>
        <member name="T:NetTopologySuite.Algorithm.RobustLineIntersector`1">
            <summary> 
            A robust version of <see cref="T:NetTopologySuite.Algorithm.LineIntersector`1"/>.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.LineIntersector`1">
            <summary> 
            A <see cref="T:NetTopologySuite.Algorithm.LineIntersector`1"/> is an algorithm that can 
            both test whether two line segments intersect and compute the 
            <see cref="T:NetTopologySuite.Algorithm.Intersection`1"/> point if they do.
            </summary>
            <remarks>
            The intersection point may be computed in a precise or non-precise manner.
            Computing it precisely involves rounding it to an integer.  (This assumes
            that the input coordinates have been made precise by scaling them to
            an integer grid.)
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector`1.ComputeEdgeDistance(`0,GeoAPI.DataStructures.Pair{`0})">
            <summary> 
            Computes the "edge distance" of an intersection point p along a segment.
            </summary>
            <remarks>
            The edge distance is a metric of the point along the edge.
            The metric used is a robust and easy to compute metric function.
            It is not equivalent to the usual Euclidean metric.
            It relies on the fact that either the x or the y ordinates of the
            points in the edge are unique, depending on whether the edge is longer in
            the horizontal or vertical direction.
            NOTE: This function may produce incorrect distances
            for inputs where <paramref name="p"/> is not precisely on 
            <paramref name="line"/>.
            (E.g. p = (139, 9) p1 = (139, 10), p2 = (280, 1) produces a distance of 0.0, 
            which is incorrect). My hypothesis is that the function is safe to use for 
            points which are the result of rounding points which lie on the line, but not 
            safe to use for truncated points.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector`1.ComputeEdgeDistance(`0,NetTopologySuite.Geometries.LineSegment{`0})">
            <summary> 
            Computes the "edge distance" of an intersection point p along a segment.
            </summary>
            <seealso cref="M:NetTopologySuite.Algorithm.LineIntersector`1.ComputeEdgeDistance(`0,GeoAPI.DataStructures.Pair{`0})"/>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector`1.NonRobustComputeEdgeDistance(`0,GeoAPI.DataStructures.Pair{`0})">
            <summary>
            This function is non-robust, since it may compute the square of large numbers.
            Currently not sure how to improve this.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector`1.ComputeIntersection(`0,`0,`0)">
            <summary> 
            Compute the intersection of a point p and the line p1-p2.
            This function computes the boolean value of the "has intersection" test.
            The actual value of the intersection (if there is one)
            is equal to the value of <paramref name="p"/>.
            </summary>
            <param name="p">
            The coordinate to test for intersection with the given <paramref name="line"/>.
            </param>
            <param name="p1">First point of the line </param>
            <param name="p2">Second point of the line </param>
            <returns>
            An <see cref="T:NetTopologySuite.Algorithm.Intersection`1"/> instance
            describing the relationship of <paramref name="p"/> with a line
            from <paramref name="p1"/>.to <paramref name="p2"/>
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector`1.ComputeIntersection(`0,GeoAPI.DataStructures.Pair{`0})">
            <summary> 
            Compute the intersection of a point p and the line p1-p2.
            This function computes the boolean value of the "has intersection" test.
            The actual value of the intersection (if there is one)
            is equal to the value of <paramref name="p"/>.
            </summary>
            <param name="p">
            The coordinate to test for intersection with the given <paramref name="line"/>.
            </param>
            <param name="line">
            The line to test for intersection with.
            </param>
            <returns>
            An <see cref="T:NetTopologySuite.Algorithm.Intersection`1"/> instance
            describing the relationship of <paramref name="p"/> with 
            <paramref name="line"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector`1.ComputeIntersection(`0,`0,`0,`0)">
            <summary>
            Computes the intersection of the lines <c>p1-p2</c> and <c>p3-p4</c>.
            This function computes both the boolean value of the "has intersection" test
            and the (approximate) value of the intersection point itself (if there is one).
            </summary>
            <param name="p1">The first point of the line segment <c>p1-p2</c>.</param>
            <param name="p2">The second point of the line segment <c>p1-p2</c>.</param>
            <param name="p3">The first point of the line segment <c>p3-p4</c>.</param>
            <param name="p4">The second point of the line segment <c>p3-p4</c>.</param>
            <returns>
            An <see cref="T:NetTopologySuite.Algorithm.Intersection`1"/> instance
            describing the relationship of the two lines.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector`1.ComputeIntersection(GeoAPI.DataStructures.Pair{`0},GeoAPI.DataStructures.Pair{`0})">
            <summary>
            Computes the intersection of the line segments with endpoint pairs
            <paramref name="line0"/> and <paramref name="line1"/>.
            This function computes both the boolean value of the "has intersection" test
            and the (approximate) value of the intersection point itself (if there is one).
            </summary>
            <param name="line0">
            The endpoints of the first line segment to test for intersection.
            </param>
            <param name="line1">
            The endpoints of the second line segment to test for intersection.
            </param>
            <returns>
            An <see cref="T:NetTopologySuite.Algorithm.Intersection`1"/> instance
            describing the relationship of the two line segments.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.LineIntersector`1.ComputeIntersection(NetTopologySuite.Geometries.LineSegment{`0},NetTopologySuite.Geometries.LineSegment{`0})">
            <summary>
            Computes the intersection of the line segments 
            <paramref name="line0"/> and <paramref name="line1"/>.
            This function computes both the boolean value of the "has intersection" test
            and the (approximate) value of the intersection point itself (if there is one).
            </summary>
            <param name="line0">
            The first line segment to test for intersection.
            </param>
            <param name="line1">
            The second line segment to test for intersection.
            </param>
            <returns>
            An <see cref="T:NetTopologySuite.Algorithm.Intersection`1"/> instance
            describing the relationship of the two line segments.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector`1.PrecisionModel">
            <summary> 
            Force computed intersection to be rounded to a given precision model.
            </summary>
            <remarks>
            <para>
            If the precision model is set, computed intersection coordinates will be made 
            precise using <see cref="M:GeoAPI.Coordinates.IPrecisionModel`1.MakePrecise(`0)"/>.
            </para>
            <para>
            No getter is provided, because the precision model is not required to be 
            specified.
            </para>
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Algorithm.LineIntersector`1.GeometryFactory">
            <summary>
            Gets the <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> instance.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.RobustLineIntersector`1.FloatingPrecisionCoordinateFactory">
            <summary>
             Floating Precision Coordinate Factory is used for internal computation in
             the RobustLineIntersector Class to avoid problems with FixedPrecision
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector`1.computeIntersectionWithNormalization(GeoAPI.DataStructures.Pair{`0},GeoAPI.DataStructures.Pair{`0})">
            <summary> 
            This method computes the actual value of the intersection point.
            To obtain the maximum precision from the intersection calculation,
            the coordinates are normalized by subtracting the minimum
            ordinate values (in absolute value).  This has the effect of
            removing common significant digits from the calculation to
            maintain more bits of precision.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector`1.normalizeToExtentCenter(GeoAPI.Coordinates.ICoordinateFactory{`0},`0@,`0@,`0@,`0@,`0@)">
            <summary>
            Normalize the supplied coordinates to
            so that the midpoint of their intersection envelope
            lies at the origin.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustLineIntersector`1.isInSegmentExtents(GeoAPI.Geometries.IGeometryFactory{`0},`0,GeoAPI.DataStructures.Pair{`0},GeoAPI.DataStructures.Pair{`0})">
            <summary> 
            Test whether a point lies in the envelopes of both input segments.
            </summary>
            <returns>
            <see langword="true"/> if the input point lies within both input segment envelopes.
            </returns>
            <remarks>
            A correctly computed intersection point should return <see langword="true"/>
            for this test.
            Since this test is for debugging purposes only, no attempt is
            made to optimize the envelope test.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Algorithm.PointLocator`1">
            <summary> 
            Computes the topological relationship (Location) of a single point to a Geometry.
            The algorithm obeys the SFS boundaryDetermination rule to correctly determine
            whether the point lies on the boundary or not.
            Note that instances of this class are not reentrant.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocator`1.Intersects(`0,GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Convenience method to test a point for intersection with a Geometry
            </summary>
            <param name="p">The coordinate to test.</param>
            <param name="geom">The Geometry to test.</param>
            <returns><see langword="true"/> if the point is in the interior or boundary of the Geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.PointLocator`1.Locate(`0,GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Computes the topological relationship (<see cref="T:GeoAPI.Geometries.Locations"/>) of a single point to a Geometry.
            It handles both single-element and multi-element Geometries.
            The algorithm for multi-part Geometries takes into account the boundaryDetermination rule.
            </summary>
            <returns>The Location of the point relative to the input Geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Intersection`1.GetIntersectionPoint(System.Int32)">
            <summary> 
            Returns the intersection point at index <paramref name="intersectionIndex"/>.
            </summary>
            <param name="intersectionIndex">Index of the intersection: 0 or 1.</param>
            <returns>
            The intersection point at intersection <paramref name="intersectionIndex"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Intersection`1.IsIntersection(`0)">
            <summary> 
            Test whether a point is a intersection point of two line segments.
            Note that if the intersection is a line segment, this method only tests for
            equality with the endpoints of the intersection segment.
            It does not return true if the input point is internal to the 
            intersection segment.
            </summary>
            <returns>
            <see langword="true"/> if the input point is one of the intersection points.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Intersection`1.IsInteriorIntersection">
            <summary> 
            Tests whether either intersection point is an interior point of 
            one of the input segments.
            </summary>
            <returns>
            <see langword="true"/> if either intersection point is in the 
            interior of one of the input segment.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Intersection`1.IsInteriorIntersection(System.Int32)">
            <summary>
            Tests whether either intersection point is an interior point 
            of the specified input segment.
            </summary>
            <returns> 
            <see langword="true"/> if either intersection point is in the 
            interior of the input segment.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Intersection`1.GetIntersectionAlongSegment(System.Int32,System.Int32)">
            <summary> 
            Computes the intersection point number <paramref name="intersectionIndex"/> 
            in the direction of a specified input line segment.
            </summary>
            <param name="segmentIndex">Index of the line segment: 0 or 1.</param>
            <param name="intersectionIndex">Index of the intersection: 0 or 1.</param>
            <returns>
            The intersection point at index <paramref name="intersectionIndex"/> 
            in the direction of the specified input line segment.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Intersection`1.GetIndexAlongSegment(System.Int32,System.Int32)">
            <summary>
            Computes the index of the intersection point at index 
            <paramref name="intersectionIndex"/> in the direction of
            a specified input line segment.
            </summary>
            <param name="segmentIndex">Index of the line segment: 0 or 1.</param>
            <param name="intersectionIndex">Index of the intersection: 0 or 1.</param>
            <returns>
            The index of the intersection point along the segment (0 or 1).
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Intersection`1.GetEdgeDistance(System.Int32,System.Int32)">
            <summary> 
            Computes the "edge distance" of an intersection point along the specified input line segment.
            </summary>
            <param name="segmentIndex">Index of the line segment: 0 or 1.</param>
            <param name="intersectionIndex">Index of the intersection: 0 or 1.</param>
            <returns>The edge distance of the intersection point.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Intersection`1.IsCollinear">
            <summary>
            Gets a value indicating whether the input geometries are collinear.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Intersection`1.HasIntersection">
            <summary> 
            Gets a value indicating whether the input geometries intersect.
            </summary>
            <returns><see langword="true"/> if the input geometries intersect.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Intersection`1.IntersectionDegree">
            <summary>
            Returns the number of intersection points found. 
            </summary>
            <remarks>
            This will be either 0, 1 or 2.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Intersection`1.IsProper">
            <summary>
            Gets a value indicating whether an intersection is proper.
            </summary>
            <remarks>
            The intersection between two line segments is considered proper if
            they intersect in a single point in the interior of both segments
            (e.g. the intersection is a single point and is not equal to any 
            of the endpoints). 
            The intersection between a point and a line segment is considered proper
            if the point lies in the interior of the segment 
            (e.g. is not equal to either of the endpoints).
            </remarks>
            <returns><see langword="true"/> if the intersection is proper.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPointLine`1">
            <summary>
            Computes a point in the interior of an linear point.
            </summary>
            <remarks>
            Algorithm:
            Find an interior vertex which is closest to
            the centroid of the linestring.
            If there is no interior vertex, find the endpoint which is
            closest to the centroid.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine`1.AddInterior(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests the interior vertices (if any)
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointLine`1.AddEndpoints(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Tests the endpoint vertices
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.IBoundaryNodeRule">
            <summary>
            An interface for rules which determine whether node points
            which are in boundaries of linear geometry components
            are in the boundary of the parent geometry collection.
            </summary>
            <remarks>
            The SFS specifies a single kind of boundary node rule,
            the <see cref="T:NetTopologySuite.Algorithm.Mod2BoundaryNodeRule"/> rule.
            However, other kinds of Boundary Node Rules are appropriate
            in specific situations (for instance, linear network topology
            usually follows the <see cref="T:NetTopologySuite.Algorithm.EndPointBoundaryNodeRule"/>.)
            Some NTS operations allow the BoundaryNodeRule to be specified,
            and respect this rule when computing the results of the operation.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.IBoundaryNodeRule.IsInBoundary(System.Int32)">
            <summary>
            Tests whether a point that lies in <paramref name="boundaryCount"/>
            geometry component boundaries is considered to form part of the boundary
            of the parent geometry.
            </summary>
            <param name="boundaryCount">
            The number of component boundaries that this point occurs in.
            </param>
            <returns>
            <see langword="true"/> if points in this number of boundaries lie 
            in the parent boundary.
            </returns>
        </member>
        <member name="T:GeoAPI.IO.WellKnownText.WktTokenizer">
            <summary>
            Reads a stream of Well Known Text (WKT) and returns a 
            stream of tokens.
            </summary>
        </member>
        <member name="T:GeoAPI.IO.WellKnownText.TextTokenizer">
            <summary>
            Parses input character data into tokens.
            </summary>
            <remarks>
            <para>
            The TextTokenizer class takes an input character stream and parses 
            it into "tokens", allowing the tokens to be read one at a time. 
            The parsing process is controlled by a table and a number of flags 
            that can be set to various states. The stream tokenizer can recognize 
            identifiers, numbers, quoted strings, and various comment styles.
            </para>
            </remarks>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.TextTokenizer.#ctor(System.IO.TextReader,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GeoAPI.IO.WellKnownText.TextTokenizer"/> class.
            </summary>
            <param name="reader">A <see cref="T:System.IO.TextReader"/> with text data to tokenize.</param>
            <param name="ignoreWhitespace">Flag indicating whether whitespace should be ignored.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.TextTokenizer.Read(System.Boolean)">
            <summary>
            Returns the <see cref="T:GeoAPI.IO.WellKnownText.TokenType"/> of the next token.
            </summary>
            <param name="ignoreWhitespace">
            Determines is whitespace is ignored. True if whitespace is to be ignored.
            </param>
            <returns>The TokenType of the next token.</returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.TextTokenizer.Read">
            <summary>
            Returns the next token type.
            </summary>
            <returns>The TokenType of the next token.</returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.TextTokenizer.advanceToken">
            <summary>
            Returns next token that is not whitespace.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.TextTokenizer.getType(System.Nullable{System.Char})">
            <summary>
            Determines a characters type (e.g. number, symbols, character).
            </summary>
            <param name="character">The character to determine.</param>
            <returns>The TokenType the character is.</returns>
        </member>
        <member name="P:GeoAPI.IO.WellKnownText.TextTokenizer.LineNumber">
            <summary>
            Gets the current line number of the stream being read.
            </summary>
        </member>
        <member name="P:GeoAPI.IO.WellKnownText.TextTokenizer.Column">
            <summary>
            Gets the current column number of the stream being read.
            </summary>
        </member>
        <member name="P:GeoAPI.IO.WellKnownText.TextTokenizer.CurrentTokenAsNumber">
            <summary>
            If the current token is a number, this field contains the value 
            of that number. 
            </summary>
            <remarks>
            If the current token is a number, this field contains the value 
            of that number. The current token is a number when the value of 
            <see cref="P:GeoAPI.IO.WellKnownText.TextTokenizer.CurrentTokenType"/> is <see cref="F:GeoAPI.IO.WellKnownText.TokenType.Number"/>.
            </remarks>
            <exception cref="T:System.FormatException">
            Current token is not a number in a valid format.
            </exception>
        </member>
        <member name="P:GeoAPI.IO.WellKnownText.TextTokenizer.CurrentToken">
            <summary>
            If the current token is a word token, this field contains a 
            String giving the characters of the word token. 
            </summary>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.WktTokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Initializes a new instance of the WktStreamTokenizer class.
            </summary>
            <remarks>The WktStreamTokenizer class ais in reading WKT streams.</remarks>
            <param name="reader">A TextReader that contains </param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.WktTokenizer.ReadToken(System.String)">
            <summary>
            Reads a token and checks it is what is expected.
            </summary>
            <param name="expectedToken">The expected token.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.WktTokenizer.ReadDoubleQuotedWord">
            <summary>
            Reads a string inside double quotes.
            </summary>
            <remarks>
            White space inside quotes is preserved.
            </remarks>
            <returns>The string inside the double quotes.</returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.WktTokenizer.ReadAuthority(System.String@,System.String@)">
            <summary>
            Reads the authority and authority code.
            </summary>
            <param name="authority">String to place the authority in.</param>
            <param name="authorityCode">Int64 to place the authority code in.</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.SplitSegment`1">
            <summary>
             Models a constraint segment which can be split in two in various ways, according to certain geometric constraints.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.SplitSegment`1.PointAlongReverse(GeoAPI.Coordinates.ICoordinateFactory{`0},NetTopologySuite.Geometries.LineSegment{`0},System.Double)">
            Computes the {@link Coordinate} that lies a given fraction along the line defined by the
            reverse of the given segment. A fraction of <code>0.0</code> returns the end point of the
            segment; a fraction of <code>1.0</code> returns the start point of the segment.
            
            @param seg the LineSegment
            @param segmentLengthFraction the fraction of the segment length along the line
            @return the point at that distance
        </member>
        <member name="M:NetTopologySuite.Triangulate.SplitSegment`1.#ctor(NetTopologySuite.Geometries.LineSegment{`0})">
            <summary>
             Creates an instance of this class
            </summary>
            <param name="seg">a line segment</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.ITriangleVisitor`1">
            <summary>
             An interface for algorithms which process the triangles in a <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
            <typeparam name="TData"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.ITriangleVisitor`1.Visit(GeoAPI.Coordinates.ICoordinateFactory{`0},NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0}[])">
            <summary>
             Visits the <see cref="!:QuadEdge&lt;TCoordinate, TData&gt;"/>s of a triangle.
            </summary>
            <param name="coordFactory">the factory to create coordinates</param>
            <param name="triEdges">an array of the 3 quad edges in a triangle (in CCW order)</param>
        </member>
        <member name="T:NetTopologySuite.Simplify.DouglasPeuckerLineSimplifier`1">
            <summary>
            Simplifies a line (sequence of points) using
            the standard Douglas-Peucker algorithm.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.PointBuilder`1">
            <summary>
            Constructs <see cref="T:GeoAPI.Geometries.IPoint`1"/>s from the 
            nodes of an overlay graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PointBuilder`1.Build(NetTopologySuite.Operation.Overlay.SpatialFunctions)">
            <returns>
            A list of the <see cref="T:GeoAPI.Geometries.IPoint`1"/>s in the result 
            of the specified overlay operation.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.PointBuilder`1.FilterCoveredNodeToPoint(NetTopologySuite.GeometriesGraph.Node{`0},System.Collections.Generic.ICollection{GeoAPI.Geometries.IPoint{`0}})">
            <summary>
             Converts non-covered nodes to Point objects and adds them to the result.
             A node is covered if it is contained in another element Geometry
             with higher dimension (e.g. a node point might be contained in a polygon,
             in which case the point can be eliminated from the result).
            </summary>
             <param name="n">the node to test</param>
             <param name="lst">collection of uncovered points</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMergeGraph`1">
            <summary>
            A planar graph of edges that is analyzed to sew the edges together. The 
            <c>marked</c> flag on <c>com.vividsolutions.planargraph.Edge</c>s 
            and <c>com.vividsolutions.planargraph.Node</c>s indicates whether they have been
            logically deleted from the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMergeGraph`1.AddEdge(GeoAPI.Geometries.ILineString{`0})">
            <summary>
            Adds an Edge, DirectedEdges, and Nodes for the given LineString representation
            of an edge. 
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge`1">
            <summary>
            A <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/> of a <see cref="T:NetTopologySuite.Operation.Linemerge.LineMergeGraph`1"/>. 
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.DirectedEdge`1">
            <summary>
            Represents a directed edge in a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/>. 
            </summary>
            <remarks>
            A <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/> may or
            may not have a reference to a parent <see cref="!:Edge&lt;TCoordinate&gt;"/> (some applications of
            planar graphs may not require explicit Edge objects to be created). Usually
            a client using a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/> will subclass 
            <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/> to add its own application-specific 
            data and methods.    
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NetTopologySuite.Planargraph.GraphComponent`1" -->
        <member name="M:NetTopologySuite.Planargraph.GraphComponent`1.SetVisited(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.GraphComponent{`0}},System.Boolean)">
            <summary>
            Sets the <see cref="P:NetTopologySuite.Planargraph.GraphComponent`1.Visited"/> state 
            for all <see cref="T:NetTopologySuite.Planargraph.GraphComponent`1"/>s in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="components">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to scan.</param>
            <param name="visited">
            The state to set the <see cref="P:NetTopologySuite.Planargraph.GraphComponent`1.Visited"/> flag to.
            </param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.GraphComponent`1.SetMarked(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.GraphComponent{`0}},System.Boolean)">
            <summary>
            Sets the <see cref="P:NetTopologySuite.Planargraph.GraphComponent`1.Marked"/> state 
            for all <see cref="T:NetTopologySuite.Planargraph.GraphComponent`1"/>s in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="components">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to scan.</param>
            <param name="marked">The state to set the <see cref="P:NetTopologySuite.Planargraph.GraphComponent`1.Marked"/> flag to.</param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.GraphComponent`1.GetComponentWithVisitedState(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.GraphComponent{`0}},System.Boolean)">
            <summary>
            Finds the first <see cref="T:NetTopologySuite.Planargraph.GraphComponent`1"/> 
            in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            which has the specified <see cref="P:NetTopologySuite.Planargraph.GraphComponent`1.Visited"/> state.
            </summary>
            <param name="components">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to scan.</param>
            <param name="visitedState">The <see cref="P:NetTopologySuite.Planargraph.GraphComponent`1.Visited"/> state to test.</param>
            <returns>
            The first <see cref="T:NetTopologySuite.Planargraph.GraphComponent`1"/> found, or <see langword="null"/> if none found.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent`1.IsVisited">
            <summary>
            Gets a value indicating if a component has been 
            visited during the course of a graph algorithm.
            </summary>              
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent`1.Visited">
            <summary> 
            Gets or sets the visited flag for this component.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent`1.IsMarked">
            <summary>
            Gets a value indicating if a component has been marked 
            at some point during the processing involving this graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent`1.Marked">
            <summary>
            Gets or sets the marked flag for this component.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.GraphComponent`1.IsRemoved">
            <summary>
            Gets a value indicating whether this component 
            has been removed from its containing graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge`1.#ctor(NetTopologySuite.Planargraph.Node{`0},NetTopologySuite.Planargraph.Node{`0},`0,System.Boolean)">
            <summary>
            Constructs a DirectedEdge connecting the <c>from</c> node to the
            <c>to</c> node.
            </summary>
            <param name="directionPt">
            Specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            Whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge`1.CompareTo(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Returns 1 if this DirectedEdge has a greater angle with the
            positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is susceptible to roundoff. A robust algorithm
            is:
            first compare the quadrants. If the quadrants are different, it it
            trivial to determine which vector is "greater".
            if the vectors lie in the same quadrant, the robust
            <c>RobustCGAlgorithms.ComputeOrientation(Coordinate, Coordinate, Coordinate)</c>
            function can be used to decide the relative orientation of the vectors.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge`1.ToEdges(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.DirectedEdge{`0}})">
            <summary>
            Returns a set containing the parent <see cref="P:NetTopologySuite.Planargraph.DirectedEdge`1.Edge"/> 
            (possibly <see langword="null"/>) for each of the given 
            <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge`1.CompareDirection(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Returns 1 if this DirectedEdge has a greater angle with the
            positive x-axis than b", 0 if the DirectedEdges are collinear, and -1 otherwise.
            </summary>
            <remarks>
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is susceptible to roundoff. A robust algorithm
            is to first compare the quadrants. If the quadrants are different, it it
            trivial to determine which vector is "greater". 
            If the vectors lie in the same quadrant, the robust
            <see cref="M:NetTopologySuite.Algorithm.CGAlgorithms`1.ComputeOrientation(`0,`0,`0)"/>
            function can be used to decide the relative orientation of the vectors.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge`1.Write(System.IO.StreamWriter)">
            <summary>
            Writes a detailed String representation of this DirectedEdge to the given PrintStream.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdge`1.Remove">
            <summary>
            Removes this directed edge from its containing graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.Edge">
            <summary>
            Returns this DirectedEdge's parent Edge, or null if it has none.
            Associates this DirectedEdge with an Edge (possibly null, indicating no associated
            Edge).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.Quadrant">
            <summary>
            Returns 0, 1, 2, or 3, indicating the quadrant in which this DirectedEdge's
            orientation lies.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.DirectionVector">
            <summary>
            Returns a point to which an imaginary line is drawn from the from-node to
            specify this DirectedEdge's orientation.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.EdgeDirection">
            <summary>
            Returns whether the direction of the parent Edge (if any) is the same as that
            of this Directed Edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.FromNode">
            <summary>
            Returns the node from which this DirectedEdge leaves.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.ToNode">
            <summary>
            Returns the node to which this DirectedEdge goes.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.Coordinate">
            <summary>
            Returns the coordinate of the from-node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.Angle">
            <summary>
            Returns the angle that the start of this DirectedEdge makes with the
            positive x-axis, in radians.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.Sym">
            <summary>
            Returns the symmetric DirectedEdge -- the other DirectedEdge associated with
            this DirectedEdge's parent Edge.
            Sets this DirectedEdge's symmetric DirectedEdge, which runs in the opposite
            direction.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdge`1.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge`1.#ctor(NetTopologySuite.Planargraph.Node{`0},NetTopologySuite.Planargraph.Node{`0},`0,System.Boolean)">
            <summary>
            Constructs a LineMergeDirectedEdge connecting the <c>from</c> node to the <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge`1.Next">
            <summary>
            Returns the directed edge that starts at this directed edge's end point, or null
            if there are zero or multiple directed edges starting there.  
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferOp`1">
            <summary>
            Computes the buffer of a geometry, for both positive and negative 
            buffer distances.  
            </summary>
            <remarks>  
            <para>
            In GIS, the positive (or negative) buffer of a point is defined as
            the Minkowski sum (or difference) of the point
            with a circle with radius equal to the absolute value of the buffer distance.
            </para>
            <para>
            In the CAD/CAM world buffers are known as offset curves.
            In morphological analysis the 
            operation of postive and negative buffering 
            is referred to as <i>erosion</i> and <i>dilation</i>
            </para>
            <para>
            The buffer operation always returns a polygonal result.
            The negative or zero-distance buffer of lines and points is always an empty <see cref="T:GeoAPI.Geometries.IPolygon`1"/>.
            </para>
            <para>
            Since true buffer curves may contain circular arcs,
            computed buffer polygons can only be approximations to the true point.
            The user can control the accuracy of the curve approximation by specifying
            the number of linear segments with which to approximate a curve.
            </para>
            <para>
            The end cap endCapStyle of a linear buffer may be specified. The
            following end cap styles are supported:
            <list type="table">
            <item>
            <term><see cref="F:GeoAPI.Operations.Buffer.BufferStyle.Round"/></term>
            <description>the usual round end caps</description>
            </item>
            <item>
            <term><see cref="F:GeoAPI.Operations.Buffer.BufferStyle.Butt"/></term>
            <description>
            end caps are truncated flat at the line ends
            </description>
            </item>
            <item>
            <term><see cref="F:GeoAPI.Operations.Buffer.BufferStyle.Square"/></term>
            <description>
            end caps are squared off at the buffer distance beyond the line ends
            </description>
            </item>
            </list>
            </para>
            <para>
            The computation uses an algorithm involving iterated noding 
            and precision reduction to provide a high degree of robustness.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Initializes a buffer computation for the given point.
            </summary>
            <param name="g">The point to buffer.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp`1.PrecisionScaleFactor(GeoAPI.Geometries.IGeometry{`0},System.Double,System.Int32)">
            <summary>
            Compute a reasonable scale factor to limit the precision of
            a given combination of geometry and buffer distance.
            The scale factor is based on a heuristic.
            </summary>
            <param name="g">
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> being buffered.
            </param>
            <param name="distance">The buffer distance.</param>
            <param name="maxPrecisionDigits">
            The max # of digits that should be allowed by
            the precision determined by the computed scale factor.
            </param>
            <returns>
            A scale factor that allows a reasonable amount of precision 
            for the buffer computation.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double)">
            <summary>
            Computes the buffer of a geometry for a given buffer distance.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <returns> The buffer of the input point.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double,GeoAPI.Operations.Buffer.BufferStyle)">
            <summary>
            Computes the buffer of a point for a given buffer distance,
            using the given Cap Style for borders of the point.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>        
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns> The buffer of the input point.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double,System.Int32)">
            <summary>
            Computes the buffer for a point for a given buffer distance
            and accuracy of approximation.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <param name="quadrantSegments">The number of segments used to approximate a quarter circle.</param>
            <returns>The buffer of the input point.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double,System.Int32,GeoAPI.Operations.Buffer.BufferStyle)">
            <summary>
            Computes the buffer for a point for a given buffer distance
            and accuracy of approximation.
            </summary>
            <param name="g">The point to buffer.</param>
            <param name="distance">The buffer distance.</param>
            <param name="quadrantSegments">The number of segments used to approximate a quarter circle.</param>
            <param name="endCapStyle">Cap Style to use for compute buffer.</param>
            <returns>The buffer of the input point.</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferOp`1.EndCapStyle">
            <summary> 
            Gets or sets the end cap <see cref="T:GeoAPI.Operations.Buffer.BufferStyle"/> of the 
            generated buffer geometry.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.MonotoneChainIndexPointSnapper`1">
            <summary>
            "Snaps" all <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s in 
            a <see cref="T:GeoAPI.Indexing.ISpatialIndex`2"/> containing
            <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain`1"/>s to a given
            <see cref="T:NetTopologySuite.Noding.Snapround.HotPixel`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MonotoneChainIndexPointSnapper`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},System.Collections.Generic.IEnumerable{NetTopologySuite.Index.Chain.MonotoneChain{`0}},GeoAPI.Indexing.ISpatialIndex{GeoAPI.Geometries.IExtents{`0},NetTopologySuite.Index.Chain.MonotoneChain{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.Snapround.MonotoneChainIndexPointSnapper`1"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MonotoneChainIndexPointSnapper`1.Snap(NetTopologySuite.Noding.Snapround.HotPixel{`0},NetTopologySuite.Noding.ISegmentString{`0},System.Int32)">
            <summary>
            Snaps (nodes) all interacting segments to this hot pixel.
            The hot pixel may represent a vertex of an edge,
            in which case this routine uses the optimization
            of not noding the vertex itself.
            </summary>
            <param name="hotPixel">The hot pixel to snap to.</param>
            <param name="parentEdge">The edge containing the vertex, if applicable, or <see langword="null" />.</param>
            <param name="vertexIndex"></param>
            <returns><see langword="true"/> if a node was added for this pixel.</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentSetMutualIntersector`1">
            <summary>
            An intersector for the red-blue intersection problem.
            In this class of line arrangement problem,
            two disjoint sets of linestrings are provided.
            It is assumed that within
            each set, no two linestrings intersect except possibly at their endpoints.
            Implementations can take advantage of this fact to optimize processing.
            
            @author Martin Davis
            @version 1.10
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Noding.SegmentSetMutualIntersector`1.SetSegmentIntersector(NetTopologySuite.Noding.ISegmentIntersector{`0})" -->
        <member name="M:NetTopologySuite.Noding.SegmentSetMutualIntersector`1.SetBaseSegments(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
             <summary>
             </summary>
            <param name="segStrings">a collection of <see cref="T:NetTopologySuite.Noding.ISegmentString`1"/>s to node</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Noding.SegmentSetMutualIntersector`1.Process(System.Collections.Generic.List{NetTopologySuite.Noding.ISegmentString{`0}})" -->
        <member name="T:NetTopologySuite.Noding.ISegmentIntersector`1">
            <summary>
            Computes the intersections between two line segments in <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s
            and adds them to each string.
            The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> is passed to a <see cref="T:NetTopologySuite.Noding.INoder`1"/>.
            The <see cref="M:NetTopologySuite.Noding.NodedSegmentString`1.AddIntersections(NetTopologySuite.Algorithm.Intersection{`0},System.Int32,System.Int32)"/>  method is called whenever the <see cref="T:NetTopologySuite.Noding.INoder`1"/>
            detects that two <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/> s might intersect.
            This class is an example of the Strategy pattern.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.ISegmentIntersector`1.ProcessIntersections(NetTopologySuite.Noding.ISegmentString{`0},System.Int32,NetTopologySuite.Noding.ISegmentString{`0},System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> interface to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s being intersected.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.ISegmentIntersector`1.IsDone">
             <summary>
            Reports whether the client of this class
            needs to continue testing all intersections in an arrangement.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.NodingValidator`1">
            <summary>
            Validates that a collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s is correctly noded.
            Throws an appropriate exception if an noding error is found.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.NodingValidator`1"/> 
            class.
            </summary>
            <param name="segStrings">The seg strings.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator`1.CheckCollapses">
            <summary>
            Checks if a segment string contains a segment pattern a-b-a (which implies a self-intersection).
            </summary>   
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator`1.CheckInteriorIntersections">
            <summary>
            Checks all pairs of segments for intersections at an interior point of a segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator`1.HasInteriorIntersection(NetTopologySuite.Algorithm.Intersection{`0},`0,`0)">
            <returns><see langword="true"/> if there is an intersection point which is not an endpoint of the segment p0-p1.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodingValidator`1.CheckEndPtVertexIntersections">
            <summary>
            Checks for intersections between an endpoint of a segment string
            and an interior vertex of another segment string
            </summary>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LocationIndexedLine`1">
            <summary>
            Supports linear referencing along a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            using <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>s as the index.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Constructs an object which allows linear referencing along
            a given linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.ExtractPoint(NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Computes the <typeparamref name="TCoordinate"/> for the point on the line at the given index.
            If the <paramref name="index" /> is out of range,
            the first or last point on the line will be returned.
            </summary>
            <param name="index">The index of the desired point.</param>
            <returns>The <typeparamref name="TCoordinate"/> at the given index.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.ExtractPoint(NetTopologySuite.LinearReferencing.LinearLocation{`0},System.Double)">
             Computes the {@link Coordinate} for the point
             on the line at the given index, offset by the given distance.
             If the index is out of range the first or last point on the
             line will be returned.
             The computed point is offset to the left of the line if the offset distance is
             positive, to the right if negative.
             
             The Z-ordinate of the computed point will be interpolated from
             the Z-ordinates of the line segment containing it, if they exist.
            
             @param index the index of the desired point
             @param offsetDistance the distance the point is offset from the segment
                (positive is to the left, negative is to the right)
             @return the Coordinate at the given index
            <summary>
            </summary>
            <param name="index"></param>
            <param name="offsetDistance"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.ExtractLine(NetTopologySuite.LinearReferencing.LinearLocation{`0},NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Computes the <see cref="T:GeoAPI.Geometries.ILineString`1"/> for the interval
            on the line between the given indices.
            </summary>
            <param name="startIndex">The index of the start of the interval.</param>
            <param name="endIndex">The index of the end of the interval.</param>
            <returns>The linear interval between the indices.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.IndexOf(`0)">
            <summary>
            Computes the index for a given point on the line.
            The supplied point does not necessarily have to lie precisely
            on the line, but if it is far from the line the accuracy and
            performance of this function is not guaranteed.
            Use <see cref="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.Project(`0)"/> to compute a guaranteed result for points
            which may be far from the line.
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The index of the point.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.IndicesOf(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Computes the indices for a subline of the line.
            (The subline must conform to the line; that is,
            all vertices in the subline (except possibly the first and last)
            must be vertices of the line and occcur in the same order).
            </summary>
            <param name="subLine">A subLine of the line.</param>
            <returns>A pair of indices for the start and end of the subline.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.Project(`0)">
            <summary>
            Computes the index for the closest point on the line to the given point.
            If more than one point has the closest distance the first one along the line is returned.
            (The point does not necessarily have to lie precisely on the line.)
            </summary>
            <param name="pt">A point on the line.</param>
            <returns>The index of the point.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.IsValidIndex(NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Tests whether an index is in the valid index range for the line.
            </summary>
            <param name="index">The index to test.</param>
            <returns><see langword="true"/> if the index is in the valid range.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.ClampIndex(NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Computes a valid index for this line by clamping 
            the given index to the valid range of index values.
            </summary>
            <param name="index">The index value to clamp to a valid value.</param>
            <returns>A valid index value.</returns>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.StartIndex">
            <summary>
            Returns the index of the start of the line.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LocationIndexedLine`1.EndIndex">
            <summary>
            Returns the index of the end of the line.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.StrTree`2">
            <summary>  
            A query-only R-tree created using the Sort-Tile-Recursive (STR) algorithm.
            For two-dimensional spatial data. 
            </summary>
            <remarks>
            The STR packed R-tree is simple to implement and maximizes space
            utilization; that is, as many leaves as possible are filled to capacity.
            Overlap between nodes is far less than in a basic R-tree. However, once the
            tree has been built (explicitly or on the first call to <see cref="M:NetTopologySuite.Index.Strtree.StrTree`2.Query(GeoAPI.Geometries.IExtents{`0})"/>), 
            items may not be added or removed. 
            Described in: P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.AbstractStrTree`2">
            <summary>
            Base class for STR trees and SIR trees. 
            <remarks>
            <para>
            STR-packed R-trees are described in:
            P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            </para>
            <para>
            This implementation is based on boundables rather than just AbstractNodes,
            because the STR algorithm operates on both nodes and
            data, both of which are treated here as boundables.
            </para>
            </remarks>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.#ctor(System.Int32)">
            <summary> 
            Constructs an AbstractStrTree with the specified maximum number of child
            nodes that a node may have.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.Remove(`1)">
            <remarks>
            Also builds the tree, if necessary.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.Query(`0)">
            <remarks>
            Also builds the tree, if necessary.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.Query(`0,System.Predicate{`1})">
            <remarks>
            Also builds the tree, if necessary.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.Build">
            <summary> 
            Creates parent nodes, grandparent nodes, and so forth up to the root
            node, for the data that has been inserted into the tree. Can only be
            called once, and thus should be called only after all of the data has been
            inserted into the tree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.CreateParentBoundables(System.Collections.Generic.IList{GeoAPI.Indexing.IBoundable{`0}},System.Int32)">
            <summary>
            Sorts the childBoundables then divides them into groups of size M, where
            M is the node capacity.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.boundablesAtLevel(System.Int32,GeoAPI.Indexing.ISpatialIndexNode{`0,`1})">
            <param name="level">-1 to get items.</param>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.createHigherLevels(System.Collections.Generic.IList{GeoAPI.Indexing.IBoundable{`0}},System.Int32)">
            <summary>
            Creates the levels higher than the given level.
            </summary>
            <param name="boundablesOfALevel">The level to build on.</param>
            <param name="level">The level of the boundables, or -1 if the boundables are item
            boundables (that is, below level 0).</param>
            <returns>The root, which may be a ParentNode or a LeafNode.</returns>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.AbstractStrTree`2.ItemsTree">
            <summary>
            Gets a tree structure (as a nested list) 
            corresponding to the structure of the items and nodes in this tree.
            The returned Lists contain either Object items, 
            or Lists which correspond to subtrees of the tree
            Subtrees which do not contain any items are not included.
            Builds the tree if necessary.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Strtree.AbstractStrTree`2.NodeCapacity">
            <summary> 
            Returns the maximum number of child nodes that a node may have.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.StrTree`2.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary> 
            Constructs an STRtree with the default (10) node capacity.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.StrTree`2.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},System.Int32)">
            <summary> 
            Constructs an STRtree with the given maximum number of child nodes that
            a node may have.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.StrTree`2.Query(GeoAPI.Geometries.IExtents{`0})">
            <summary>
            Returns items whose bounds intersect the given envelope.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.StrTree`2.CreateParentBoundables(System.Collections.Generic.IList{GeoAPI.Indexing.IBoundable{GeoAPI.Geometries.IExtents{`0}}},System.Int32)">
            <summary>
            Creates the parent level for the given child level. First, orders the items
            by the x-values of the midpoints, and groups them into vertical slices.
            For each slice, orders the items by the y-values of the midpoints, and
            group them into runs of size M (the node capacity). For each run, creates
            a new (parent) node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.StrTree`2.VerticalSlices(System.Collections.Generic.ICollection{GeoAPI.Indexing.IBoundable{GeoAPI.Geometries.IExtents{`0}}},System.Int32)">
            <param name="childBoundables">
            Must be sorted by the x-value of the envelope midpoints.
            </param>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.IntervalSize">
            <summary>
            Provides a test for whether an interval is
            so small it should be considered as zero for the purposes of
            inserting it into a binary tree.
            The reason this check is necessary is that round-off error can
            cause the algorithm used to subdivide an interval to fail, by
            computing a midpoint value which does not lie strictly between the
            endpoints.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Index.Quadtree.IntervalSize.MinBinaryExponent">
            <summary> 
            This value is chosen to be a few powers of 2 less than the
            number of bits available in the Double representation (i.e. 53).
            This should allow enough extra precision for simple computations to be correct,
            at least for comparison purposes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.IntervalSize.IsZeroWidth(System.Double,System.Double)">
            <summary> 
            Computes whether the interval [min, max] is effectively zero width.
            I.e. the width of the interval is so much less than the
            location of the interval that the midpoint of the interval cannot be
            represented precisely.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Position">
            <summary> 
            A Position indicates the position of a Location relative to a graph component
            (Node, Edge, or Area).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Position.Opposite(NetTopologySuite.GeometriesGraph.Positions)">
            <summary> 
            Returns Positions.Left if the position is Positions.Right, 
            Positions.Right if the position is Left, or the position
            otherwise.
            </summary>
            <param name="position"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Depth">
            <summary>
            A <see cref="T:NetTopologySuite.GeometriesGraph.Depth"/> records the topological depth of the sides
            of an <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/> for up to two 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> instances.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.IsNull">
            <summary>
            A Depth object is null (has never been initialized) if all depths are null.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Depth.Normalize">
            <summary>
            Normalize the depths for each point, if they are non-null.
            </summary>
            <remarks>
            A normalized depth
            has depth values in the set { 0, 1 }.
            Normalizing the depths
            involves reducing the depths by the same amount so that at least
            one of them is 0.  If the remaining value is > 0, it is set to 1.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Depth.Item(System.Int32,NetTopologySuite.GeometriesGraph.Positions)">
            <summary>
            Gets or sets the depth for the given <paramref name="geometryIndex"/>
            at the given <paramref name="position"/>.
            </summary>
            <param name="geometryIndex">The index of the geometry: 0 or 1.</param>
            <param name="position">The position relative to the given geometry.</param>
            <returns>
            The depth stored for the geometry at the position, or <see langword="null"/>
            if none is stored.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Noding.NodedSegmentString`1">
            <summary>
            Represents a list of contiguous line segments, and supports noding the segments.
            The line segments are represented by an set of <typeparamref name="TCoordinate"/>s.
            Intended to optimize the noding of contiguous segments by
            reducing the number of allocated objects.
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s can carry a context object, which is useful
            for preserving topological or parentage information.
            All noded substrings are initialized with the same context object.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString`1.#ctor(GeoAPI.Coordinates.ICoordinateSequence{`0},System.Object)">
            <summary>
            Creates a new segment string from a list of vertices.
            </summary>
            <param name="coordinates">The vertices of the segment string.</param>
            <param name="data">The user-defined data of this segment string (may be null).</param>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString`1.GetSegmentOctant(System.Int32)">
            <summary>
            Gets the octant of the segment starting at vertex <paramref name="index"/>.
            </summary>
            <param name="index">
            The index of the vertex starting the segment.  
            Must not be the last index in the vertex list
            </param>
            <returns>The octant of the segment at the vertex.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString`1.AddIntersections(NetTopologySuite.Algorithm.Intersection{`0},System.Int32,System.Int32)">
            <summary>
            Adds edge intersections for one or both
            intersections found for a segment of an edge to the edge intersection list.   
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.NodedSegmentString`1.AddIntersection(NetTopologySuite.Algorithm.Intersection{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a <see cref="T:NetTopologySuite.Noding.SegmentNode`1"/> for intersection
            <paramref name="intersectionPointIndex"/>.
            </summary>
            <remarks>
            An intersection that falls exactly on a vertex
            of the <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/> is normalized
            to use the higher of the two possible segmentIndexes.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Noding.NodedSegmentString`1.Context">
            <summary>
            Gets or sets the user-defined context for this segment string.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Densify.Densifier`1">
            <summary>
            Densifies a geometry by inserting extra vertices along the line segments
            in the geometry. The densified geometry contains no line segment which
            is longer than the given distance tolerance.
            Densified polygonal geometries are guaranteed to be topologically correct.
            The coordinates created during densification respect the input geometry's
            {@link PrecisionModel}.
            Note: At some future point this class will offer a variety of densification strategies.
             </summary>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier`1.Densify(GeoAPI.Geometries.IGeometry{`0},System.Double)">
            <summary>
            Densifies a geometry using a given distance tolerance,
            and respecting the input geometry's <see cref="T:GeoAPI.Coordinates.IPrecisionModel`1"/>.
            </summary>
            <param name="geom">Geometry to densify</param>
            <param name="distanceTolerance">Distance tolerance to densify</param>
            <returns>The densified geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier`1.DensifyPoints(`0[],System.Double,GeoAPI.Coordinates.ICoordinateFactory{`0})">
            Densifies a coordinate sequence.
            
            @param pts
            @param distanceTolerance
            @return the densified coordinate sequence
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Creates a new densifier instance. Assigns inputGeom's GeometryFactory
            </summary>
            <param name="inputGeom">geometry to densify</param>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier`1.#ctor(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Creates a new densifier instance. Assigns inputGeom's GeometryFactory
            </summary>
            <param name="inputGeom">geometry to densify</param>
            <param name="factory">geometryfactory to create densified geometry</param>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier`1.GetResultGeometry">
            Gets the densified geometry.
            
            @return the densified geometry
        </member>
        <member name="P:NetTopologySuite.Densify.Densifier`1.DistanceTolerance">
            <summary>
            Sets the distance tolerance for the densification. All line segments
            in the densified geometry will be no longer than the distance tolereance.
            simplified geometry will be within this distance of the original geometry.
            The distance tolerance must be positive.
            </summary>	
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryTransformer`1">
            <summary>
            A framework for processes which transform an input <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> into
            an output <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>, possibly changing its structure and type(s).
            This class is a framework for implementing subclasses
            which perform transformations on
            various different Geometry subclasses.
            It provides an easy way of applying specific transformations
            to given point types, while allowing unhandled types to be simply copied.
            Also, the framework handles ensuring that if subcomponents change type
            the parent geometries types change appropriately to maintain valid structure.
            Subclasses will override whichever <c>TransformX</c> methods
            they need to to handle particular Geometry types.
            A typically usage would be a transformation that may transform Polygons into
            Polygons, LineStrings
            or Points.  This class would likely need to override the TransformMultiPolygon
            method to ensure that if input Polygons change type the result is a GeometryCollection,
            not a MultiPolygon.
            The default behavior of this class is to simply recursively transform
            each Geometry component into an identical object by copying.
            Note that all <c>TransformX</c> methods may return <see langword="null"/>,
            to avoid creating empty point objects. This will be handled correctly
            by the transformer.
            The Transform method itself will always
            return a point object.
            </summary>    
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryTransformer`1._preserveGeometryCollectionType">
            <summary> 
            <see langword="true"/> if a homogenous collection result
            from a <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> should still
            be a general GeometryCollection.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryTransformer`1._preserveType">
            <summary> 
            <see langword="true"/> if the type of the input should be preserved.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryTransformer`1._pruneEmptyGeometry">
            <summary>
            <see langword="true"/> if empty geometries should not be included in the result.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryTransformer`1.CreateCoordinateSequence(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Convenience method which provides standard way of
            creating a <c>CoordinateSequence</c>.
            </summary>
            <param name="coords">The coordinate array to copy.</param>
            <returns>A coordinate sequence for the array.</returns>
        </member>
        <member name="M:NetTopologySuite.Densify.Densifier`1.DensifyTransformer.CreateValidArea(GeoAPI.Geometries.IGeometry{`0})">
            Creates a valid area geometry from one that possibly has bad topology
            (i.e. self-intersections). Since buffer can handle invalid topology, but
            always returns valid geometry, constructing a 0-width buffer "corrects"
            the topology. Note this only works for area geometries, since buffer
            always returns areas. This also may return empty geometries, if the input
            has no actual area.
            
            @param roughAreaGeom
                     an area geometry possibly containing self-intersections
            @return a valid area geometry
        </member>
        <member name="P:NetTopologySuite.Algorithm.RayCrossingCounter`1.IsOnSegment">
            Reports whether the point lies exactly on one of the supplied segments.
            This method may be called at any time as segments are processed.
            If the result of this method is <tt>true</tt>, 
            no further segments need be supplied, since the result
            will never change again.
            
            @return true if the point lies exactly on a segment
        </member>
        <!-- Badly formed XML comment ignored for member "P:NetTopologySuite.Algorithm.RayCrossingCounter`1.Location" -->
        <member name="P:NetTopologySuite.Algorithm.RayCrossingCounter`1.IsPointInPolygon">
            <summary>
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Match.ISimilarityMeasure`1">
            <summary>
             An interface for classes which measures the degree of similarity between two <see cref="T:GeoAPI.Geometries.IGeometry`1"/>s.
             The computed measure lies in the range [0, 1].
             Higher measures indicate a great degree of similarity.
             A measure of 1.0 indicates that the input geometries are identical
             A measure of 0.0 indicates that the geometries
             have essentially no similarity.
             The precise definition of "identical" and "no similarity" may depend on the 
             exact algorithm being used.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.CentralEndpointIntersector`1">
            <summary>
            Computes an approximate intersection of two line segments
            by taking the most central of the endpoints of the segments.
            </summary>
            <remarks>
            This is effective in cases where the segments are nearly parallel
            and should intersect at an endpoint.
            It is also a reasonable strategy for cases where the 
            endpoint of one segment lies on or almost on the interior of another one.
            Taking the most central endpoint ensures that the computed intersection
            point lies in the envelope of the segments.
            Also, by always returning one of the input points, this should result 
            in reducing segment fragmentation.
            Intended to be used as a last resort for 
            computing ill-conditioned intersection situations which 
            cause other methods to fail.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.IO.WellKnownBinary.WkbReader`1">
            <summary>
            Converts data encoded in Well-Known Binary format to corresponding 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instances.
            </summary>
            <typeparam name="TCoordinate">The type of coordinate to use.</typeparam>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.ToGeometry(System.Byte[],GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Converts the given data encoded in Well-Known Binary format to the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> it represents.
            </summary>
            <param name="wkbData">
            The data to decode and represent as an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </param>
            <param name="geoFactory">
            A <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> used to create
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instances.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> represented by <paramref name="wkbData"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.ToGeometry(System.IO.Stream,GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Converts the given data encoded in Well-Known Binary format to the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> it represents.
            </summary>
            <param name="wkbData">
            A stream of data to decode and represent as an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </param>
            <param name="geoFactory">
            A <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> used to create
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instances.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> represented by the data obtained from
            <paramref name="wkbData"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.ToGeometry(System.IO.BinaryReader,GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Converts the given data encoded in Well-Known Binary format to the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> it represents.
            </summary>
            <param name="wkbData">
            A <see cref="T:System.IO.BinaryReader"/> which accesses data to decode 
            and represent as an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </param>
            <param name="geoFactory">
            A <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> used to create
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instances.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> represented by the data obtained from
            <paramref name="wkbData"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Creates a new instance of a <see cref="T:NetTopologySuite.IO.WellKnownBinary.WkbReader`1"/> with
            the given <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> used to create
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instances.
            </summary>
            <param name="geoFactory">
            The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> used to create instances
            of <see cref="T:GeoAPI.Geometries.IGeometry`1"/> from the Well-Known Binary data.
            </param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.Read(System.Byte[])">
            <summary>
            Converts the given data encoded in Well-Known Binary format to the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> it represents.
            </summary>
            <param name="wkb">
            The data to decode and represent as an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> represented by <paramref name="wkb"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.Read(System.Byte[],System.Int32)">
            <summary>
            Converts the given data encoded in Well-Known Binary format to the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> it represents, starting at 
            <paramref name="offset"/> in <paramref name="wkb"/>.
            </summary>
            <param name="wkb">
            The data to decode and represent as an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </param>
            <param name="offset">
            The offset into <paramref name="wkb"/> at which to start decoding.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> represented by <paramref name="wkb"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.Read(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Converts the given data encoded in Well-Known Binary format to the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> it represents.
            </summary>
            <param name="wkb">
            The data to decode and represent as an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> represented by <paramref name="wkb"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.Read(System.IO.Stream)">
            <summary>
            Converts data accessed via the given <see cref="T:System.IO.Stream"/>, encoded in Well-Known Binary 
            format to the <see cref="T:GeoAPI.Geometries.IGeometry`1"/> it represents.
            </summary>
            <param name="wkb">
            A <see cref="T:System.IO.Stream"/> of data to decode and represent as 
            an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> represented by the data in
            <paramref name="wkb"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.Read(System.IO.BinaryReader)">
            <summary>
            Converts data accessed via the given <see cref="T:System.IO.BinaryReader"/>, encoded in Well-Known Binary 
            format to the <see cref="T:GeoAPI.Geometries.IGeometry`1"/> it represents.
            </summary>
            <param name="wkb">
            A <see cref="T:System.IO.BinaryReader"/> accessing data to decode and represent as 
            an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.IGeometry`1"/> represented by the data accessed through
            <paramref name="wkb"/>.
            </returns>
        </member>
        <member name="P:NetTopologySuite.IO.WellKnownBinary.WkbReader`1.GeometryFactory">
            <summary>
            Gets the <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> used to create instances
            of <see cref="T:GeoAPI.Geometries.IGeometry`1"/> from the Well-Known Binary data.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.IQuadEdgeLocator`1">
            <summary>
             An interface for classes which locate an edge in a <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/>
             which either contains a given <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> 
             or is an edge of a triangle which contains V. 
             Implementors may utilized different strategies for
             optimizing locating containing edges/triangles.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.IQuadEdgeLocator`1.Locate(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Finds a quadedge of a triangle containing a location specified by a <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/>, if one exists.
            </summary>
            <param name="v">the vertex to locate</param>
            <returns>a quadedge on the edge of a triangle which touches or contains the location </returns>
            <returns>null if no such triangle exists</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.QuadtreeNestedRingTester`1">
            <summary>
            Tests whether any of a set of <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>s are
            nested inside another ring in the set, using a <see cref="T:NetTopologySuite.Index.Quadtree.Quadtree`2"/>
            index to speed up the comparisons.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.HotPixel`1">
            <summary>
            Implements a "hot pixel" as used in the Snap Rounding algorithm.
            </summary>
            <remarks>
            A hot pixel contains the interior of the tolerance square and the boundary
            minus the top and right segments.
            The hot pixel operations are all computed in the integer domain
            to avoid rounding problems.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel`1.#ctor(`0,System.Double,NetTopologySuite.Algorithm.LineIntersector{`0},GeoAPI.Coordinates.ICoordinateFactory{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.Snapround.HotPixel`1"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.HotPixel`1.GetSafeExtents">
            <summary>
            Returns a "safe" envelope that is guaranteed to contain the 
            hot pixel.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.RTree.RTreeBranchNode`2">
            <summary>
            </summary>
            <typeparam name="TBounds"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="T:NetTopologySuite.Index.RTree.RTreeNode`2">
            <summary>
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Index.RTree.RTreeNode`2.#ctor(GeoAPI.Indexing.IBoundsFactory{`0},System.Int32)">
            <summary>
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:NetTopologySuite.Index.RTree.RTreeNode`2.#ctor(GeoAPI.Indexing.IBoundsFactory{`0},`0,System.Int32)">
            <summary>
            </summary>
            <param name="bounds"></param>
            <param name="level"></param>
        </member>
        <member name="M:NetTopologySuite.Index.RTree.RTreeBranchNode`2.#ctor(GeoAPI.Indexing.IBoundsFactory{`0},System.Int32,NetTopologySuite.Index.RTree.RTreeNode{`0,`1},NetTopologySuite.Index.RTree.RTreeNode{`0,`1})">
            <summary>
            </summary>
            <param name="level"></param>
            <param name="node1"></param>
            <param name="node2"></param>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector`1">
            <summary>
            Finds all intersections in one or two sets of edges,
            using the straightforward method of
            comparing all segments.
            This algorithm is too slow for production use, but is useful for testing purposes.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector`1">
            <summary>
            An <see cref="T:NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector`1"/> computes all the 
            intersections between the edges in the set.  It adds the computed 
            intersections to each edge they are found on.
            </summary>
            <remarks>
            An <see cref="T:NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector`1"/> may be used in two scenarios:
            <list type="bullet">
            <item><description>
            determining the internal intersections between a single set of edges
            </description></item>
            <item><description>
            determining the mutual intersections between two different sets of edges
            </description></item>
            </list>
            It uses a <see cref="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1"/> to compute the 
            intersections between segments and to record statistics about what 
            kinds of intersections were found.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector`1.ComputeIntersections(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge{`0}},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector{`0},System.Boolean)">
            <summary>
            Computes all self-intersections between edges in a set of edges,
            allowing client to choose whether self-intersections are computed.
            </summary>
            <param name="edges">A list of edges to test for intersections.</param>
            <param name="si">
            The <see cref="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1"/> to use.
            </param>
            <param name="testAllSegments">
            <see langword="true"/> if self-intersections are to be tested as well.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.EdgeSetIntersector`1.ComputeIntersections(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge{`0}},System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.Edge{`0}},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector{`0})">
            <summary> 
            Computes all mutual intersections between two sets of edges.
            </summary>
            <param name="edges0">
            One set of edges to test for mutual intersections with the other set.
            </param>
            <param name="edges1">
            The other set of edges to test for mutual intersections.
            </param>
            <param name="si">
            The <see cref="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1"/> to use.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SimpleEdgeSetIntersector`1.computeIntersects(NetTopologySuite.GeometriesGraph.Edge{`0},NetTopologySuite.GeometriesGraph.Edge{`0},NetTopologySuite.GeometriesGraph.Index.SegmentIntersector{`0})">
            <summary>
            Performs a brute-force comparison of every segment in each Edge.
            This has n^2 performance, and is about 100 times slower than using
            monotone chains.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.GeometryGraph`1">
            <summary>
            A <see cref="T:NetTopologySuite.GeometriesGraph.GeometryGraph`1"/> is a graph that models a given 
            <see cref="P:NetTopologySuite.GeometriesGraph.GeometryGraph`1.Geometry"/>, where nodes and edges in the graph
            correspond to vertexes and line segments in the geometry.
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.GeometryGraph`1._useBoundaryDeterminationRule">
            <summary>
            If this flag is true, the Boundary Determination Rule will used when deciding
            whether nodes are in the boundary or not
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph`1.AddEdge(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary> 
            Add an <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/> computed externally.  
            The <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> on the edge is assumed to be correct.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph`1.AddPoint(`0)">
            <summary>
            Add a point computed externally.  The point is assumed to be a
            <see cref="T:GeoAPI.Geometries.IPoint`1"/> geometry part, 
            which has a location of <see cref="F:GeoAPI.Geometries.Locations.Interior"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph`1.ComputeSelfNodes(NetTopologySuite.Algorithm.LineIntersector{`0},System.Boolean)">
            <summary>
            Compute self-nodes, taking advantage of the <see cref="T:GeoAPI.Geometries.OgcGeometryType"/> 
            to minimize the number of intersection tests, if possible (e.g. rings are
            not tested for self-intersection, since they are assumed to be valid).
            </summary>
            <param name="li">
            The <see cref="T:NetTopologySuite.Algorithm.LineIntersector`1"/> to use.
            </param>
            <param name="computeRingSelfNodes">
            If <see langword="false"/>, intersection checks are optimized 
            to not test rings for self-intersection.
            </param>
            <returns>
            The <see cref="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1"/> used, 
            containing information about the intersections found.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph`1.addPoint(GeoAPI.Geometries.IPoint{`0})">
            <summary> 
            Add a Point to the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph`1.addPolygonRing(GeoAPI.Geometries.ILineString{`0},GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary> 
            The left and right topological location arguments assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph`1.insertBoundaryPoint(System.Int32,`0)">
            <summary> 
            Adds points using the mod-2 rule of SFS.  This is used to add the boundary
            points of dim-1 geometries (Curves/MultiCurves).  According to the SFS,
            an endpoint of a Curve is on the boundary
            if it is in the boundaries of an odd number of Geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.GeometryGraph`1.addSelfIntersectionNode(System.Int32,`0,GeoAPI.Geometries.Locations)">
            <summary>
            Add a node for a self-intersection.
            If the node is a potential boundary node (e.g. came from an edge which
            is a boundary) then insert it as a potential boundary node.
            Otherwise, just add it as a regular node.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Extents`1">
            <summary>
            Defines a rectangular, orthogonal region of the 2D coordinate plane.
            </summary>
            <remarks>
            An <see cref="T:NetTopologySuite.Geometries.Extents`1"/> is often used to represent the 
            bounding box of a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>,
            e.g. the minimum and maximum x and y values of all the coordinates.
            Extents support infinite or half-infinite regions, by using the values of
            <see cref="F:System.Double.PositiveInfinity"/> and <see cref="F:System.Double.NegativeInfinity"/>.
            When Extents objects are created or initialized,
            the supplies extent values are automatically sorted into the correct order. 
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Creates a null <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates an <see cref="T:NetTopologySuite.Geometries.Extents`1"/> for a region defined by maximum and minimum values.
            </summary>
            <param name="factory">The factory to create the extents with</param>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},`0,`0)">
            <summary>
            Creates an <see cref="T:NetTopologySuite.Geometries.Extents`1"/> for a region defined by two Coordinates.
            </summary>
            <param name="factory">The factory to create the extents with</param>
            <param name="p1">The first Coordinate.</param>
            <param name="p2">The second Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},`0)">
            <summary>
            Creates an <see cref="T:NetTopologySuite.Geometries.Extents`1"/> for a region defined by a single Coordinate.
            </summary>
            <param name="factory">The factory to create the extents with</param>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},GeoAPI.Geometries.IExtents{`0})">
            <summary>
            Create an <see cref="T:NetTopologySuite.Geometries.Extents`1"/> from an existing Envelope.
            </summary>
            <param name="extents">The Envelope to initialize from.</param>
            <param name="factory">The factory to create the extents with</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.SetToEmpty">
            <summary>
            Makes this <see cref="T:NetTopologySuite.Geometries.Extents`1"/> a "null" envelope..
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.ExpandToInclude(`0)">
            <summary>
            Enlarges the boundary of the <see cref="T:NetTopologySuite.Geometries.Extents`1"/> so that it contains (p).
            Does nothing if (p) is already on or within the boundaries.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Intersection(GeoAPI.Geometries.IExtents{`0})">
            <summary>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Overlaps(GeoAPI.Geometries.IExtents{`0})">
            <summary>
            Use Intersects instead. In the future, Overlaps may be
            changed to be a true overlap check; that is, whether the intersection is
            two-dimensional.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Overlaps(`0)">
            <summary>
            Use Intersects instead.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Contains(GeoAPI.Geometries.IExtents{`0})">
            <summary>  
            Returns <see langword="true"/> if the <c>Envelope other</c>
            lies wholely inside this <see cref="T:NetTopologySuite.Geometries.Extents`1"/> (inclusive of the boundary).
            </summary>
            <param name="other"> the <see cref="T:NetTopologySuite.Geometries.Extents`1"/> which this <see cref="T:NetTopologySuite.Geometries.Extents`1"/> is being checked for containing.</param>
            <returns><see langword="true"/> if <c>other</c> is contained in this <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Distance(GeoAPI.Geometries.IExtents{`0})">
            <summary> 
            Computes the distance between this and another
            <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.
            The distance between overlapping Envelopes is 0.  Otherwise, the
            distance is the Euclidean distance between the closest points.
            </summary>
            <returns>The distance between this and another <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.System#ICloneable#Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>A new object that is a copy of this instance.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Union(`0)">
            <summary>
            Calculates the union of the current box and the given coordinate.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Union(GeoAPI.Geometries.IExtents{`0})">
            <summary>
            Calculates the union of the current box and the given box.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Intersects(`0,`0,`0)">
            <summary>
            Test the point q to see whether it intersects the Envelope
            defined by p1-p2.
            </summary>
            <param name="p1">One extremal point of the envelope.</param>
            <param name="p2">The other extremal point of the envelope.</param>
            <param name="q">Point to test for intersection.</param>
            <returns><see langword="true"/> if q intersects the envelope p1-p2.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Intersects(`0,`0,`0,`0)">
            <summary>
            Test the envelope defined by p1-p2 for intersection
            with the envelope defined by q1-q2.
            </summary>
            <param name="p1">One extremal point of the envelope Point.</param>
            <param name="p2">Another extremal point of the envelope Point.</param>
            <param name="q1">One extremal point of the envelope Q.</param>
            <param name="q2">Another extremal point of the envelope Q.</param>
            <returns><see langword="true"/> if Q intersects Point</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Init">
            <summary>
            Initialize to a null <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Init(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Initialize an <see cref="T:NetTopologySuite.Geometries.Extents`1"/> for a region defined by maximum and minimum values.
            </summary>
            <param name="x1">The first x-value.</param>
            <param name="x2">The second x-value.</param>
            <param name="y1">The first y-value.</param>
            <param name="y2">The second y-value.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Init(`0,`0)">
            <summary>
            Initialize an <see cref="T:NetTopologySuite.Geometries.Extents`1"/> 
            for a region defined by two <typeparamref name="TCoordinate"/>s.
            </summary>
            <param name="p1">The first coordinate.</param>
            <param name="p2">The second coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Init(`0)">
            <summary>
            Initialize an <see cref="T:NetTopologySuite.Geometries.Extents`1"/> for a region defined by a single Coordinate.
            </summary>
            <param name="p">The Coordinate.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Init(GeoAPI.Geometries.IExtents{`0})">
            <summary>
            Initialize an <see cref="T:NetTopologySuite.Geometries.Extents`1"/> from an existing 
            <see cref="T:GeoAPI.Geometries.IExtents`1"/>.
            </summary>
            <param name="extents">The Envelope to initialize from.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.ExpandToInclude(System.Double,System.Double)">
            <summary>
            Enlarges the boundary of the <see cref="T:NetTopologySuite.Geometries.Extents`1"/> 
            so that it contains (x, y). Does nothing if (x, y) is already on 
            or within the boundaries.
            </summary>
            <param name="x">
            The value to lower the minimum x to or to raise the maximum x to.
            </param>
            <param name="y">
            The value to lower the minimum y to or to raise the maximum y to.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Translate(System.Double,System.Double)">
            <summary>
            Translates this envelope by given amounts in the X and Y direction.
            </summary>
            <param name="transX">The amount to translate along the X axis.</param>
            <param name="transY">The amount to translate along the Y axis.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Intersects(System.Double,System.Double)">
            <summary>  
            Check if the point <c>(x, y)</c> overlaps (lies inside) the region 
            of this <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.
            </summary>
            <param name="x">The x-ordinate of the point.</param>
            <param name="y">The y-ordinate of the point.</param>
            <returns>
            <see langword="true"/> if the point overlaps this <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Overlaps(System.Double,System.Double)">
            <summary>
            Use Intersects instead.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Contains(System.Double,System.Double)">
            <summary>  
            Returns <see langword="true"/> if the given point lies in or on the envelope.
            </summary>
            <param name="x"> the x-coordinate of the point which this <see cref="T:NetTopologySuite.Geometries.Extents`1"/> is
            being checked for containing.</param>
            <param name="y"> the y-coordinate of the point which this <see cref="T:NetTopologySuite.Geometries.Extents`1"/> is
            being checked for containing.</param>
            <returns><see langword="true"/> if <c>(x, y)</c> lies in the interior or
            on the boundary of this <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.op_Equality(NetTopologySuite.Geometries.Extents{`0},NetTopologySuite.Geometries.Extents{`0})">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Geometries.Extents`1"/> instances for value equality.
            </summary>
            <param name="left">The left <see cref="T:NetTopologySuite.Geometries.Extents`1"/> instance.</param>
            <param name="right">The right <see cref="T:NetTopologySuite.Geometries.Extents`1"/> instance.</param>
            <returns>
            <see langword="true"/> if the <typeparamref name="TCoordinate"/> values of the 
            <see cref="T:NetTopologySuite.Geometries.Extents`1"/> are equal.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.op_Inequality(NetTopologySuite.Geometries.Extents{`0},NetTopologySuite.Geometries.Extents{`0})">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Geometries.Extents`1"/> instances for value inequality.
            </summary>
            <param name="left">The left <see cref="T:NetTopologySuite.Geometries.Extents`1"/> instance.</param>
            <param name="right">The right <see cref="T:NetTopologySuite.Geometries.Extents`1"/> instance.</param>
            <returns>
            <see langword="true"/> if the <typeparamref name="TCoordinate"/> values of the 
            <see cref="T:NetTopologySuite.Geometries.Extents`1"/> are not equal.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Clone">
            <summary>
            Creates a deep copy of the current envelope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Union(GeoAPI.Geometries.IPoint{`0})">
            <summary>
            Calculates the union of the current box and the given point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Covers(`0)">
            <summary>
             Tests if the given point lies in or on the envelope.
            </summary>
            <param name="p">the point which this <code>Envelope</code> is being checked for containing</param>
            <returns><code>true</code> if the point lies in the interior or on the boundary of this <code>Envelope</code>.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Covers(GeoAPI.Geometries.IExtents)">
            <summary>
             Tests if the <code>Envelope other</code>
             lies wholely inside this <code>Envelope</code> (inclusive of the boundary).
            </summary>
            <param name="other"> the <code>Envelope</code> to check</param>
            <returns>true if this <code>Envelope</code> covers the <code>other</code> </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Extents`1.Covers(System.Double[])">
            <summary>
             Tests if the given point lies in or on the envelope.
            </summary>
             <param name="coordinates">coordinate of the point which this Extent is being checked for containing</param>
             <returns>true if (x, y) lies in the interior or on the boundary of this Extent.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Extents`1.IsEmpty">
            <summary>
            Returns <see langword="true"/> if this <see cref="T:NetTopologySuite.Geometries.Extents`1"/> 
            is an empty envelope.
            </summary>
            <returns>
            <see langword="true"/> if this <see cref="T:NetTopologySuite.Geometries.Extents`1"/> is uninitialized
            or is the envelope of the empty point.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Extents`1.Width">
            <summary>
            Returns the difference between the maximum and minimum x values.
            </summary>
            <returns>max x - min x, or 0 if this is a null <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Extents`1.Height">
            <summary>
            Returns the difference between the maximum and minimum y values.
            </summary>
            <returns>max y - min y, or 0 if this is a null <see cref="T:NetTopologySuite.Geometries.Extents`1"/>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Extents`1.Area">
            <summary>
            Returns the area of the envelope.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.SirTreePointInRing`1">
            <summary> 
            Implements <see cref="T:NetTopologySuite.Algorithm.IPointInRing`1"/> using 
            an <see cref="T:NetTopologySuite.Index.Strtree.SirTree`1"/> index to increase performance.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.IPointInRing`1">
            <summary> 
            An interface for classes which test whether a <typeparamref name="TCoordinate"/>
            lies inside a ring.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.RobustDeterminant">
            <summary> 
            Implements an algorithm to compute the
            sign of a 2x2 determinant for Double precision values robustly.
            It is a direct translation of code developed by Olivier Devillers.
            
            The original code carries the following copyright notice:
            ************************************************************************
            Author : Olivier Devillers
            Olivier.Devillers@sophia.inria.fr
            http:/www.inria.fr:/prisme/personnel/devillers/anglais/determinant.html
            *************************************************************************
            *************************************************************************
            Copyright (c) 1995  by  INRIA Prisme Project
            BP 93 06902 Sophia Antipolis Cedex, France.
            All rights reserved
            *************************************************************************
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.RobustDeterminant.SignOfDet2x2(System.Double,System.Double,System.Double,System.Double)">
            <returns>
            returns -1 if the determinant is negative,
            returns  1 if the determinant is positive,
            retunrs  0 if the determinant is null.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator`1">
            <summary>
            An interface for classes which determine the {@link Location} of
            points in a <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.IPointOnGeometryLocator`1.Locate(`0)">
            <summary>
            Determines the <see cref="T:GeoAPI.Geometries.Locations"/>  of a point in the <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="coordinate">point to test</param>
            <returns><see cref="T:GeoAPI.Geometries.Locations"/>the location of the point in the geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.CentroidArea`1">
            <summary> 
            Computes the centroid of an area point.
            </summary>
            <remarks>
            Algorithm:
            Based on the usual algorithm for calculating
            the centroid as a weighted sum of the centroids
            of a decomposition of the area into (possibly overlapping) triangles.
            The algorithm has been extended to handle holes and multi-polygons.
            See <see href="http://www.faqs.org/faqs/graphics/algorithms-faq"/>
            for further details of the basic approach.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CentroidArea`1.Add(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Adds the area defined by a Geometry to the centroid total.
            If the geometry has no area it does not contribute to the centroid.
            </summary>
            <param name="geom">The geometry to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CentroidArea`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Adds the area defined by an array of
            coordinates.  The array must be a ring;
            i.e. end with the same coordinate as it starts with.
            </summary>
            <param name="ring">A set of <typeparamref name="TCoordinate"/>s.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CentroidArea`1.centroid3(`0,`0,`0,`0@)">
            <summary> 
            Returns three times the centroid of the triangle p1-p2-p3.
            The factor of 3 is left in to permit division to be avoided until later.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CentroidArea`1.area2(`0,`0,`0)">
            <summary>
            Returns twice the signed area of the triangle p1-p2-p3,
            positive if a,b,c are oriented ccw, and negative if cw.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Angle`1">
            Utility functions for working with angles.
            Unless otherwise noted, methods in this class express angles in radians.
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.ToDegrees(System.Double)">
            <summary>
             Converts from radians to degrees.
            </summary>
            <param name="radians">an angle in radians</param>
            <returns>the angle in degrees</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.ToRadians(System.Double)">
            <summary>
             Converts from degrees to radians.
            </summary>
            <param name="angleDegrees">an angle in degrees</param>
            <returns>the angle in radians</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.CalculateAngle(`0,`0)">
            <summary>
             Returns the angle of the vector from p0 to p1,
             relative to the positive X-axis.
             The angle is normalized to be in the range [ -Pi, Pi ].
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns>the normalized angle (in radians) that p0-p1 makes with the positive x-axis.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.CalculateAngle(`0)">
            <summary>
             Returns the angle that the vector from (0,0) to p,
             relative to the positive X-axis.
             The angle is normalized to be in the range [ -Pi, Pi ].
            </summary>
            <param name="p"></param>
            <returns>the normalized angle (in radians) that p makes with the positive x-axis.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.IsAcute(`0,`0,`0)">
            <summary>
             Tests whether the angle between p0-p1-p2 is acute.
             An angle is acute if it is less than 90 degrees.
             Note: this implementation is not robust for angles very close to 90 degrees.
            </summary>
            <param name="p0">an endpoint of the angle</param>
            <param name="p1">the base of the angle</param>
            <param name="p2">the other endpoint of the angle</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.IsObtuse(`0,`0,`0)">
            <summary>
             Tests whether the angle between p0-p1-p2 is obtuse.
             An angle is obtuse if it is greater than 90 degrees.
             Note: this implementation is not robust for angles very close to 90 degrees.
            </summary>
            <param name="p0">an endpoint of the angle</param>
            <param name="p1">the base of the angle</param>
            <param name="p2">the other endpoint of the angle</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.CalculateAngleBetween(`0,`0,`0)">
            <summary>
             Returns the unoriented smallest angle between two vectors.
             The computed angle will be in the range [0, Pi].
            </summary>
            <param name="tip1">the tip of one vector</param>
            <param name="tail">the tail of each vector</param>
            <param name="tip2">the tip of the other vector</param>
            <returns>the angle between tail-tip1 and tail-tip2</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.CalculateAngleBetweenOriented(`0,`0,`0)">
            <summary>
             Returns the oriented smallest angle between two vectors.
             The computed angle will be in the range (-Pi, Pi].
             A positive result corresponds to a counterclockwise rotation
             from v1 to v2;
             a negative result corresponds to a clockwise rotation.
            </summary>
            <param name="tip1">the tip of v1</param>
            <param name="tail">the tail of each vector</param>
            <param name="tip2">the tip of v2</param>
            <returns>the angle between v1 and v2, relative to v1</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.InteriorAngle(`0,`0,`0)">
            <summary>
             Computes the interior angle between two segments of a ring. The ring is
             assumed to be oriented in a clockwise direction. The computed angle will be
             in the range [0, 2Pi]
            </summary>
            <param name="p0">a point of the ring</param>
            <param name="p1">the next point of the ring</param>
            <param name="p2">the next point of the ring</param>
            <returns>the interior angle based at <code>p1</code></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.GetTurn(System.Double,System.Double)">
            <summary>
             Returns whether an angle must turn clockwise or counterclockwise
             to overlap another angle.
            </summary>
            <param name="ang1">an angle (in radians)</param>
            <param name="ang2">an angle (in radians)</param>
            <returns>whether <code>ang1</code> must turn CLOCKWISE, COUNTERCLOCKWISE or NONE to overlap <code>ang2</code></returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.Normalize(System.Double)">
            <summary>
             Computes the normalized value of an angle, which is the
             equivalent angle in the range [ -Pi, Pi ].
            </summary>
            <param name="angle">the angle to normalize</param>
            <returns>an equivalent angle in the range [-Pi, Pi]</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.NormalizePositive(System.Double)">
            <summary>
             Computes the normalized positive value of an angle, which is the
             equivalent angle in the range [ 0, 2*Pi ].
            </summary>
            <param name="angle">the angle to normalize, in radians</param>
            <returns>an equivalent positive angle</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Angle`1.Difference(System.Double,System.Double)">
            <summary>
             Computes the unoriented smallest difference between two angles.
             The angles are assumed to be normalized to the range [-Pi, Pi].
             The result will be in the range [0, Pi].
            </summary>
            <param name="ang1">the angle of one vector (in [-Pi, Pi] )</param>
            <param name="ang2">the angle of the other vector (in range [-Pi, Pi] )</param>
            <returns>the angle (in radians) between the two vectors (in range [0, Pi] )</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.SineStarFactory`1">
            <summary>
            Creates geometries which are shaped like multi-armed stars with each arm shaped like a sine wave.
            These kinds of geometries are useful as a more complex geometry for testing algorithms.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1">
            <summary>
            Computes various kinds of common geometric shapes.
            Allows various ways of specifying the location and extent of the shapes,
            as well as number of line segments used to form them.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Create a shape factory which will create shapes using the given GeometryFactory.
            </summary>
            <param name="geoFactory">The factory to use.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.CreateRectangle">
            <summary>
            Creates a rectangular <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>.
            </summary>
            <returns>A rectangular polygon.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.CreateCircle">
            <summary>
            Creates a circular <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>.
            </summary>
            <returns>A circular polygon.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.CreateSquircle">
            <summary>
             Creates a squircular <see cref="T:GeoAPI.Geometries.IPolygon`1"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.CreateSupercircle(System.Double)">
            <summary>
             Creates a supercircular <see cref="T:GeoAPI.Geometries.IPolygon`1"/> of a given positive power.
            </summary>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.CreateArc(System.Double,System.Double)">
            <summary>
            Creates a elliptical arc, as a <see cref="T:GeoAPI.Geometries.ILineString`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.CreateArcPolygon(System.Double,System.Double)">
            <summary>
             Creates an elliptical arc polygon.
             The polygon is formed from the specified arc of an ellipse
             and the two radii connecting the endpoints to the centre of the ellipse.
            </summary>
            <param name="startAng">start angle in radians</param>
            <param name="angExtent">size of angle in radians</param>
            <returns>an elliptical arc polygon</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.Base">
            <summary>
            Gets or sets the location of the shape by specifying the base coordinate
            (which in most cases is the lower left point of the envelope containing the shape).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.Center">
            <summary>
            Gets or sets the location of the shape by specifying the center of
            the shape's bounding box.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.PointCount">
            <summary>
            Gets or sets the total number of points in the created Geometry.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.Size">
            <summary>
            Gets/Sets the size of the extent of the shape in both x and y directions.        
            </summary>                
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.Width">
            <summary>
            Gets/Sets the width of the shape.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.GeometricShapeFactory`1.Height">
            <summary>
            Gets/Sets the height of the shape.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.SineStarFactory`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
             Creates a factory which will create sine stars using the provided <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.SineStarFactory`1.CreateSineStar">
            <summary>
             Generates the geometry for the sine star
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.SineStarFactory`1.NumberOfArms">
            <summary>
             Gets/Sets the number of arms in the star
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Utilities.SineStarFactory`1.ArmLengthRatio">
            <summary>
             Gets/Sets the ration of the length of each arm to the distance from the tip
             of the arm to the centre of the star. Value should be between 0.0 and 1.0
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator`1">
            <summary>
             Computes a Delauanay Triangulation of a set of {@link Vertex}es, using an incrementatal insertion algorithm.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator`1.#ctor(NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision{`0})">
            <summary>
             Creates a new triangulator using the given {@link QuadEdgeSubdivision}.
             The triangulator uses the tolerance of the supplied subdivision.
            </summary>
            <param name="subdiv">a subdivision in which to build the TIN</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator`1.InsertSites(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Quadedge.Vertex{`0}})">
            <summary>
             Inserts all sites in a collection. The inserted vertices <b>MUST</b> be
             unique up to the provided tolerance value. (i.e. no two vertices should be
             closer than the provided tolerance value). They do not have to be rounded
             to the tolerance grid, however.
            </summary>
            <param name="vertices">a Collection of Vertex</param>
             <exception cref="T:NetTopologySuite.Triangulate.Quadedge.LocateFailureException`1">if the location algorithm fails to converge in a reasonable number of iterations</exception>
        </member>
        <member name="M:NetTopologySuite.Triangulate.IncrementalDelaunayTriangulator`1.InsertSite(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Inserts a new point into a subdivision representing a Delaunay
             triangulation, and fixes the affected edges so that the result is still a
             Delaunay triangulation.
            </summary>
            <param name="v">vertex to insert</param>
            <returns>a quadedge containing the inserted vertex</returns>
        </member>
        <member name="T:NetTopologySuite.Planargraph.Subgraph`1">
            <summary>
            A subgraph of a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/>.
            A subgraph may contain any subset of <see cref="T:NetTopologySuite.Planargraph.Edge`1"/>s
            from the parent graph.
            It will also automatically contain all <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s
            and <see cref="T:NetTopologySuite.Planargraph.Node`1"/>s associated with those edges.
            No new objects are created when edges are added -
            all associated components must already exist in the parent graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph`1.#ctor(NetTopologySuite.Planargraph.PlanarGraph{`0})">
            <summary>
            Creates a new subgraph of the given <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Subgraph`1.Add(NetTopologySuite.Planargraph.Edge{`0})">
            <summary>
            Adds an <see cref="T:NetTopologySuite.Planargraph.Edge`1"/> to the subgraph.
            The associated <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s and 
            <see cref="T:NetTopologySuite.Planargraph.Node`1"/>s are also added.
            </summary>
            <param name="e">The <see cref="T:NetTopologySuite.Planargraph.Edge`1"/> to add.</param>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Subgraph`1.Parent">
            <summary>
             Gets the <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/> which this subgraph is part of.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Subgraph`1.DirectedEdges">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the 
            <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s in this graph,
            in the order in which they were added.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Subgraph`1.Edges">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the <see cref="T:NetTopologySuite.Planargraph.Edge`1"/>s in this graph,
            in the order in which they were added.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Subgraph`1.Nodes">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the <see cref="T:NetTopologySuite.Planargraph.Node`1"/>s in this graph.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.Node`1">
            <summary>
            A node in a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/> is a location 
            where 0 or more <see cref="T:NetTopologySuite.Planargraph.Edge`1"/>s meet. 
            </summary>
            <remarks>
            A node is connected to each of its incident <see cref="T:NetTopologySuite.Planargraph.Edge`1"/>s 
            via an outgoing <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>. 
            Some clients using a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/> may want to
            subclass <see cref="T:NetTopologySuite.Planargraph.Node`1"/> to add their own application-specific
            data and methods.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Node`1._directedEdgeStar">
            <summary>
            The collection of DirectedEdges that leave this Node.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.Node`1._coordinate">
            <summary>
            The location of this Node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node`1.#ctor(`0)">
            <summary>
            Constructs a Node with the given location.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node`1.#ctor(`0,NetTopologySuite.Planargraph.DirectedEdgeStar{`0})">
            <summary>
            Constructs a Node with the given location and collection of outgoing DirectedEdges.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node`1.GetEdgesBetween(NetTopologySuite.Planargraph.Node{`0},NetTopologySuite.Planargraph.Node{`0})">
            <summary>
            Returns all Edges that connect the two nodes (which are assumed to be different).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node`1.AddOutEdge(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Adds an outgoing DirectedEdge to this Node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node`1.GetIndex(NetTopologySuite.Planargraph.Edge{`0})">
            <summary>
            Returns the zero-based index of the given Edge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Node`1.Remove">
            <summary>
            Removes this node from its containing graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Node`1.Coordinate">
            <summary>
            Returns the location of this Node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Node`1.OutEdges">
            <summary>
            Returns the collection of DirectedEdges that leave this Node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Node`1.Degree">
            <summary>
            Returns the number of edges around this Node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Node`1.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder`1">
            <summary>
            Finds all connected <see cref="T:NetTopologySuite.Planargraph.Subgraph`1"/>s of a 
            <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder`1.#ctor(NetTopologySuite.Planargraph.PlanarGraph{`0})">
            <summary>
            Initializes a new instance of the 
            <see cref="T:NetTopologySuite.Planargraph.Algorithm.ConnectedSubgraphFinder`1"/> class.
            </summary>
            <param name="graph">The <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/>.</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.ConnectedInteriorTester`1">
            <summary> 
            This class tests that the interior of an area <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            (a descendent of <see cref="T:GeoAPI.Geometries.ISurface`1"/> such as 
            <see cref="T:GeoAPI.Geometries.IPolygon`1"/> or <see cref="T:GeoAPI.Geometries.IMultiPolygon`1"/>)
            is connected.  An area Geometry is invalid if the interior is disconnected.
            This can happen if:
            - a shell self-intersects,
            - one or more holes form a connected chain touching a shell at two different points,
            - one or more holes form a ring around a subset of the interior.
            If a disconnected situation is found the location of the problem is recorded.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester`1.buildEdgeRings(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeEnd{`0}})">
            <summary>
            Form <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/>s in graph into Minimal EdgeRings.
            (Minimal Edgerings must be used, because only they are guaranteed to provide
            a correct isHole computation).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester`1.visitShellInteriors(GeoAPI.Geometries.IGeometry{`0},NetTopologySuite.GeometriesGraph.PlanarGraph{`0})">
            <summary>
            Mark all the edges for the edgeRings corresponding to the shells of the input polygons.  
            Only ONE ring gets marked for each shell - if there are others which remain unmarked
            this indicates a disconnected interior.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.ConnectedInteriorTester`1.hasUnvisitedShellEdge(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.EdgeRing{`0}})">
            <summary>
            Check if any shell ring has an unvisited edge.
            A shell ring is a ring which is not a hole and which has the interior
            of the parent area on the RHS.
            (Note that there may be non-hole rings with the interior on the LHS,
            since the interior of holes will also be polygonized into CW rings
            by the <c>LinkAllDirectedEdges()</c> step).
            </summary>
            <returns><see langword="true"/> if there is an unvisited edge in a non-hole ring.</returns>
        </member>
        <member name="T:NetTopologySuite.Noding.IteratedNoder`1">
            <summary>
            Nodes a set of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s completely.
            The set of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s is fully noded;
            i.e. noding is repeated until no further intersections are detected.
            </summary>
            <remarks>
            <para>
            Iterated noding using a <see cref="!:PrecisionModelType.Floating"/> precision model 
            is not guaranteed to converge, due to roundoff error. This problem is detected 
            and an exception is thrown.
            Clients can choose to rerun the noding using a lower precision model.
            </para>
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Noding.INoder`1">
            <summary>
            Computes all intersections between segments in a set of 
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s. Intersections found 
            are represented as <see cref="T:NetTopologySuite.Noding.SegmentNode`1"/>s and added to the
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s in which they occur.
            As a final step in the noding a new set of 
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s split at 
            the nodes may be returned.
            </summary>
            <typeparam name="TCoordinate">The type of coordinate.</typeparam>
        </member>
        <member name="M:NetTopologySuite.Noding.INoder`1.Node(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Computes the noding for a collection of 
            <see cref="T:NetTopologySuite.Noding.ISegmentString`1"/>s.
            Some noders may add all these nodes to the input 
            <see cref="T:NetTopologySuite.Noding.ISegmentString`1"/>s;
            others may only add some or none at all.
            </summary>
            <param name="segStrings">
            The <see cref="T:NetTopologySuite.Noding.ISegmentString`1"/>s to node.
            </param>
        </member>
        <member name="M:NetTopologySuite.Noding.INoder`1.ComputeNodes(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
             Computes the noding for a collection of {@link SegmentString}s.
             Some Noders may add all these nodes to the input SegmentStrings;
             others may only add some or none at all.
            </summary>
            <param name="segStrings">segStrings an enumerable of <see cref="T:NetTopologySuite.Noding.ISegmentString`1"/>s to node</param>
        </member>
        <member name="M:NetTopologySuite.Noding.IteratedNoder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Initializes a new instance of the 
            <see cref="T:NetTopologySuite.Noding.IteratedNoder`1"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IteratedNoder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},GeoAPI.Coordinates.IPrecisionModel{`0})">
            <summary>
            Initializes a new instance of the 
            <see cref="T:NetTopologySuite.Noding.IteratedNoder`1"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IteratedNoder`1.Node(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Fully nodes a set of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s, 
            i.e. peforms noding iteratively until no intersections are found between 
            segments.
            Maintains labeling of edges correctly through the noding.
            The <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s have the same context as their parent.
            </summary>
            <param name="segStrings">
            An enumeration of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s to be noded.
            </param>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">If the iterated noding fails to converge.</exception>
        </member>
        <member name="M:NetTopologySuite.Noding.IteratedNoder`1.node(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}},System.Int32@)">
            <summary>
            Node the input segment strings once
            and create the split edges between the nodes.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IteratedNoder`1.MaximumIterations">
            <summary>
            Gets or sets the maximum number of noding iterations performed before
            the noding is aborted. Experience suggests that this should rarely need to be changed
            from the default. The default is <see cref="F:NetTopologySuite.Noding.IteratedNoder`1.DefaultMaxIterations"/>.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Chain.MonotoneChainBuilder">
            <summary> 
            A <see cref="T:NetTopologySuite.Index.Chain.MonotoneChainBuilder"/> implements static functions
            to determine the monotone chains in a sequence of points.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainBuilder.GetChains``1(GeoAPI.Geometries.IGeometryFactory{``0},GeoAPI.Coordinates.ICoordinateSequence{``0},System.Object)">
            <summary>
            Return a list of the <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain`1"/>s
            for the given list of coordinates.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainBuilder.GetChainStartIndices``1(GeoAPI.Coordinates.ICoordinateSequence{``0})">
            <summary>
            Return an enumeration containing of start / end indexes of the 
            monotone chains for the given set of coordinates.
            The last entry in the enumeration is the index to the end point 
            of the point set, for use as a sentinel.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.BaseBinNode`1">
            <summary> 
            The base class for nodes in a <see cref="T:NetTopologySuite.Index.Bintree.BinTree`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.BaseBinNode`1.GetSubNodeIndex(GeoAPI.DataStructures.Interval,System.Double)">
            <summary> 
            Returns the index of the subnode that wholely contains the given interval.
            If none does, returns -1.
            Subnodes are numbered as follows:
                0 | 1
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.BaseBinNode`1.GetSubNode(GeoAPI.DataStructures.Interval,System.Double,System.Boolean)">
            <summary>
            Get the subnode for the index.
            If it doesn't exist, create it.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.BaseBinNode`1.GetSubNode(System.Int32,System.Boolean)">
            <summary>
            Get the subnode for the index.
            If it doesn't exist, create it.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly`1">
            <summary>
             <see>ContainsProperly</see> operation for <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly`1.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0})">
            <summary>
             Creates an instance of this operation.
            </summary>
            <param name="prepPoly">the PreparedPolygon to evaluate</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly`1.ContainsProperly(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0},GeoAPI.Geometries.IGeometry{`0})" -->
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContainsProperly`1.ContainsProperly(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Tests whether this PreparedPolygon containsProperly a given geometry.
            </summary>
            <param name="geom">the test geometry</param>
            <returns>true if the test geometry is contained properly</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferBuilder_110`1">
            <summary>
             Builds the buffer geometry for a given input geometry and precision model.
             Allows setting the level of approximation for circular arcs,
             and the precision model in which to carry out the computation.
             
             When computing buffers in floating point double-precision
             it can happen that the process of iterated noding can fail to converge (terminate).
             In this case a TopologyException will be thrown.
             Retrying the computation in a fixed precision
             can produce more robust results.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder_110`1.DepthDelta(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
             Compute the change in depth as an edge is crossed from R to L
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder_110`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},GeoAPI.Operations.Buffer.BufferParameters)">
            <summary>
             Creates a new BufferBuilder
            </summary>
            <param name="bufParams"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder_110`1.InsertUniqueEdge(NetTopologySuite.GeometriesGraph.Edge{`0})">
            Inserted edges are checked to see if an identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder_110`1.BuildSubgraphs(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Buffer.BufferSubgraph{`0}},NetTopologySuite.Operation.Overlay.PolygonBuilder{`0})">
             Completes the building of the input subgraphs by depth-labelling them,
             and adds them to the PolygonBuilder.
             The subgraph list must be sorted in rightmost-coordinate order.
            
             @param subgraphList the subgraphs to build
             @param polyBuilder the PolygonBuilder which will build the final polygons
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder_110`1.CreateEmptyResultGeometry">
            Gets the standard result for an empty buffer.
            Since buffer always returns a polygonal result,
            this is chosen to be an empty polygon.
            
            @return the empty result geometry
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder_110`1.WorkingPrecisionModel">
            <summary>
             Gets/Sets the precision model to use during the curve computation and noding,
             if it is different to the precision model of the Geometry.
             If the precision model is less than the precision of the Geometry precision model,
             the Geometry must have previously been rounded to that precision.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder_110`1.WorkingNoder">
            <summary>
             Gets/Sets the {@link Noder} to use during noding.
             This allows choosing fast but non-robust noding, or slower
             but robust noding.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.SimplePointInRing`1">
            <summary> 
            Tests whether a <c>Coordinate</c> lies inside
            a ring, using a linear-time algorithm.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.MinimumDiameter`1">
            <summary>
            Computes the minimum diameter of a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <remarks>
            The minimum diameter is defined to be the
            width of the smallest band that contains the point,
            where a band is a strip of the plane defined
            by two parallel lines.
            This can be thought of as the smallest hole that the point can be
            moved through, with a single rotation.
            The first step in the algorithm is computing the convex hull of the Geometry.
            If the input Geometry is known to be convex, a hint can be supplied to
            avoid this computation.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Compute a minimum diameter for a giver <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="inputGeom">a Geometry.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter`1.#ctor(GeoAPI.Geometries.IGeometry{`0},System.Boolean)">
            <summary> 
            Compute a minimum diameter for a giver <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>,
            with a hint if the Geometry is convex
            (e.g. a convex Polygon or LinearRing,
            or a two-point LineString, or a Point).
            </summary>
            <param name="inputGeom">a Geometry which is convex.</param>
            <param name="isConvex"><see langword="true"/> if the input point is convex.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.MinimumDiameter`1.computeConvexRingMinDiameter(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Compute the width information for a ring of <c>Coordinate</c>s.
            Leaves the width information in the instance variables.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Algorithm.MinimumDiameter`1.Length">
            <summary> 
            Gets the length of the minimum diameter of the input Geometry.
            </summary>
            <returns>The length of the minimum diameter.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.MinimumDiameter`1.WidthCoordinate">
            <summary>
            Gets the <typeparamref name="TCoordinate"/> forming one end of the minimum diameter.
            </summary>
            <returns>A coordinate forming one end of the minimum diameter.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.MinimumDiameter`1.SupportingSegment">
            <summary>
            Gets the segment forming the base of the minimum diameter.
            </summary>
            <returns>The segment forming the base of the minimum diameter.</returns>
        </member>
        <member name="P:NetTopologySuite.Algorithm.MinimumDiameter`1.Diameter">
            <summary>
            Gets a <see cref="T:GeoAPI.Geometries.ILineString`1"/> which is a minimum diameter.
            </summary>
            <returns>
            A <see cref="T:GeoAPI.Geometries.ILineString`1"/> which is a minimum diameter.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.ConvexHull`1">
            <summary> 
            Computes the convex hull of a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            The convex hull is the smallest convex Geometry that contains all the
            points in the input Geometry.
            Uses the Graham Scan algorithm.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Create a new convex hull construction for the input <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull`1.#ctor(GeoAPI.Coordinates.ICoordinateSequence{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Create a new convex hull construction for the input 
            <typeparamref name="TCoordinate"/> set.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull`1.GetConvexHull">
            <summary> 
            Returns a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> that represents the convex hull of the input point.
            The point will contain the minimal number of points needed to
            represent the convex hull.  In particular, no more than two consecutive
            points will be collinear.
            </summary>
            <returns> 
            If the convex hull contains 3 or more points, a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>;
            2 points, a <c>LineString</c>;
            1 point, a <c>Point</c>;
            0 points, an empty <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull`1.reduce(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary>
            Uses a heuristic to reduce the number of points scanned to compute the hull.
            The heuristic is to find a polygon guaranteed to
            be in (or on) the hull, and eliminate all points inside it.
            A quadrilateral defined by the extremal points
            in the four orthogonal directions
            can be used, but even more inclusive is
            to use an octilateral defined by the points in the 8 cardinal directions.
            Note that even if the method used to determine the polygon vertices
            is not 100% robust, this does not affect the robustness of the convex hull.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull`1.isBetween(`0,`0,`0)">
            <returns>
            Whether the three coordinates are collinear 
            and c2 lies between c1 and c3 inclusive.
            </returns>        
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull`1.lineOrPolygon(System.Collections.Generic.IEnumerable{`0})">
            <param name="coordinates"> The vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear).</param>
            <returns>
            A 2-vertex <c>LineString</c> if the vertices are collinear; 
            otherwise, a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> with unnecessary (collinear) vertices removed.
            </returns>       
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull`1.cleanRing(System.Collections.Generic.IEnumerable{`0})">
            <param name="original">The vertices of a linear ring, which may or may not be flattened (i.e. vertices collinear).</param>
            <returns>The coordinates with unnecessary (collinear) vertices removed.</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.ConvexHull`1.RadialComparator">
            <summary>
            Compares <typeparamref name="TCoordinate" />s for their angle and distance
            relative to an origin.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.ConvexHull`1.RadialComparator.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Algorithm.ConvexHull`1.RadialComparator"/> class.
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.WellKnownBinary.GeometryFromWkb">
            <summary>
            Converts Well-Known Binary representations to a 
            <see cref="T:GeoAPI.Geometries.IGeometry"/> instance.
            </summary>
            <remarks>
            <para>
            The Well-Known Binary Representation for <see cref="T:GeoAPI.Geometries.IGeometry"/> 
            (WkbGeometry) provides a portable 
            representation of a <see cref="T:GeoAPI.Geometries.IGeometry"/> value as a contiguous stream of bytes. 
            It permits <see cref="T:GeoAPI.Geometries.IGeometry"/> 
            values to be exchanged between an ODBC client and an SQL database in binary form.
            </para>
            <para>
            The Well-Known Binary Representation for <see cref="T:GeoAPI.Geometries.IGeometry"/> 
            is obtained by serializing a <see cref="T:GeoAPI.Geometries.IGeometry"/>
            instance as a sequence of numeric types drawn from the set {Unsigned Integer, Double} and
            then serializing each numeric type as a sequence of bytes using one of two well defined,
            standard, binary representations for numeric types (NDR, XDR). The specific binary encoding
            (NDR or XDR) used for a geometry Byte stream is described by a one Byte tag that precedes
            the serialized bytes. The only difference between the two encodings of geometry is one of
            Byte order, the XDR encoding is Big Endian, the NDR encoding is Little Endian.
            </para>
            </remarks> 
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryFromWkb.Parse``1(System.Byte[],GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates an <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instance from the 
            supplied <see cref="T:System.Byte"/> array containing the Well-Known Binary representation.
            </summary>
            <typeparam name="TCoordinate">Type of coordinate to use.</typeparam>
            <param name="bytes">
            A <see cref="T:System.Byte"/> array containing the geometry encoded in 
            the Well-Known Binary representation.
            </param>
            <param name="factory">
            The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> to use to create the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instance.
            </param>
            <returns>
            A <see cref="T:GeoAPI.Geometries.IGeometry"/> created from on supplied 
            Well-Known Binary representation.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryFromWkb.Parse``1(System.IO.Stream,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Parses a stream of data encoded as Well-Known Binary to generate an 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instance.
            </summary>
            <typeparam name="TCoordinate">Type of coordinate to use.</typeparam>
            <param name="data">
            A stream containing a sequence of bytes representing a Well-Known Binary
            encoded geometry.
            </param>
            <param name="factory">
            The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> to use to create the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instance.
            </param>
            <returns>
            A <see cref="T:GeoAPI.Geometries.IGeometry"/> created from on supplied 
            Well-Known Binary representation.
            </returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryFromWkb.Parse``1(System.IO.BinaryReader,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a <see cref="T:GeoAPI.Geometries.IGeometry`1"/> encoded as 
            Well-Known Binary representation to be read from <paramref name="reader"/>.
            </summary>
            <typeparam name="TCoordinate">Type of coordinate to use.</typeparam>
            <param name="reader">
            A <see cref="T:System.IO.BinaryReader"/> used to read the 
            Well-Known Binary encoded geometry.
            </param>
            <param name="factory">
            The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> to use to create the 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instance.
            </param>
            <returns>
            A <see cref="T:GeoAPI.Geometries.IGeometry`1"/> created from the Well-Known 
            Binary representation.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.ConstraintVertex`1">
            <summary>
             A vertex in a Constrained Delaunay Triangulation. The vertex may or may not lie on a constraint.
             If it does it may carry extra information about the original constraint.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NetTopologySuite.Triangulate.Quadedge.Vertex`1" -->
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.#ctor(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Double,System.Double)">
            <summary>
            </summary>
            <param name="factory"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.#ctor(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Double,System.Double,System.Double)">
            <summary>
            </summary>
            <param name="factory"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.#ctor(`0)">
            <summary>
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.Equals2D(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.Equals(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},System.Double)">
            <summary>
            </summary>
            <param name="x"></param>
            <param name="tolerance"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.Classify(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.CrossProduct(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            Computes the cross product k = u X v.
            
            @param v a vertex
            @return returns the magnitude of u X v
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.Dot(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            Computes the inner or dot product
            
            @param v, a vertex
            @return returns the dot product u.v
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.Times(System.Double)">
            Computes the scalar product c(v)
            
            @param v, a vertex
            @return returns the scaled vector
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.triArea(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            Computes twice the area of the oriented triangle (a, b, c), i.e., the area is positive if the
            triangle is oriented counterclockwise.
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.InCircle(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            Tests if this is inside the circle defined by the points a, b, c. This test uses simple
            double-precision arithmetic, and thus may not be robust.
            
            @param a
            @param b
            @param c
            @return true if this point is inside the circle defined by the points a, b, c
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.IsCCW(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Tests whether the triangle formed by this <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> and two
            </summary>
            <param name="b">second <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> of the triangle</param>
            <param name="c">third <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> of the triangle</param>
            <returns>true if the triangle is oriented CCW</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.RightOf(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.LeftOf(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.CircumRadiusRatio(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Computes the value of the ratio of the circumradius to shortest edge. If smaller than some
             given tolerance B, the associated triangle is considered skinny. For an equal lateral
             triangle this value is 0.57735. The ratio is related to the minimum triangle angle theta by:
             <code>circumRadius/shortestEdge = 1/(2sin(theta))</code>.
            </summary>
            <param name="b">second <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> of the triangle</param>
            <param name="c">third <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> of the triangle</param>
            <returns>ratio of circumradius to shortest edge.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.MidPoint(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})" -->
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.CircleCenter(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Computes the centre of the circumcircle of this <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> and two others.
            </summary>
            <param name="b">second <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> of the triangle</param>
            <param name="c">third <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/> of the triangle</param>
            <returns>the Coordinate which is the circumcircle of the 3 points.</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.InterpolateZValue(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             For this <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/>enclosed in a triangle defined by three verticies v0, v1 and v2, interpolate
             a z value from the surrounding vertices.
            </summary>
            <param name="v0"></param>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.InterpolateZ(`0,`0,`0,`0)" -->
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Triangulate.Quadedge.Vertex`1.InterpolateZ(`0,`0,`0)" -->
        <member name="P:NetTopologySuite.Triangulate.Quadedge.Vertex`1.X">
            <summary>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.Vertex`1.Y">
            <summary>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.Vertex`1.Z">
            <summary>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.Vertex`1.Coordinate">
            <summary>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConstraintVertex`1.#ctor(`0)">
            <summary>
             Creates a new constraint vertex
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConstraintVertex`1.Merge(NetTopologySuite.Triangulate.ConstraintVertex{`0})">
            <summary>
             Merges the constraint data in the vertex <tt>other</tt> into this vertex.
             This method is called when an inserted vertex is very close to an existing vertex in the triangulation.
            </summary>"/>
             <param name="other">the constraint vertex to merge</param>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConstraintVertex`1.IsOnConstraint">
            <summary>
             Gets/Sets whether this vertex lies on a constraint.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConstraintVertex`1.Constraint">
            <summary>
             Gets/Sets the external constraint information
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateNodeFactory`1">
            <summary>
            Used by the <see cref="T:NetTopologySuite.GeometriesGraph.NodeMap`1"/> in a 
            <see cref="T:NetTopologySuite.Operation.Relate.RelateNodeGraph`1"/> to create 
            <see cref="T:NetTopologySuite.Operation.Relate.RelateNode`1"/>s.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.NodeFactory`1">
            <summary>
            A factory for producing nodes in a <see cref="T:NetTopologySuite.GeometriesGraph.GeometryGraph`1"/>.
            </summary>
            <typeparam name="TCoordinate">
            The type of the coordinate in the geometry.
            </typeparam>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.NodeFactory`1.CreateNode(`0)">
            <summary> 
            The basic node constructor does not allow for incident edges.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.EdgeEndBuilder`1">
            <summary> 
            An <see cref="T:NetTopologySuite.Operation.Relate.EdgeEndBuilder`1"/> creates <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s 
            for all the "split edges" created by the intersections determined for an 
            <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>.
            </summary>
            <remarks>
            Computes the <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s which arise from a 
            noded <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBuilder`1.ComputeEdgeEnds(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            Creates stub edges for all the intersections in this
            Edge (if any) and returns them for insertion into a graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBuilder`1.CreateEdgeEndForPrev(NetTopologySuite.GeometriesGraph.Edge{`0},NetTopologySuite.GeometriesGraph.EdgeIntersection{`0},System.Nullable{NetTopologySuite.GeometriesGraph.EdgeIntersection{`0}})">
            <summary>
            Create a EdgeStub for the edge before the intersection eiCurr.
            </summary>
            <remarks>
            The previous intersection is provided
            in case it is the endpoint for the stub edge.
            Otherwise, the previous point from the parent edge will be the endpoint.
            eiCurr will always be an EdgeIntersection, but eiPrev may be null.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBuilder`1.CreateEdgeEndForNext(NetTopologySuite.GeometriesGraph.Edge{`0},NetTopologySuite.GeometriesGraph.EdgeIntersection{`0},System.Nullable{NetTopologySuite.GeometriesGraph.EdgeIntersection{`0}})">
            <summary>
            Create a StubEdge for the edge after the intersection eiCurr.
            </summary>
            <remarks>
            The next intersection is provided
            in case it is the endpoint for the stub edge.
            Otherwise, the next point from the parent edge will be the endpoint.
            eiCurr will always be an EdgeIntersection, but eiNext may be null.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.Polygonizer`1">
            <summary>
            Polygonizes a set of Geometrys which contain linework that
            represents the edges of a planar graph.
            </summary>
            <remarks>
            <para>
            Any dimension of Geometry is handled - the constituent linework is extracted
            to form the edges.
            </para>
            <para>
            The edges must be correctly noded; that is, they must only meet
            at their endpoints.  The Polygonizer will still run on incorrectly noded input
            but will not form polygons from incorrected noded edges.
            </para>
            The Polygonizer reports the follow kinds of errors:
            <list type="table">
            <item>
            <term>Dangles</term>
            <description>Edges which have one or both ends which are not incident on another edge endpoint.</description>
            </item>
            <item>
            <term>Cut Edges</term>
            <description>Edges which are connected at both ends but which do not form part of polygon.</description>
            </item>
            <item>
            <term>Invalid Ring Lines</term>
            <description>Edges which form rings which are invalid (e.g. the component lines contain a self-intersection).</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Operation.Polygonize.Polygonizer`1._dangles">
            <summary>
            Initialized with empty collections, in case nothing is computed
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer`1.Add(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <summary>
            Add a collection of geometries to be polygonized.
            May be called multiple times.
            Any dimension of Geometry may be added;
            the constituent linework will be extracted and used.
            </summary>
            <param name="geomList">A list of <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s with linework to be polygonized.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer`1.Add(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Add a point to the linework to be polygonized.
            May be called multiple times.
            Any dimension of Geometry may be added;
            the constituent linework will be extracted and used
            </summary>
            <param name="g">
            A <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with linework to be polygonized.
            </param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer`1.addLine(GeoAPI.Geometries.ILineString{`0})">
            <summary>
            Add a linestring to the graph of polygon edges.
            </summary>
            <param name="line">The <c>LineString</c> to add.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.Polygonizer`1.polygonize">
            <summary>
            Perform the polygonization, if it has not already been carried out.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.Polygonizer`1.Polygons">
            <summary>
            Compute and returns the list of polygons formed by the polygonization.
            </summary>        
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.Polygonizer`1.Dangles">
            <summary> 
            Compute and returns the list of dangling lines found during polygonization.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.Polygonizer`1.CutEdges">
            <summary>
            Compute and returns the list of cut edges found during polygonization.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.Polygonizer`1.InvalidRingLines">
            <summary>
            Compute and returns the list of lines forming invalid rings found during polygonization.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1">
            <summary>
            Represents a planar graph of edges that can be used to compute a
            polygonization, and implements the algorithms to compute the
            EdgeRings formed by the graph.
            The marked flag on DirectedEdges is used to indicate that a directed edge
            has be logically deleted from the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Create a new polygonization graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.DeleteAllEdges(NetTopologySuite.Planargraph.Node{`0})">
            <summary>
            Deletes all edges at a node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.AddEdge(GeoAPI.Geometries.ILineString{`0})">
            <summary>
            Add a <c>LineString</c> forming an edge of the polygon graph.
            </summary>
            <param name="line">The line to add.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.GetEdgeRings">
            <summary>
            Computes the EdgeRings formed by the edges in this graph.        
            </summary>
            <returns>A list of the{EdgeRings found by the polygonization process.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.DeleteCutEdges">
            <summary>
            Finds and removes all cut edges from the graph.
            </summary>
            <returns>
            A set of the <see cref="T:GeoAPI.Geometries.ILineString`1"/>s 
            forming the removed cut edges.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.DeleteDangles">
            <summary>
            Marks all edges from the graph which are "dangles".
            Dangles are edges which are incident on a node with degree 1.
            This process is recursive, since removing a dangling edge
            may result in another edge becoming a dangle.
            In order to handle large recursion depths efficiently,
            an explicit recursion stack is used.
            </summary>
            <returns>
            A set containing the <see cref="T:GeoAPI.Geometries.ILineString`1"/>s 
            that formed dangles.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.findLabeledEdgeRings(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge{`0}})">
            <param name="dirEdges">A List of the DirectedEdges in the graph.</param>
            <returns>A set of DirectedEdges, one for each edge ring found.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.computeNextCCWEdges(NetTopologySuite.Planargraph.Node{`0},System.Int64)">
            <summary>
            Computes the next edge pointers going CCW around the given node, for the
            given edgering label.
            This algorithm has the effect of converting maximal edgerings into minimal edgerings
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.findIntersectionNodes(NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge{`0},System.Int64)">
            <summary>
            Finds all nodes in a maximal edgering which are self-intersection nodes
            </summary>
            <returns> 
            The list of intersection nodes found,
            or null if no intersection nodes were found.       
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.ConvertMaximalToMinimalEdgeRings(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge{`0}})">
            <summary>
            Convert the maximal edge rings found by the initial graph traversal
            into the minimal edge rings required by NTS polygon topology rules.
            </summary>
            <param name="ringEdges">The list of start edges for the edgeRings to convert.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeGraph`1.findDirEdgesInRing(NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge{`0})">
            <summary>
            Traverse a ring of DirectedEdges, accumulating them into a list.
            This assumes that all dangling directed edges have been removed
            from the graph, so that there is always a next dirEdge.
            </summary>
            <param name="startDE">The DirectedEdge to start traversing at.</param>
            <returns>A List of DirectedEdges that form a ring.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.EdgeSetNoder`1">
            <summary>
            Nodes a set of edges.
            Takes one or more sets of edges and constructs a
            new set of edges consisting of all the split edges created by
            noding the input edges together.
            </summary>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LocationIndexOfPoint`1">
            <summary>
            Computes the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> of the point
            on a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>nearest a given <typeparamref name="TCoordinate"/>.
            The nearest point is not necessarily unique; this class
            always computes the nearest point closest to the start of the geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfPoint`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LocationIndexOfPoint`1"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfPoint`1.IndexOf(`0)">
            <summary>     
            Find the nearest location along a linear <see cref="T:GeoAPI.Geometries.IGeometry`1"/> to a given point.
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfPoint`1.IndexOfAfter(`0,System.Nullable{NetTopologySuite.LinearReferencing.LinearLocation{`0}})">
            <summary>
            Find the nearest <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> 
            along the linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> 
            to a given <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> 
            after the specified minimum <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>.
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <param name="minIndex">The minimum location for the point location.</param>
            <returns>The location of the nearest point.</returns>
            <remarks>
            If possible the location returned will be strictly greater 
            than the <paramref name="minIndex"/>. If this is not possible, 
            the value returned will equal <paramref name="minIndex"/>.
            (An example where this is not possible is when <paramref name="minIndex"/> = [end of line] ).
            </remarks>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LinearLocation`1">
            <summary>
            Represents a location along a <see cref="T:GeoAPI.Geometries.ILineString`1"/> 
            or <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/>.
            </summary>
            <remarks>
            The referenced geometry is not maintained within this location, 
            but must be provided for operations which require it.
            Various methods are provided to manipulate the location value
            and query the geometry it references.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.#ctor(System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
            <param name="segmentIndex">Index of the segment.</param>
            <param name="segmentFraction">The segment fraction.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> class:
            creates a location referring to the start of a linear geometry.
            </summary>
            <param name="componentIndex">Index of the component.</param>
            <param name="segmentIndex">Index of the segment.</param>
            <param name="segmentFraction">The segment fraction.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.GetSegment(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Gets a <see cref="T:NetTopologySuite.Geometries.LineSegment`1"/> representing the segment of the
             given linear <see cref="T:GeoAPI.Geometries.IGeometry`1"/> which contains this location.
            </summary>
             
            <param name="linearGeom"> a linear geometry</param>
            <returns>the <tt>LineSegment</tt> containing the location</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.CompareTo(NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <param name="other">
            The other <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> being compared to.
            </param>
            <returns>
            A negative integer, zero, or a positive integer as this 
            <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> is less than, equal to, 
            or greater than the specified <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.GetEndLocation(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Gets a location which refers to the end of a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="linear">The linear geometry.</param>
            <returns>A new <c>LinearLocation</c>.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.PointAlongSegmentByFraction(GeoAPI.Coordinates.ICoordinateFactory{`0},`0,`0,System.Double)">
            <summary>
            Computes the <typeparamref name="TCoordinate"/> of a point a given fraction
            along the line segment <c>(p0, p1)</c>.
            If the fraction is greater than 1.0 the last
            point of the segment is returned.
            If the fraction is less than or equal to 0.0 the first point
            of the segment is returned.
            </summary>
            <param name="p0">The first point of the line segment.</param>
            <param name="p1">The last point of the line segment.</param>
            <param name="fraction">The length to the desired point.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.Clamp(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Ensures the indexes are valid for a given linear <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="linear">A linear geometry.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.SnapToVertex(GeoAPI.Geometries.IGeometry{`0},System.Double)">
            <summary>
            Snaps the value of this location to
            the nearest vertex on the given linear <see cref="T:GeoAPI.Geometries.IGeometry`1"/>,
            if the vertex is closer than <paramref name="minDistance"/>.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <param name="minDistance">The minimum allowable distance to a vertex.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.GetSegmentLength(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Gets the length of the segment in the given
            Geometry containing this location.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns>The length of the segment.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.setToEnd(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> with 
            the value of this location to moved to refer the end of a linear geometry.
            </summary>
            <param name="linear">The linear geometry to create a location for.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.GetCoordinate(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Gets the <typeparamref name="TCoordinate"/> along the
            given linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> which is
            referenced by this location.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns>The <typeparamref name="TCoordinate"/> at the location.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.IsValid(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether this location refers to a valid
            location on the given linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
            <returns><see langword="true"/> if this location is valid.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.IsOnSameSegment(NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
             Tests whether two locations 
             are on the same segment in the parent <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="loc">a location on the same geometry</param>
            <returns>true if the locations are on the same segment of the parent geometry</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.CompareLocationValues(System.Int32,System.Int32,System.Double)">
            <summary>
            Compares this object with the specified index values for order.
            </summary>
            <param name="componentIndex">The component index.</param>
            <param name="segmentIndex">The segment index.</param>
            <param name="segmentFraction">The segment fraction.</param>
            <returns>
            A negative integer, zero, or a positive integer as this <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>
            is less than, equal to, or greater than the specified locationValues.
            </returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearLocation`1.CompareLocationValues(System.Int32,System.Int32,System.Double,System.Int32,System.Int32,System.Double)">
            <summary>
            Compares two sets of location values for order.
            </summary>
            <param name="componentIndex0">The first component index.</param>
            <param name="segmentIndex0">The first segment index.</param>
            <param name="segmentFraction0">The first segment fraction.</param>
            <param name="componentIndex1">The second component index.</param>
            <param name="segmentIndex1">The second segment index.</param>
            <param name="segmentFraction1">The second segment fraction.</param>
            <returns>
            A negative integer, zero, or a positive integer
            as the first set of location values is less than, equal to, 
            or greater than the second set of locationValues.
            </returns>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearLocation`1.ComponentIndex">
            <summary>
            Gets the component index for this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearLocation`1.SegmentIndex">
            <summary>
            Gets the segment index for this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearLocation`1.SegmentFraction">
            <summary>
            Gets the segment fraction for this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearLocation`1.IsVertex">
            <summary>
            Tests whether this location refers to a vertex:
            returns <see langword="true"/> if the location is a vertex.
            </summary>        
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1">
            <summary> 
            Models the end of an edge incident on a node.
            </summary>
            <remarks>
            <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s have a direction determined by 
            the direction of the ray from the initial point to the next point.
            EdgeEnds are <see cref="T:System.IComparable`1"/> under the ordering
            "a has a greater angle with the x-axis than b".
            This ordering is used to sort EdgeEnds around a node.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd`1.CompareDirection(NetTopologySuite.GeometriesGraph.EdgeEnd{`0})">
            <summary> 
            Implements the total order relation:
            a has a greater angle with the positive x-axis than b.
            Using the obvious algorithm of simply computing the angle is not robust,
            since the angle calculation is obviously susceptible to roundoff.
            A robust algorithm is:
            - first compare the quadrant.  If the quadrants
            are different, it it trivial to determine which vector is "greater".
            - if the vectors lie in the same quadrant, the computeOrientation function
            can be used to decide the relative orientation of the vectors.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEnd`1.ComputeLabel(NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            Subclasses should override this if they are using labels
            </summary>
        </member>
        <member name="F:NetTopologySuite.GeometriesGraph.DirectedEdge`1._depth">
            <summary> 
            The depth of each side (position) of this edge.
            The 0 element of the array is never used.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge`1.DepthFactor(GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Computes the factor for the change in depth 
            when moving from one location to another.
            E.g. if crossing from the <see cref="F:GeoAPI.Geometries.Locations.Interior"/> 
            to the <see cref="F:GeoAPI.Geometries.Locations.Exterior"/>
            the depth decreases, so the factor is -1.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdge`1.SetEdgeDepths(NetTopologySuite.GeometriesGraph.Positions,System.Int32)">
            <summary> 
            Set both edge depths.  
            One depth for a given side is provided.  
            The other is computed depending on the Location 
            transition and the depthDelta of the edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge`1.IsEdgeVisited">
            <summary>
            Gets or sets whether the entire edge is visited. The edge is visted when 
            both the <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/> and the corresponding 
            <see cref="P:NetTopologySuite.GeometriesGraph.DirectedEdge`1.Sym"/> have an <see cref="P:NetTopologySuite.GeometriesGraph.DirectedEdge`1.IsVisited"/>
            property with the value of <see langword="true"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge`1.IsLineEdge">
            <summary>
            Gets <see langword="true"/> if at least one of the edge's labels is a line label
            any labels which are not line labels have all <see cref="T:NetTopologySuite.GeometriesGraph.Positions"/> 
            equal to <see cref="F:GeoAPI.Geometries.Locations.Exterior"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.DirectedEdge`1.IsInteriorAreaEdge">
            <summary> 
            Gets <see langword="true"/> if
            the edge's label is an area label for both geometries
            and for each geometry both sides are in the interior.
            </summary>
            <returns><see langword="true"/> if this is an interior Area edge.</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers`1">
            <summary>
             <see cref="M:GeoAPI.Geometries.ISpatialRelation`1.Covers(GeoAPI.Geometries.IGeometry{`0})"/> operation for <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers`1.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0})">
            <summary>
             Creates an instance of this operation.
            </summary>
            <param name="prepPoly">the PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers`1.Covers(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Computes the <see cref="M:GeoAPI.Geometries.ISpatialRelation.Covers(GeoAPI.Geometries.IGeometry)"/> predicate between a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1"/> and a <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="prep">the prepared polygon</param>
            <param name="geom">a test geometry</param>
            <returns>true if the polygon covers the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers`1.Covers(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Tests whether this PreparedPolygon <tt>covers</tt> a given geometry.
            </summary>
            <param name="geom"></param>
            <returns>true if the test geometry is covered</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonCovers`1.FullTopologicalPredicate(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Computes the full topological <see cref="M:GeoAPI.Geometries.ISpatialRelation.Covers(GeoAPI.Geometries.IGeometry)"/> predicate.
            </summary>
             <param name="geom">the test geometry</param>
             <returns>true if this prepared polygon covers the test geometry</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.MultiPolygon`1">
            <summary>
            Basic implementation of <see cref="T:GeoAPI.Geometries.IMultiPolygon`1"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon`1.#ctor(GeoAPI.Geometries.IPolygon{`0}[])">
            <summary>
            Constructs a <c>MultiPolygon</c>.
            </summary>
            <param name="polygons">
            The <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>s for this <c>MultiPolygon</c>
            , or <see langword="null"/> or an empty array to create the empty point.
            Elements may be empty <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>s, but not <see langword="null"/>
            s. The polygons must conform to the assertions specified in the 
            <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.        
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> 
            with <see cref="P:NetTopologySuite.Geometries.GeometryFactory`1.PrecisionModel"/> <c> == </c> <see cref="!:PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IPolygon{`0}})">
            <summary>
            Constructs a <c>MultiPolygon</c>.
            </summary>
            <param name="polygons">
            The <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>s for this <c>MultiPolygon</c>
            , or <see langword="null"/> or an empty array to create the empty point.
            Elements may be empty <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>s, but not <see langword="null"/>
            s. The polygons must conform to the assertions specified in the 
            <see href="http://www.opengis.org/techno/specs.htm"/> OpenGIS Simple Features
            Specification for SQL.        
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> 
            with <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/> <c> == </c> <see cref="!:PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPolygon`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IPolygon{`0}},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.MultiPolygon`1"/>.
            </summary>
            <param name="polygons">
            The <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>s for this 
            <see cref="T:NetTopologySuite.Geometries.MultiPolygon`1"/>, or <see langword="null"/> 
            or an empty array to create the empty point.     
            </param>
            <remarks>
            Elements may be empty <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>s, but not 
            <see langword="null"/>s. The polygons must conform to the assertions 
            specified in the <see href="http://www.opengis.org/techno/specs.htm">
            OpenGIS Simple Features Specification for SQL</see>.   
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.LinearRing`1">
            <summary>  
            Basic implementation of <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>.
            </summary>
            <remarks>
            The first and last point in the coordinate sequence must be equal.
            Either orientation of the ring is allowed.
            A valid ring must not self-intersect.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.LineString`1">
            <summary>  
            Basic implementation of <c>LineString</c>.
            </summary>  
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString`1.#ctor(GeoAPI.Coordinates.ICoordinateSequence{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.Geometries.LineString`1"/> instance from the 
            given <paramref name="points"/>.
            </summary>
            <param name="points">
            The points of the linestring, or <see langword="null"/>
            to create the empty point. Consecutive points may not be equal.
            </param>
            <param name="factory">
            The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> instance used to generate
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString`1.Reverse">
            <summary>
            Creates an <see cref="T:GeoAPI.Geometries.ILineString`1"/> whose coordinates 
            are in the reverse order of this objects.
            </summary>
            <returns>
            An <see cref="T:GeoAPI.Geometries.ILineString`1"/> with coordinates 
            in the reverse order.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString`1.Normalize">
            <summary> 
            Normalizes a <see cref="T:NetTopologySuite.Geometries.LineString`1"/>.  
            A normalized <see cref="T:NetTopologySuite.Geometries.LineString`1"/> 
            has the first point which 
            is not equal to it's reflected point
            less than the reflected point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LineString`1.IsCoordinate(`0)">
            <summary>
            Returns true if the given point is a vertex of this <see cref="T:NetTopologySuite.Geometries.LineString`1"/>.
            </summary>
            <param name="pt">The <c>Coordinate</c> to check.</param>
            <returns><see langword="true"/> if <c>pt</c> is one of this <c>LineString</c>'s vertices.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString`1.Angle">
            <summary>
            Returns the value of the angle between the <see cref="P:NetTopologySuite.Geometries.LineString`1.StartPoint"/>
            and the <see cref="P:NetTopologySuite.Geometries.LineString`1.EndPoint"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LineString`1.Length">
            <summary>  
            Returns the length of this <c>LineString</c>
            </summary>
            <returns>The length of the polygon.</returns>
        </member>
        <member name="F:NetTopologySuite.Geometries.LinearRing`1.MinimumValidSize">
            <summary>
             The minimum number of vertices allowed in a valid non-empty ring (= 4).
             Empty rings with 0 vertices are also valid.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.LinearRing`1.#ctor(GeoAPI.Coordinates.ICoordinateSequence{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> with the given coordinates.
            </summary>
            <param name="coordinates">
            Points forming a closed and simple linestring, or
            <see langword="null"/> or an empty array to create the empty point.
            This array must not contain <see langword="null"/> elements.
            </param>
            <param name="factory"></param>
        </member>
        <member name="P:NetTopologySuite.Geometries.LinearRing`1.IsSimple">
            <summary>
            Returns <see langword="true"/> if the geometry has no anomalous geometric 
            points, such as self intersection or self tangency. The description of each 
            instantiable geometric class will include the specific conditions that cause 
            an instance of that class to be classified as not simple.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.LinearRing`1.IsClosed">
            <summary>
             Returns <see langword="true"/> if the first and last coordinate describe the same location.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Precision.CommonBitsRemover`1">
            <summary>
            Allow computing and removing common significand bits from one or more 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instances.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover`1.Add(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Add a point to the set of geometries whose common bits are
            being computed.  After this method has executed the
            common coordinate reflects the common bits of all added
            geometries.
            </summary>
            <param name="geom">A Geometry to test for common bits.</param>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover`1.RemoveCommonBits(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Removes the common coordinate bits from a Geometry.
            The coordinates of the Geometry are changed.
            </summary>
            <param name="geom">The Geometry from which to remove the common coordinate bits.</param>
            <returns>The shifted Geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBitsRemover`1.AddCommonBits(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Adds the common coordinate bits back into a Geometry.
            The coordinates of the Geometry are changed.
            </summary>
            <param name="geom">The Geometry to which to add the common coordinate bits.</param>
            <returns>The shifted Geometry.</returns>
        </member>
        <member name="P:NetTopologySuite.Precision.CommonBitsRemover`1.CommonCoordinate">
            <summary>
            The common bits of the Coordinates in the supplied Geometries.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.CoordinateOperation">
            <summary>
            A GeometryEditorOperation which modifies the coordinate list of a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            Operates on Geometry subclasses which contains a single coordinate list.
            </summary>      
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.IGeometryEditorOperation">
            <summary> 
            A interface which specifies an edit operation for Geometries.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor`1">
            <summary> 
            Supports creating a new <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> 
            which is a modification of an existing one.
            </summary>
            <remarks>
            <para>
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> objects are intended to be treated as immutable.
            This class allows you to "modify" a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            by traversing it and creating a new <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> 
            with the same overall structure but possibly modified components.
            </para>
            The following kinds of modifications can be made:
            <list type="bullet">
            <item>
            <description>
            The values of the coordinates may be changed.
            Changing coordinate values may make the resultant <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> 
            invalid; this is not checked by the <see cref="T:NetTopologySuite.Geometries.Utilities.GeometryEditor`1"/>.
            </description>
            </item>
            <item>
            <description>
            The coordinate lists may be changed (e.g. by adding or removing coordinates).
            The modifed coordinate lists must be consistent with their original parent component
            (e.g. a <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> must always have at least 4 
            coordinates, and the first and last coordinate must be equal).
            </description>
            </item>
            <item>
            <description>
            Components of the original point may be deleted
            (e.g. holes may be removed from a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>, 
            or <see cref="T:NetTopologySuite.Geometries.LineString`1"/>s removed from a 
            <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>).
            Deletions will be propagated up the component tree appropriately.
            </description>
            </item>
            </list>
            <para>
            Note that all changes must be consistent with the original Geometry's structure
            (e.g. a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> cannot be collapsed into a 
            <see cref="T:NetTopologySuite.Geometries.LineString`1"/>).
            The resulting <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is not checked for validity.
            If validity needs to be enforced, the new Geometry's 
            <see cref="P:NetTopologySuite.Geometries.Geometry`1.IsValid"/> should be checked.
            </para>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Utilities.GeometryEditor`1._factory">
            <summary> 
            The factory used to create the modified Geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.#ctor">
            <summary> 
            Creates a new GeometryEditor object which will create
            an edited <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with the same {GeometryFactory} as the input Geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary> 
            Creates a new GeometryEditor object which will create
            the edited Geometry with the given GeometryFactory.
            </summary>
            <param name="factory">The GeometryFactory to create the edited Geometry with.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.Edit(GeoAPI.Geometries.IGeometry{`0},NetTopologySuite.Geometries.Utilities.GeometryEditor{`0}.IGeometryEditorOperation)">
            <summary> 
            Edit the input <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> with the given edit 
            operation. Clients will create subclasses of GeometryEditorOperation or
            CoordinateOperation to perform required modifications.
            </summary>
            <param name="geometry">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> to edit.</param>
            <param name="operation">The edit operation to carry out.</param>
            <returns>
            A new <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> which is the result of the editing.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.CoordinateOperation">
            <summary>
            A GeometryEditorOperation which modifies the coordinate list of a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            Operates on Geometry subclasses which contains a single coordinate list.
            </summary>      
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.IGeometryEditorOperation">
            <summary> 
            A interface which specifies an edit operation for Geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.IGeometryEditorOperation.Edit(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Edits a Geometry by returning a new Geometry with a modification.
            The returned Geometry might be the same as the Geometry passed in.
            </summary>
            <param name="geometry">The Geometry to modify.</param>
            <param name="factory">
            The factory with which to construct the modified Geometry
            (may be different to the factory of the input point).
            </param>
            <returns>A new Geometry which is a modification of the input Geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.GeometryEditor`1.CoordinateOperation.Edit(System.Collections.Generic.IEnumerable{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Edits the array of <c>Coordinate</c>s from a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="coordinates">The coordinate array to operate on.</param>
            <param name="geometry">The point containing the coordinate list.</param>
            <returns>An edited coordinate array (which may be the same as the input).</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder_110`1">
            <summary>
             Creates all the raw offset curves for a buffer of a <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
             Raw curves need to be noded together and polygonized to form the final buffer area.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder_110`1.#ctor(GeoAPI.Geometries.IGeometry{`0},System.Double,NetTopologySuite.Operation.Buffer.OffsetCurveBuilder_110{`0})">
            <summary>
             Creates an instance of this class
            </summary>
            <param name="inputGeom"></param>
            <param name="distance"></param>
            <param name="curveBuilder"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder_110`1.GetCurves">
            <summary>
             Computes the set of raw offset curves for the buffer.
             Each offset curve has an attached {@link Label} indicating
             its left and right location.
            </summary>
            <returns>
             An <see cref="T:System.Collections.Generic.IEnumerable`1"/> representing the raw buffer curves
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder_110`1.AddCurve(GeoAPI.Coordinates.ICoordinateSequence{`0},GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/> for a coordinate list
            which is a raw offset curve, and adds it to the list of buffer curves.
            </summary>
            <remarks>
            The SegmentString is tagged with a Label giving the topology of the curve.
            The curve may be oriented in either direction.
            If the curve is oriented CW, the locations will be:
            Left: Locations.Exterior.
            Right: Locations.Interior.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder_110`1.AddPoint(GeoAPI.Geometries.IPoint{`0})">
            <summary>
            Add a Point to the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder_110`1.AddPolygonRing(GeoAPI.Coordinates.ICoordinateSequence{`0},System.Double,NetTopologySuite.GeometriesGraph.Positions,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Adds an offset curve for a polygon.
            The side and left and right topological location arguments
            assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged and the side flipped.
            </summary>
            <param name="coord">The coordinates of the ring (must not contain repeated points).</param>
            <param name="offsetDistance">The distance at which to create the buffer.</param>
            <param name="side">The side of the ring on which to construct the buffer line.</param>
            <param name="cwLeftLoc">The location on the L side of the ring (if it is CW).</param>
            <param name="cwRightLoc">The location on the R side of the ring (if it is CW).</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder_110`1.IsErodedCompletely(System.Collections.Generic.IEnumerable{`0},System.Double)">
            <summary>
            The ringCoord is assumed to contain no repeated points.
            It may be degenerate (i.e. contain only 1, 2, or 3 points).
            In this case it has no area, and hence has a minimum diameter of 0.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder_110`1.IsTriangleErodedCompletely(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Collections.Generic.IEnumerable{`0},System.Double)">
            <summary>
            Tests whether a triangular ring would be eroded completely by the given
            buffer distance.
            This is a precise test.  It uses the fact that the inner buffer of a
            triangle converges on the inCentre of the triangle (the point
            equidistant from all sides).  If the buffer distance is greater than the
            distance of the inCentre from a side, the triangle will be eroded completely.
            This test is important, since it removes a problematic case where
            the buffer distance is slightly larger than the inCentre distance.
            In this case the triangle buffer curve "inverts" with incorrect topology,
            producing an incorrect hole in the buffer.       
            </summary>
        </member>
        <member name="T:GeoAPI.IO.WellKnownText.TokenType">
            <summary>
            Represents the type of token created by the StreamTokenizer class.
            </summary>
        </member>
        <member name="F:GeoAPI.IO.WellKnownText.TokenType.Word">
            <summary>
            Indicates that the token is a word.
            </summary>
        </member>
        <member name="F:GeoAPI.IO.WellKnownText.TokenType.Number">
            <summary>
            Indicates that the token is a number. 
            </summary>
        </member>
        <member name="F:GeoAPI.IO.WellKnownText.TokenType.Eol">
            <summary>
            Indicates that the end of line has been read. The field can only have this value if the eolIsSignificant method has been called with the argument true. 
            </summary>
        </member>
        <member name="F:GeoAPI.IO.WellKnownText.TokenType.Eof">
            <summary>
            Indicates that the end of the input stream has been reached.
            </summary>
        </member>
        <member name="F:GeoAPI.IO.WellKnownText.TokenType.Bof">
            <summary>
            Indicates that the beginning of the input stream has not been reached.
            </summary>
        </member>
        <member name="F:GeoAPI.IO.WellKnownText.TokenType.Whitespace">
            <summary>
            Indictaes that the token is white space (space, tab, newline).
            </summary>
        </member>
        <member name="F:GeoAPI.IO.WellKnownText.TokenType.Symbol">
            <summary>
            Characters that are not whitespace, numbers, etc...
            </summary>
        </member>
        <member name="T:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb">
            <summary>
            Converts a <see cref="T:GeoAPI.Geometries.IGeometry"/> instance 
            to a Well-Known Binary String representation.
            </summary>
            <remarks>
            <para>
            The Well-Known Binary Representation for <see cref="T:GeoAPI.Geometries.IGeometry"/> 
            (WKBGeometry) provides a portable representation of a <see cref="T:GeoAPI.Geometries.IGeometry"/> 
            value as a contiguous stream of bytes. It permits <see cref="T:GeoAPI.Geometries.IGeometry"/> 
            values to be exchanged between an ODBC client and an SQL database in binary form.
            </para>
            <para>
            The Well-Known Binary Representation for <see cref="T:GeoAPI.Geometries.IGeometry"/> 
            is obtained by serializing a <see cref="T:GeoAPI.Geometries.IGeometry"/>
            instance as a sequence of numeric types drawn from the set {Unsigned Integer, Double} and
            then serializing each numeric type as a sequence of bytes using one of two well defined,
            standard, binary representations for numeric types (NDR, XDR). The specific binary encoding
            (NDR or XDR) used for a geometry Byte stream is described by a one Byte tag that precedes
            the serialized bytes. The only difference between the two encodings of geometry is one of
            Byte order, the XDR encoding is Big Endian, the NDR encoding is Little Endian.</para>
            </remarks> 
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.Write(GeoAPI.Geometries.IGeometry)">
            <summary>
            Encodes a <see cref="T:GeoAPI.Geometries.IGeometry"/> to Well-Known Binary format
            and writes it to a Byte array using little endian Byte encoding.
            </summary>
            <param name="g">The geometry to encode as WKB.</param>
            <returns>WKB representation of the geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.Write(GeoAPI.Geometries.IGeometry,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Encodes a <see cref="T:GeoAPI.Geometries.IGeometry"/> to Well-Known Binary format
            and writes it to a Byte array using the specified encoding.
            </summary>
            <param name="g">The geometry to encode as WKB.</param>
            <param name="wkbByteOrder">Byte order to encode values in.</param>
            <returns>WKB representation of the geometry.</returns>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeType(GeoAPI.Geometries.IGeometry,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes the type number for this geometry.
            </summary>
            <param name="geometry">The geometry to determine the type of.</param>
            <param name="writer">Binary Writer</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeGeometry(GeoAPI.Geometries.IGeometry,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes the geometry to the binary writer.
            </summary>
            <param name="geometry">The geometry to be written.</param>
            <param name="bWriter"></param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeCoordinate(GeoAPI.Coordinates.ICoordinate,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes an <see cref="T:GeoAPI.Coordinates.ICoordinate"/> instance.
            </summary>
            <param name="coordinate">The coordinate vector to be written.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writePoint(GeoAPI.Geometries.IPoint,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes a Point.
            </summary>
            <param name="point">The point to be written.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeLineString(GeoAPI.Geometries.ILineString,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes a LineString.
            </summary>
            <param name="ls">The linestring to be written.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writePolygon(GeoAPI.Geometries.IPolygon,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes a polygon.
            </summary>
            <param name="poly">The polygon to be written.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeMultiPoint(GeoAPI.Geometries.IMultiPoint,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes a multipoint.
            </summary>
            <param name="mp">The multipoint to be written.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeMultiLineString(GeoAPI.Geometries.IMultiLineString,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes a multilinestring.
            </summary>
            <param name="mls">The multilinestring to be written.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeMultiPolygon(GeoAPI.Geometries.IMultiPolygon,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes a multipolygon.
            </summary>
            <param name="mp">The mulitpolygon to be written.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeGeometryCollection(GeoAPI.Geometries.IGeometryCollection,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes a GeometryCollection instance.
            </summary>
            <param name="gc">The GeometryCollection to be written.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeUInt32(System.UInt32,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes an unsigned 32-bit integer to the BinaryWriter using the specified Byte encoding.
            </summary>
            <param name="value">Value to write.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="M:NetTopologySuite.IO.WellKnownBinary.GeometryToWkb.writeDouble(System.Double,System.IO.BinaryWriter,GeoAPI.IO.WellKnownBinary.WkbByteOrder)">
            <summary>
            Writes a Double floating point value to the BinaryWriter using the specified Byte encoding.
            </summary>
            <param name="value">Value to write.</param>
            <param name="writer">Writer to persist WKB values to.</param>
            <param name="byteOrder">Byte order to encode values in.</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1">
            <summary>
             A class that represents the edge data structure which implements the quadedge algebra.
             The quadedge algebra was described in a well-known paper by Guibas and Stolfi,
             "Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams",
             <i>ACM Transactions on Graphics</i>, 4(2), 1985, 75-123.
             <para>
             Each edge object is part of a quartet of 4 edges, linked via their <tt>rot</tt> references.
             Any edge in the group may be accessed using a series of {@link #rot()} operations.
             Quadedges in a subdivision are linked together via their <tt>next</tt> references.
             The linkage between the quadedge quartets determines the topology
             of the subdivision. 
             </para>
             <para>
             The edge class does not contain separate information for vertice or faces; a vertex is implicitly
             defined as a ring of edges (created using the <tt>next</tt> field).
             </para>
             
            </summary>
            <typeparam name="TCoordinate"></typeparam>
             <typeparam name="TData"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.MakeEdge(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Creates a new QuadEdge quartet from {@link Vertex} o to {@link Vertex} d.
            </summary>
            <param name="o">the origin Vertex</param>
            <param name="d">the destination Vertex</param>
            <returns>the new QuadEdge quartet</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Connect(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0},NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
             Creates a new QuadEdge connecting the destination of a to the origin of
             b, in such a way that all three have the same left face after the
             connection is complete. Additionally, the data pointers of the new edge
             are set.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>the connected edge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Splice(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0},NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
             Splices two edges together or apart.
             Splice affects the two edge rings around the origins of a and b, and, independently, the two
             edge rings around the left faces of <tt>a</tt> and <tt>b</tt>. 
             In each case, (i) if the two rings are distinct,
             Splice will combine them into one, or (ii) if the two are the same ring, Splice will break it
             into two separate pieces. Thus, Splice can be used both to attach the two edges together, and
             to break them apart.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Swap(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
             Turns an edge counterclockwise inside its enclosing quadrilateral.
            </summary>
            <param name="e">the quadedge to turn</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.#ctor">
            <summary>
             Quadedges must be made using <see cref="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.MakeEdge(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})"/>, to ensure proper construction.
             </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.GetPrimary">
            <summary>
             Gets the primary edge of this quadedge and its <tt>sym</tt>.
             The primary edge is the one for which the origin
             and destination coordinates are ordered
             according to the standard {@link Coordinate} ordering
            </summary>
            <returns>the primary quadedge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Delete">
            <summary>
             Marks this quadedge as being deleted.
             This does not free the memory used by
             this quadedge quartet, but indicates
             that this edge no longer participates
             in a subdivision.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.InverseRot">
            <summary>
             Gets the dual of this edge, directed from its left to its right.
            </summary>
            <returns>the inverse rotated edge.</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Sym">
            <summary>
             Gets the edge from the destination to the origin of this edge.
            </summary>
            <returns>the sym of the edge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.GetLength">
            <summary>
             Gets the length of the geometry of this quadedge.
            </summary>
             <returns>the length of the quadedge</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.EqualsNonOriented(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
             Tests if this quadedge and another have the same line segment geometry, 
            </summary>
            <param name="qe">a quadege</param>
            <returns>true if the quadedges are based on the same line segment regardless of orientation regardless of orientation.</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.EqualsOriented(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
             Tests if this quadedge and another have the same line segment geometry
             with the same orientation.
            </summary>
            <param name="qe">a quadege</param>
            <returns>true if the quadedges are based on the same line segment</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.ToLineSegment">
            <summary>
             Creates a <see cref="T:NetTopologySuite.Geometries.LineSegment`1"/> representing the 
             geometry of this edge.
             </summary>
            <returns>LineSegment</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.ToString">
            Converts this edge to a WKT two-point <tt>LINESTRING</tt> indicating 
            the geometry of this edge.
            
            @return a String representing this edge's geometry
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Data">
            <summary>
            Gets/Sets the external data value for this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.IsLive">
            <summary>
             Tests whether this edge has been deleted.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Next">
            <summary>Gets/Sets the connected edge
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Rot">
            <summary>
             Gets the dual of this edge, directed from its right to its left.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.OriginNext">
            <summary>
             Gets the next CCW edge around the origin of this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.OriginPrev">
            <summary>
             Gets the next CW edge around (from) the origin of this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.DestinationNext">
            <summary>
             Gets the next CCW edge around (into) the destination of this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.DestinationPrev">
            <summary>
             Gets the next CW edge around (into) the destination of this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.LeftNext">
            <summary>
             Gets the CCW edge around the left face following this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.LeftPrev">
            <summary>
             Gets the CCW edge around the left face before this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.RightNext">
            <summary>
             Gets the edge around the right face ccw following this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.RightPrev">
            <summary>
             Gets the edge around the right face ccw before this edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Origin">
            <summary>
             Gets/Sets the vertex for this edge's origin
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1.Destination">
            <summary>
             Sets the vertex for this edge's destination
            </summary>
        </member>
        <member name="T:NetTopologySuite.Simplify.TaggedLinesSimplifier`1">
            <summary>
            Simplifies a collection of TaggedLineStrings, preserving topology
            (in the sense that no new intersections are introduced).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLinesSimplifier`1.Simplify(System.Collections.Generic.IEnumerable{NetTopologySuite.Simplify.TaggedLineString{`0}})">
            <summary>
            Simplify a collection of <see cref="T:NetTopologySuite.Simplify.TaggedLineString`1"/>s.
            </summary>
            <param name="taggedLines">The collection of lines to simplify.</param>
        </member>
        <member name="P:NetTopologySuite.Simplify.TaggedLinesSimplifier`1.DistanceTolerance">
            <summary>
            Gets or sets the distance tolerance for the simplification.
            Points closer than this tolerance to a simplified segment may
            be removed.
            </summary>        
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.IsValidOp`1">
            <summary>
            Implements the algorithsm required to compute the <see cref="P:NetTopologySuite.Geometries.Geometry`1.IsValid"/>
            method for <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s.
            See the documentation for the various geometry types for a specification of validity.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.IsValidCoordinate(`0)">
            <summary>
            Checks whether a coordinate is valid for processing.
            Coordinates are valid iff their x and y ordinates are in the
            range of the floating point representation.
            </summary>
            <param name="coord">The coordinate to validate.</param>
            <returns><see langword="true"/> if the coordinate is valid.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.FindPointNotNode(System.Collections.Generic.IEnumerable{`0},GeoAPI.Geometries.ILinearRing{`0},NetTopologySuite.GeometriesGraph.GeometryGraph{`0})">
            <summary>
            Find a point from the list of testCoords
            that is NOT a node in the edge for the list of searchCoords.
            </summary>
            <returns>The point found, or <see langword="null" /> if none found.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkValid(GeoAPI.Geometries.IPoint{`0})">
            <summary>
            Checks validity of a Point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkValid(GeoAPI.Geometries.IMultiPoint{`0})">
            <summary>
            Checks validity of a MultiPoint.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkValid(GeoAPI.Geometries.ILineString{`0})">
            <summary>
            Checks validity of a LineString.  
            Almost anything goes for lineStrings!
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkValid(GeoAPI.Geometries.ILinearRing{`0})">
            <summary>
            Checks validity of a LinearRing.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkValid(GeoAPI.Geometries.IPolygon{`0})">
            <summary>
            Checks the validity of a polygon and sets the validErr flag.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkNoSelfIntersectingRings(NetTopologySuite.GeometriesGraph.GeometryGraph{`0})">
            <summary>
            Check that there is no ring which self-intersects (except of course at its endpoints).
            This is required by OGC topology rules (but not by other models
            such as ESRI SDE, which allow inverted shells and exverted holes).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkNoSelfIntersectingRing(NetTopologySuite.GeometriesGraph.EdgeIntersectionList{`0})">
            <summary>
            Check that a ring does not self-intersect, except at its endpoints.
            Algorithm is to count the number of times each node along edge occurs.
            If any occur more than once, that must be a self-intersection.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.CheckHolesInShell(GeoAPI.Geometries.IPolygon{`0},NetTopologySuite.GeometriesGraph.GeometryGraph{`0})">
            <summary>
            Tests that each hole is inside the polygon shell.
            This routine assumes that the holes have previously been tested
            to ensure that all vertices lie on the shell or inside it.
            A simple test of a single point in the hole can be used,
            provide the point is chosen such that it does not lie on the
            boundary of the shell.
            </summary>
            <param name="p">The polygon to be tested for hole inclusion.</param>
            <param name="graph">A GeometryGraph incorporating the polygon.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkShellNotNested(GeoAPI.Geometries.ILinearRing{`0},GeoAPI.Geometries.IPolygon{`0},NetTopologySuite.GeometriesGraph.GeometryGraph{`0})">
            <summary>
            Check if a shell is incorrectly nested within a polygon.  This is the case
            if the shell is inside the polygon shell, but not inside a polygon hole.
            (If the shell is inside a polygon hole, the nesting is valid.)
            The algorithm used relies on the fact that the rings must be properly contained.
            E.g. they cannot partially overlap (this has been previously checked by
            <c>CheckRelateConsistency</c>).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Valid.IsValidOp`1.checkShellInsideHole(GeoAPI.Geometries.ILinearRing{`0},GeoAPI.Geometries.ILinearRing{`0},NetTopologySuite.GeometriesGraph.GeometryGraph{`0})">
            <summary> 
            This routine checks to see if a shell is properly contained in a hole.
            It assumes that the edges of the shell and hole do not
            properly intersect.
            </summary>
            <returns>
            <see langword="null" /> if the shell is properly contained, or
            a Coordinate which is not inside the hole if it is not.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.IsValidOp`1.IsSelfTouchingRingFormingHoleValid">
            <summary>
            <para>
            Gets or sets whether polygons using Self-Touching Rings to form
            holes are reported as valid.
            If this flag is set, the following Self-Touching conditions
            are treated as being valid:
            - The shell ring self-touches to create a hole touching the shell.
            - A hole ring self-touches to create two holes touching at a point.
            </para>
            <para>
            The default (following the OGC SFS standard)
            is that this condition is not valid (<c>false</c>).
            </para>
            <para>
            This does not affect whether Self-Touching Rings
            disconnecting the polygon interior are considered valid
            (these are considered to be invalid under the SFS, and many other
            spatial models as well).
            This includes "bow-tie" shells,
            which self-touch at a single point causing the interior to be disconnected,
            and "C-shaped" holes which self-touch at a single point causing an island to be formed.
            </para>
            </summary>
            <value>States whether geometry with this condition is valid.</value>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.ConsistentAreaTester`1">
            <summary> 
            Checks that a {GeometryGraph} representing an area
            (am <see cref="T:GeoAPI.Geometries.IPolygon`1"/> or <see cref="T:GeoAPI.Geometries.IMultiPolygon`1"/> )
            is consistent with the SFS semantics for area geometries.
            Checks include:
            Testing for rings which self-intersect (both properly and at nodes).
            Testing for duplicate rings.
            If an inconsistency if found the location of the problem is recorded.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.ConsistentAreaTester`1.InvalidPoint">
            <summary>
            Returns the intersection point, or <see langword="null" /> if none was found.
            </summary>        
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.ConsistentAreaTester`1.IsNodeEdgeAreaLabelsConsistent">
            <summary>
            Check all nodes to see if their labels are consistent.
            If any are not, return false.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Valid.ConsistentAreaTester`1.HasDuplicateRings">
            <summary>
            Checks for two duplicate rings in an area.
            Duplicate rings are rings that are topologically equal
            (that is, which have the same sequence of points up to point order).
            If the area is topologically consistent (determined by calling the
            <c>isNodeConsistentArea</c>,
            duplicate rings can be found by checking for EdgeBundles which contain more than one EdgeEnd.
            (This is because topologically consistent areas cannot have two rings sharing
            the same line segment, unless the rings are equal).
            The start point of one of the equal rings will be placed in invalidPoint.
            Returns <see langword="true"/> if this area Geometry is topologically consistent but has two duplicate rings.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.EdgeRing`1">
            <summary>
            Represents a ring of <c>PolygonizeDirectedEdge</c>s which form
            a ring of a polygon.  The ring may be either an outer shell or a hole.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing`1.FindEdgeRingContaining(NetTopologySuite.Operation.Polygonize.EdgeRing{`0},System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Polygonize.EdgeRing{`0}})">
            <summary>
            Find the innermost enclosing shell EdgeRing containing the argument EdgeRing, if any.
            The innermost enclosing ring is the <i>smallest</i> enclosing ring.
            The algorithm used depends on the fact that:
            ring A contains ring B iff envelope(ring A) contains envelope(ring B).
            This routine is only safe to use if the chosen point of the hole
            is known to be properly contained in a shell
            (which is guaranteed to be the case if the hole does not touch its shell).
            </summary>
            <returns>
            Containing EdgeRing, if there is one, OR
            null if no containing EdgeRing is found.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing`1.PointNotInList(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Finds a point in a list of points which is not contained in another list of points.
            </summary>
            <param name="testPoints">The <typeparamref name="TCoordinate"/>s to test.</param>
            <param name="points">
            An array of <typeparamref name="TCoordinate"/>s 
            to test the input points against.
            </param>
            <returns>
            A <c>Coordinate</c> from <c>testPts</c> which is not in <c>pts</c>, 
            or <see langword="null" />.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing`1.IsInList(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Tests whether a given point is in an array of points.
            Uses a value-based test.
            </summary>
            <param name="testPoint">A <typeparamref name="TCoordinate"/> for the test point.</param>
            <param name="points">An array of <typeparamref name="TCoordinate"/>s to test,</param>
            <returns><see langword="true"/> if the point is in the array.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing`1.Add(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Adds a DirectedEdge which is known to form part of this ring.
            </summary>
            <param name="de">The DirectedEdge to add.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.EdgeRing`1.AddHole(GeoAPI.Geometries.ILinearRing{`0})">
            <summary>
            Adds a hole to the polygon formed by this ring.
            </summary>
            <param name="hole">The LinearRing forming the hole.</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing`1.IsHole">
            <summary>
            Tests whether this ring is a hole.
            Due to the way the edges in the polyongization graph are linked,
            a ring is a hole if it is oriented counter-clockwise.
            </summary>
            <returns><see langword="true"/> if this ring is a hole.</returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing`1.Polygon">
            <summary>
            Computes and returns the Polygon formed by this ring and any 
            contained holes.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing`1.IsValid">
            <summary>
            Tests if the LinearRing ring formed by this edge ring is topologically valid.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing`1.LineString">
            <summary>
            Gets the coordinates for this ring as a <c>LineString</c>.
            Used to return the coordinates in this ring
            as a valid point, when it has been detected that the ring is topologically
            invalid.
            </summary>        
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.EdgeRing`1.Ring">
            <summary>
            Returns this ring as a LinearRing, or null if an Exception occurs while
            creating it (such as a topology problem). Details of problems are written to
            standard output.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.FastSegmentSetIntersectionFinder`1">
            <summary>
            Finds if two sets of {@link SegmentStrings}s intersect.
            Uses indexing for fast performance and to optimize repeated tests
            against a target set of lines.
            Short-circuited to return as soon an intersection is found.
            
            @version 1.7
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.FastSegmentSetIntersectionFinder`1.GetSegmentSetIntersector">
            <summary>
            Gets the segment set intersector used by this class.
            This allows other uses of the same underlying indexed structure.
            </summary>
            <returns> the segment set intersector used</returns>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.SirTree`1">
            <summary>
            One-dimensional version of an STR-packed R-tree.
            </summary>
            <remarks>
            SIR stands for
            "Sort-Interval-Recursive". STR-packed R-trees are described in:
            P. Rigaux, Michel Scholl and Agnes Voisard. Spatial Databases With
            Application To GIS. Morgan Kaufmann, San Francisco, 2002.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SirTree`1.#ctor">
            <summary> 
            Constructs an SIRtree with the default (10) node capacity.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SirTree`1.#ctor(System.Int32)">
            <summary> 
            Constructs an SIRtree with the given maximum number of child nodes that
            a node may have.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SirTree`1.Insert(System.Double,System.Double,`0)">
            <summary> 
            Inserts an item having the given bounds into the tree.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SirTree`1.Query(System.Double)">
            <summary>
            Returns items whose bounds intersect the given value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.SirTree`1.Query(System.Double,System.Double)">
            <summary> 
            Returns items whose bounds intersect the given bounds.
            </summary>
            <param name="x1">Possibly equal to x2.</param>
            <param name="x2">Possibly equal to x1.</param>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.Quadtree`2">
            <summary>
            A Quadtree is a spatial index structure for efficient querying
            of 2D rectangles.  
            </summary>
            <remarks>
            <para>
            If other kinds of spatial objects
            need to be indexed they can be represented by their
            envelopes.
            </para>
            <para>
            The quadtree structure is used to provide a primary filter
            for range rectangle queries.  The Query() method returns a list of
            all objects which may intersect the query rectangle.  Note that
            it may return objects which do not in fact intersect.
            A secondary filter is required to test for exact intersection.
            Of course, this secondary filter may consist of other tests besides
            intersection, such as testing other kinds of spatial relationships.
            This implementation does not require specifying the extent of the inserted
            items beforehand.  It will automatically expand to accomodate any extent
            of dataset.
            </para>
            <para>
            This data structure is also known as an <c>MX-CIF quadtree</c>
            following the usage of Samet and others.
            </para>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Index.Quadtree.Quadtree`2._minExtent">
            <summary>
            minExtent is the minimum envelope extent of all items
            inserted into the tree so far. It is used as a heuristic value
            to construct non-zero envelopes for features with zero X and/or Y extent.
            Start with a non-zero extent, in case the first feature inserted has
            a zero extent in both directions.  This value may be non-optimal, but
            only one feature will be inserted with this value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`2.EnsureExtent(GeoAPI.Geometries.IGeometryFactory{`0},GeoAPI.Geometries.IExtents{`0},System.Double)">
            <summary>
            Ensure that the extents for the inserted item is non-zero.
            Use <paramref name="minExtent"/> to pad the envelope, if necessary.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Quadtree`2.Remove(GeoAPI.Geometries.IExtents{`0},`1)">
            <summary> 
            Removes a single item from the tree.
            </summary>
            <param name="itemExtents">The <see cref="T:GeoAPI.Geometries.IExtents`1"/> of the item to remove.</param>
            <param name="item">The item to remove.</param>
            <returns><see langword="true"/> if the item was found.</returns>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Quadtree`2.Depth">
            <summary> 
            Returns the number of levels in the tree.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Quadtree.Quadtree`2.Count">
            <summary> 
            Returns the number of items in the tree.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains`1">
            <summary>
             <see cref="M:GeoAPI.Geometries.ISpatialRelation`1.Contains(GeoAPI.Geometries.IGeometry{`0})"/> operation for <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains`1.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0})">
            <summary>
             Creates an instance of this operation.
            </summary>
            <param name="prepPoly">the PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains`1.Contains(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Computes the <see cref="M:GeoAPI.Geometries.ISpatialRelation`1.Contains(GeoAPI.Geometries.IGeometry{`0})"/> predicate between a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1"/>
             and a <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="prep">the prepared polygon</param>
            <param name="geom"> a test geometry</param>
            <returns>true if the polygon contains the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains`1.Contains(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Tests whether this PreparedPolygon <see cref="M:GeoAPI.Geometries.ISpatialRelation`1.Contains(GeoAPI.Geometries.IGeometry{`0})"/> a given geometry.
            </summary>
            <param name="geom">the test geometry</param>
            <returns>true if the test geometry is contained</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonContains`1.FullTopologicalPredicate(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Computes the full topological <see cref="M:GeoAPI.Geometries.ISpatialRelation`1.Contains(GeoAPI.Geometries.IGeometry{`0})"/> predicate.
             Used when short-circuit tests are not conclusive.
            </summary>
            <param name="geom">the test geometry</param>
            <returns>true if the test geometry is contained</returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1">
            <summary>
            A base class for <see cref="T:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1"/> subclasses.
            Contains default implementations for methods, which simply delegate
            to the equivalent <see cref="T:GeoAPI.Geometries.IGeometry`1"/> methods.
            This class may be used as a "no-op" class for Geometry types
            which do not have a corresponding <see cref="T:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1"/> implementation.
            
            @author Martin Davis
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Contains(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether the base <see cref="T:GeoAPI.Geometries.IGeometry`1"/> contains a given geometry
            </summary>
            <param name="geometry"></param>
            <returns><value>True</value> if this geometry conatains given geometry</returns>
            <seealso cref="M:GeoAPI.Geometries.ISpatialRelation.Contains(GeoAPI.Geometries.IGeometry)"/>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.ContainsProperly(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether the base <see cref="T:GeoAPI.Geometries.IGeometry`1"/> contains a given geometry
            The <code>ContainsProperty</code> predicate has the following equivalent definition:
            <list type="Bullet">
            <item>Every Point of the other geometry is a point of this geometry's interior</item>
            <item>The DE-9IM Intersection Matrix for the two geometries matches <code>[T**FF*FF*]</code></item>
            </list>
            The advantage to using this predicate is that it can be computed efficiently, with no
            need to compute topology at individual points.
            An example use case for this predicate is computing the intersections
            of a set of geometries with a large polygonal geometry.  
            Since <code>intersection"</code> is a fairly slow operation, it can be more efficient
            to use <code>ContainsProperly</code> to filter out test geometries which lie
            wholly inside the area.  In these cases the intersection 
            known a priori to be simply the original test geometry. 
            </summary>
            <param name="geometry"></param>
            <returns><value>True</value> if this geometry property conatains given geometry</returns>
            <seealso cref="M:GeoAPI.Geometries.ISpatialRelation.Contains(GeoAPI.Geometries.IGeometry)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.CoveredBy(GeoAPI.Geometries.IGeometry{`0})" -->
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Covers(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether the base <see cref="T:GeoAPI.Geometries.IGeometry`1"/> covers a given geometry.
            <param name="geom">The Geometry to test</param>
            <returns><value>True</value> if this Geometry covers the given Geometry</returns>
            <seealso cref="M:GeoAPI.Geometries.ISpatialRelation`1.Covers(GeoAPI.Geometries.IGeometry{`0})"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Crosses(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether the base <see cref="T:GeoAPI.Geometries.IGeometry`1"/> crosses a given geometry.
            <param name="geom"> the Geometry to test</param>
            <returns><value>True</value> if this Geometry crosses the given Geometry</returns>
            <seealso cref="M:GeoAPI.Geometries.ISpatialRelation`1.Crosses(GeoAPI.Geometries.IGeometry{`0})"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Disjoint(GeoAPI.Geometries.IGeometry{`0})" -->
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Intersects(GeoAPI.Geometries.IGeometry{`0})" -->
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Overlaps(GeoAPI.Geometries.IGeometry{`0})" -->
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Touches(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether the base <see cref="T:GeoAPI.Geometries.IGeometry`1"/> touches a given geometry.
            <param name="geom">The Geometry to test</param>
            <returns><value>True</value> if this Geometry touches the given Geometry</returns>
            <seealso cref="M:GeoAPI.Geometries.ISpatialRelation`1.Touches(GeoAPI.Geometries.IGeometry{`0})"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Within(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether the base <see cref="T:GeoAPI.Geometries.IGeometry`1"/> is within a given geometry.
            <param name="geom">The Geometry to test</param>
            <returns><value>True</value> if this Geometry is within the given Geometry</returns> 
            <seealso cref="M:GeoAPI.Geometries.ISpatialRelation`1.Within(GeoAPI.Geometries.IGeometry{`0})"/>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Prepared.IPreparedGeometry`1.Geometry">
            <summary>
            Gets the original <see cref="T:GeoAPI.Geometries.IGeometry`1"/> which has been prepared
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            constructs an instance of this class
            </summary>
            <param name="geom"> geometry to be prepared</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.EnvelopeCovers(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Determines whether the envelope of 
            this geometry covers the Geometry g.
            </summary>
            <param name="g"> a Geometry</param>
            <returns><value>True</value> if g is contained in this envelopes</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.Contains(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.ContainsProperly(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.CoveredBy(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.Covers(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.Crosses(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.Disjoint(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Standard implementation for all geometries.
            Supports {@link GeometryCollection}s as input.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.Intersects(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.Overlaps(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.Touches(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.Within(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Default implementation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.IsAnyTargetComponentInTest(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether any representative of the target geometry 
            intersects the test geometry.
            This is useful in A/A, A/L, A/P, L/P, and P/P cases.
            </summary>
            <param name="testGeom"> The test geometry</param>
            <returns><value>True</value> if any component intersects the areal test geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.EnvelopesIntersect(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Determines whether a Geometry g interacts with 
            this geometry by testing the geometry envelopes.
            </summary>
            <param name="g"> a Geometry</param>
            <returns><value>True</value> if the envelopes intersect</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.ToString">
            <summary>
            
            </summary>
            <returns>WKT representation of base geometry</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.Prepared.BasicPreparedGeometry`1.RepresentativePoints">
            <summary>
            Gets the list of representative points for this geometry.
            One vertex is included for every component of the geometry
            (i.e. including one for every ring of polygonal geometries) 
            </summary>
        </member>
        <member name="T:NetTopologySuite.Precision.CommonBits">
            <summary> 
            Determines the maximum number of common most-significant
            bits in the significand of one or numbers.
            Can be used to compute the Double-precision number which
            is represented by the common bits.
            If there are no common bits, the number computed is 0.0.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.SignExpBits(System.Int64)">
            <summary>
            Computes the bit pattern for the sign and exponent of a
            double-precision number.
            </summary>
            <returns>The bit pattern for the sign and exponent.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.CommonMostSignificantSignificandBitsCount(System.Int64,System.Int64)">
            <summary>
            This computes the number of common most-significant bits in the significand
            of two double-precision numbers.
            It does not count the hidden bit, which is always 1.
            It does not determine whether the numbers have the same exponent - if they do
            not, the value computed by this function is meaningless.
            </summary>
            <returns>The number of common most-significant significand bits.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.ZeroLowerBits(System.Int64,System.Int32)">
            <summary>
            Zeroes the lower n bits of a bitstring.
            </summary>
            <param name="bits">The bitstring to alter.</param>
            <param name="bitCount">the number of bits to zero.</param>
            <returns>The zeroed bitstring.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.GetBit(System.Int64,System.Int32)">
            <summary>
            Extracts the i'th bit of a bitstring.
            </summary>
            <param name="bits">The bitstring to extract from.</param>
            <param name="i">The bit to extract.</param>
            <returns>The value of the extracted bit.</returns>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.Add(System.Double)">
            <summary>
             Adds a <see langword="Double"/>.
            </summary>
            <param name="num">number to add</param>
        </member>
        <member name="M:NetTopologySuite.Precision.CommonBits.ToString(System.Int64)">
            <summary>
            A representation of the Double bits formatted for easy readability.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Precision.CommonBits.Common">
            <summary>
            Common as <see langword="Double"/>.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder`1">
            <summary>
             Computes the Euclidean distance (L2 metric) from a Point to a Geometry.
             Also computes two points which are separated by the distance.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder`1.ComputeDistance(GeoAPI.Coordinates.ICoordinateFactory{`0},GeoAPI.Geometries.IGeometry{`0},`0,NetTopologySuite.Algorithm.Distance.PointPairDistance{`0})">
            <summary>
            </summary>
            <param name="coordFact"></param>
            <param name="geom"></param>
            <param name="pt"></param>
            <param name="ptDist"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder`1.ComputeDistance(GeoAPI.Coordinates.ICoordinateFactory{`0},GeoAPI.Geometries.ILineString{`0},`0,NetTopologySuite.Algorithm.Distance.PointPairDistance{`0})">
            <summary>
            </summary>
            <param name="coordFact"></param>
            <param name="line"></param>
            <param name="pt"></param>
            <param name="ptDist"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder`1.ComputeDistance(GeoAPI.Coordinates.ICoordinateFactory{`0},NetTopologySuite.Geometries.LineSegment{`0},`0,NetTopologySuite.Algorithm.Distance.PointPairDistance{`0})">
            <summary>
             Computes the 
            </summary>
            <param name="coordFact">factory to create new coordinates</param>
            <param name="segment"></param>
            <param name="pt"></param>
            <param name="ptDist"><see cref="T:NetTopologySuite.Algorithm.Distance.PointPairDistance`1"/> to update</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.DistanceToPointFinder`1.ComputeDistance(GeoAPI.Coordinates.ICoordinateFactory{`0},GeoAPI.Geometries.IPolygon{`0},`0,NetTopologySuite.Algorithm.Distance.PointPairDistance{`0})">
            <summary>
            </summary>
            <param name="coordFact"></param>
            <param name="poly"></param>
            <param name="pt"></param>
            <param name="ptDist"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList_110`1">
            <summary>
             A list of the vertices in a constructed offset curve. Automatically removes close adjacent vertices.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList_110`1._minimimVertexDistance">
            <summary>
             The distance below which two adjacent points on the curve 
             are considered to be coincident.
             This is chosen to be a small fraction of the offset distance.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList_110`1.IsDuplicate(`0)">
            Tests whether the given point duplicates the previous
            point in the list (up to tolerance)
            
            @param pt
            @return true if the point duplicates the previous point
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveVertexList_110`1.CloseRing">
            <summary>
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.BasicSegmentString`1">
            <summary>
             Represents a list of contiguous line segments,
             and supports noding the segments.
             The line segments are represented by an array of {@link Coordinate}s.
             Intended to optimize the noding of contiguous segments by
             reducing the number of allocated objects.
             SegmentStrings can carry a context object, which is useful
             for preserving topological or parentage information.
             All noded substrings are initialized with the same context object.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.BasicSegmentString`1.#ctor(GeoAPI.Coordinates.ICoordinateSequence{`0},System.Object)">
            <summary>
             Creates a new segment string from a list of vertices.
            </summary>
            <param name="pts">the vertices of the segment string</param>
            <param name="data">the user-defined data of this segment string (may be null)</param>
        </member>
        <member name="M:NetTopologySuite.Noding.BasicSegmentString`1.GetSegmentOctant(System.Int32)">
            <summary>
             Gets the octant of the segment starting at vertex <code>index</code>
            </summary>
            <param name="index">the index of the vertex starting the segment. Must not be the last index in the vertex list</param>
            <returns>octant of the segment at the vertex</returns>
        </member>
        <member name="P:NetTopologySuite.Noding.BasicSegmentString`1.Context">
            <summary>Gets the user-defined data for this segment string.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.NonRobustLineIntersector`1">
            <summary> 
            A non-robust version of <see cref="T:NetTopologySuite.Algorithm.LineIntersector`1"/>.
            </summary>   
            <typeparam name="TCoordinate">The coordinate type to use.</typeparam>
        </member>
        <member name="M:NetTopologySuite.Algorithm.NonRobustLineIntersector`1.IsSameSignAndNonZero(System.Double,System.Double)">
            <summary>
            Checks two numbers to determine if they have the same sign and are non-zero.
            </summary>
            <param name="a">First number.</param>
            <param name="b">Second number.</param>
            <returns> 
            <see langword="true"/> if both numbers are positive or if both numbers are negative, 
            <see langword="false" /> if both numbers are zero.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.NonRobustLineIntersector`1.rParameter(GeoAPI.DataStructures.Pair{`0},`0)">
            <summary> 
            RParameter computes the parameter for the point p
            in the parameterized equation
            of the line from p1 to p2.
            This is equal to the 'distance' of p along p1-p2.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator`1">
            <summary>
             Simple Point in Area Locator
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Constructs an instance of this class
            </summary>
            <param name="geom">an areal geometry</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator`1.Locate(`0,GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Determines the <see cref="T:GeoAPI.Geometries.Locations"/> of a point in an areal <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="p">the point to test</param>
            <param name="geom">the areal geometry to test</param>
            <returns>the Location of the point in the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator`1.ContainsPointInPolygon(`0,GeoAPI.Geometries.IPolygon{`0})">
            <summary>
            Determines whether a point lies in a Polygon.
            </summary>
            <param name="p">the point to test</param>
            <param name="poly">a polygon</param>
            <returns>true if the point lies inside the polygon</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.SimplePointInAreaLocator`1.IsPointInRing(`0,GeoAPI.Geometries.ILinearRing{`0})">
            <summary>
            Determines whether a point lies in a LinearRing, using the ring envelope to short-circuit if possible.
            </summary>
            <param name="p">the point to test</param>
            <param name="ring">a linear ring</param>
            <returns>true if the point lies inside the ring</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.VoronoiDiagramBuilder`1">
            <summary>
             A utility class which creates Voronoi Diagrams
             from collections of points.
             The diagram is returned as a {@link GeometryCollection} of {@link Polygon}s,
             clipped to the larger of a supplied envelope or to an envelope determined
             by the input sites.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
             Creates a new Voronoi diagram builder.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder`1.SetSites(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Sets the sites (point or vertices) which will be diagrammed.
             All vertices of the given geometry will be used as sites.
            </summary>
            <param name="geom">the geometry from which the sites will be extracted.</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder`1.SetSites(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary>Sets the sites (point or vertices) which will be diagrammed from a <see cref="T:GeoAPI.Coordinates.ICoordinateSequence`1"/>.
            </summary>
            <param name="coords">the sequence</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder`1.GetSubdivision">
            <summary>
             Gets the <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/> which models the computed diagram.
            </summary>
            <returns>the subdivision containing the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.VoronoiDiagramBuilder`1.GetDiagram">
            <summary>
             Gets the faces of the computed diagram as a <see cref="T:GeoAPI.Geometries.IGeometryCollection`1"/> of <see cref="T:GeoAPI.Geometries.IPolygon`1"/>s, clipped as specified.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.VoronoiDiagramBuilder`1.ClipExtents">
            <summary>
             Gets/sets the envelope to clip the diagram to.
             The diagram will be clipped to the larger
             of this envelope or an envelope surrounding the sites.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.VoronoiDiagramBuilder`1.Tolerance">
            <summary>
             Gets/sets the snapping tolerance which will be used
             to improved the robustness of the triangulation computation.
             A tolerance of 0.0 specifies that no snapping will take place.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper`1" -->
        <member name="M:NetTopologySuite.Triangulate.VertexTaggedGeometryDataMapper`1.TransferData(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Input is assumed to be a multiGeometry in which every component has its userData
             set to be a Coordinate which is the key to the output data.
             The Coordinate is used to determine the output data object to be written back 
             into the component. 
            </summary>
            <param name="targetGeom"></param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.LocateFailureException`1">
            <summary>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NetTopologySuite.Triangulate.MidpointSplitPointFinder`1" -->
        <member name="T:NetTopologySuite.Triangulate.IConstraintSplitPointFinder`1">
            <summary>
             An interface for strategies for determining the location of split points on constraint segments.
             The location of split points has a large effect on the performance and robustness of enforcing a
             constrained Delaunay triangulation. Poorly chosen split points can cause repeated splitting,
             especially at narrow constraint angles, since the split point will end up encroaching on the
             segment containing the original encroaching point. With detailed knowledge of the geometry of the
             constraints, it is sometimes possible to choose better locations for splitting.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.IConstraintSplitPointFinder`1.FindSplitPoint(NetTopologySuite.Triangulate.Segment{`0},`0)">
            <summary>
             Finds a point at which to split an encroached segment to allow the original segment to appear 
             as edges in a constrained Delaunay triangulation.
            </summary>
            <param name="seg">the encroached segment</param>
            <param name="encroachPt">the encroaching point</param>
            <returns>the point at which to split the encroached segment</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.MidpointSplitPointFinder`1.#ctor(GeoAPI.Coordinates.ICoordinateFactory{`0})">
            <summary>
             Creates an instance of this class
            </summary>
            <param name="coordinateFactory">the factory to create new MidpointSplitPoints</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.MidpointSplitPointFinder`1.NetTopologySuite#Triangulate#IConstraintSplitPointFinder{TCoordinate}#FindSplitPoint(NetTopologySuite.Triangulate.Segment{`0},`0)">
            <summary>Gets the midpoint of the split segment
            </summary>
            <param name="seg">the encroached segment</param>
            <param name="encroachPt">the encroaching point</param>
            <returns>the point at which to split the encroached segment</returns>
        </member>
        <member name="T:NetTopologySuite.Simplify.TaggedLineStringSimplifier`1">
            <summary>
            Simplifies a TaggedLineString, preserving topology
            (in the sense that no new intersections are introduced).
            Uses the recursive D-P algorithm.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineStringSimplifier`1.isInLineSection(NetTopologySuite.Simplify.TaggedLineString{`0},System.Int32[],NetTopologySuite.Simplify.TaggedLineSegment{`0})">
            <summary>
            Tests whether a segment is in a section of a TaggedLineString-
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.TaggedLineStringSimplifier`1.remove(NetTopologySuite.Simplify.TaggedLineString{`0},System.Int32,System.Int32)">
            <summary>
            Remove the segs in the section of the line.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Simplify.LineSegmentIndex`1">
            <summary>
            An index of <see cref="T:NetTopologySuite.Geometries.LineSegment`1"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.PointGeometryUnion`1.Union(GeoAPI.Geometries.IPuntal{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Computes the union of a <see cref="T:GeoAPI.Geometries.IPoint`1"/> geometry with 
             another arbitrary <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
             Does not copy any component geometries.
            </summary>
            <param name="pointGeom"></param>
            <param name="otherGeom"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.EdgeString`1">
            <summary>
            A sequence of <c>LineMergeDirectedEdge</c>s forming one of the lines that will
            be output by the line-merging process.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.EdgeString`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs an EdgeString with the given factory used to convert this EdgeString
            to a LineString.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.EdgeString`1.Add(NetTopologySuite.Operation.Linemerge.LineMergeDirectedEdge{`0})">
            <summary>
            Adds a directed edge which is known to form part of this line.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.EdgeString`1.ToLineString">
            <summary>
            Converts this EdgeString into a LineString.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SinglePassNoder`1">
            <summary>
            Base class for <see cref="T:NetTopologySuite.Noding.INoder`1"/>s which make a single pass to find intersections.
            This allows using a custom <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/>
            (which for instance may simply identify intersections, rather than insert them).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SinglePassNoder`1.#ctor(NetTopologySuite.Noding.ISegmentIntersector{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SinglePassNoder`1"/> class.
            </summary>
            <param name="segInt">The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> to use.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.SinglePassNoder`1.Node(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Returns a set of fully noded <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            The <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s have the same context as their parent.
            </summary>
            <remarks>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            Some Noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s;
            others may only add some or none at all.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Noding.SinglePassNoder`1.SegmentIntersector">
            <summary>
            Gets/sets the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> to use with this noder.
            A <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/>  will normally add intersection nodes
            to the input segment strings, but it may not - it may
            simply record the presence of intersections.
            However, some <see cref="T:NetTopologySuite.Noding.INoder`1"/>s may require that intersections be added.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentStringDissolver`1">
            <summary>
            Dissolves a noded collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s to produce
            a set of merged linework with unique segments.
            </summary>
            <remarks>
            <para>
            A custom merging strategy can be applied when two identical (up to orientation)
            strings are dissolved together.
            The default merging strategy is simply to discard the merged string.
            </para>
            <para>
            A common use for this class is to merge noded edges
            while preserving topological labeling.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver`1.#ctor(NetTopologySuite.Noding.SegmentStringDissolver{`0}.ISegmentStringMerger)">
            <summary>
            Creates a dissolver with a user-defined merge strategy.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver`1.#ctor">
            <summary>
            Creates a dissolver with the default merging strategy.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver`1.Dissolve(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.NodedSegmentString{`0}})">
            <summary>
            Dissolve all <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s 
            in the input set.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver`1.Dissolve(NetTopologySuite.Noding.NodedSegmentString{`0})">
            <summary>
            Dissolve the given <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>.
            </summary>
            <param name="segString"></param>
        </member>
        <member name="P:NetTopologySuite.Noding.SegmentStringDissolver`1.Dissolved">
            <summary>
            Gets the collection of dissolved (i.e. unique) <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentStringDissolver`1.ISegmentStringMerger.Merge(NetTopologySuite.Noding.NodedSegmentString{`0},NetTopologySuite.Noding.NodedSegmentString{`0},System.Boolean)">
            <summary>
            Updates the context data of a <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>
            when an identical (up to orientation) one is found during dissolving.
            </summary>
            <param name="mergeTarget">The segment string to update.</param>
            <param name="ssToMerge">The segment string being dissolved.</param>
            <param name="isSameOrientation">
            <see langword="true"/> if the strings are in the same direction,
            <c>false</c> if they are opposite.
            </param>
        </member>
        <member name="T:NetTopologySuite.Noding.IntersectionFinderAdder`1">
            <summary>
            Finds proper and interior intersections in a set of 
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s,
            and adds them as nodes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionFinderAdder`1.#ctor(NetTopologySuite.Algorithm.LineIntersector{`0})">
            <summary>
            Creates an intersection finder which finds all proper intersections.
            </summary>
            <param name="li">The <see cref="T:NetTopologySuite.Algorithm.LineIntersector`1"/> to use.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionFinderAdder`1.ProcessIntersections(NetTopologySuite.Noding.ISegmentString{`0},System.Int32,NetTopologySuite.Noding.ISegmentString{`0},System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> class to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s 
            being intersected.
            </summary>
            <remarks>
            Note that some clients (such as <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain`1"/>s) 
            may optimize away this call for segment pairs which they have determined 
            do not intersect (e.g. by an disjoint envelope test).
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Sweepline.SweepLineEvent.CompareTo(NetTopologySuite.Index.Sweepline.SweepLineEvent)">
            <summary>
            Compares two <see cref="T:NetTopologySuite.Index.Sweepline.SweepLineEvent"/>s to sort them according to 
            coordinate value and <see cref="T:NetTopologySuite.Index.Sweepline.SweepLineEventType"/>.
            </summary>
            <remarks>
            ProjectionEvents are ordered first by their x-value, and then by their eventType.
            It is important that Insert events are sorted before Delete events, so that
            items whose Insert and Delete events occur at the same x-value will be
            correctly handled.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Index.Strtree.DynamicSTRtree`2">
            <summary>
            Experimental class which behaves like an STR-Tree before being built and a Dynamic R-Tree for further inserts
            </summary>
            <typeparam name="TCoordinate"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Index.Strtree.DynamicSTRtree`2.Remove(`1)">
            <summary>
            Removes an item from the index.
            </summary>
            <param name="item">The item to remove.</param>
        </member>
        <member name="T:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter`1">
            <summary> 
            Extracts all the 1-dimensional (<see cref="T:NetTopologySuite.Geometries.LineString`1"/>) 
            components from a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.ILineString{`0}})">
            <summary> 
            Constructs a LineExtracterFilter with a list in which to store LineStrings found.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter`1.GetLines(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Extracts the linear components from a single point.
            If more than one point is to be processed, it is more
            efficient to create a single <see cref="T:NetTopologySuite.Geometries.Utilities.LinearComponentExtracter`1"/> 
            instance and pass it to multiple geometries.
            </summary>
            <param name="geom">The point from which to extract linear components.</param>
            <returns>The list of linear components.</returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.MonotoneChainEdge`1">
            <summary> 
            <see cref="T:NetTopologySuite.GeometriesGraph.Index.MonotoneChain`1"/>s are a way of 
            partitioning the segments of an edge to allow for fast 
            searching of intersections.
            </summary>
            <remarks>
            Monotone chains have the following properties:
            <list type="bullet">
            <item>
            <description>
            the segments within a monotone chain will never intersect each other, and
            </description>
            </item>
            <item>
            <description>
            the envelope of any contiguous subset of the segments in a monotone chain
            is simply the envelope of the endpoints of the subset.
            </description>
            </item>
            </list>
            <para>
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            </para>
            <para>
            Property 2 allows binary search to be used to find the intersection points 
            of two monotone chains.
            </para>
            <para>
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            </para>
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects`1">
            <summary>
             <see cref="M:GeoAPI.Geometries.ISpatialRelation`1.Intersects(GeoAPI.Geometries.IGeometry{`0})"/> operation for <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects`1.#ctor(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0})">
            <summary>
             Creates an instance of this operation.
            </summary>
            <param name="prepPoly">the PreparedPolygon to evaluate</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects`1.Intersects(NetTopologySuite.Geometries.Prepared.PreparedPolygon{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Computes the intersects predicate between a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1"/>
             and a <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="prep">the prepared polygon</param>
            <param name="geom">a test geometry</param>
            <returns>true if the polygon intersects the geometry</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygonIntersects`1.Intersects(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Tests whether this PreparedPolygon intersects a given geometry.
            </summary>
            <param name="geom">the test geometry</param>
            <returns>true if the test geometry intersects</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.#ctor">
            <summary>
             Constructs a new list without any coordinates
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Constructs a new list from an array of Coordinates, allowing repeated points.
             (I.e. this constructor produces a {@link CoordinateList} with exactly the same set of points
             as the input array.)
            </summary>
            <param name="coord">the initial coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
             Constructs a new list from an array of Coordinates, allowing caller to specify if repeated points are to be removed.
            </summary>
            <param name="coords">the array of coordinates to load into the list</param>
            <param name="allowRepeated">if <see langword="false"/>, repeated points are removed</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.AddRange(System.Collections.Generic.IEnumerable{`0},System.Boolean,System.Boolean)">
            <summary>
             Add an enumeration of coordinates
            </summary>
            <param name="coords">the coordinates</param>
            <param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
            <param name="direction">if false, the array is added in reverse order</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.AddRange(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
             Add an enumeration of coordinates
            </summary>
            <param name="coords">The coordinates</param>
            <param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.Add(System.Object,System.Boolean)">
            <summary>
             Add a coordinate
            </summary>
            <param name="obj">the coordinate to add</param>
            <param name="allowRepeated">if set to <see langword="false"/>, repeated coordinates are collapsed</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.Add(`0,System.Boolean)">
            <summary>
             Adds a coordinate to the end of the list.
            </summary>
            <param name="coord">the coordinate</param>
            <param name="allowRepeated">if set to <see langword="false"/>, repeated coordinates are collapsed</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.Insert(System.Int32,`0,System.Boolean)">
            <summary>
             Inserts the specified coordinate at the specified position in this list.
            </summary>
            <param name="i">the position at which to insert</param>
            <param name="coord"></param>
            <param name="allowRepeated">if set to false, repeated coordinates are collapsed</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.AddAll(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
             Add an array of coordinates
            </summary>
            <param name="coll">the coordinates</param>
            <param name="allowRepeated">if set to <see langword="false"/>, repeated coordinates are collapsed</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.CloseRing">
            <summary>
             Ensure this coordList is a ring, by adding the start point if necessary
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.ToCoordinateSequence(GeoAPI.Coordinates.ICoordinateSequenceFactory{`0})">
            Returns the Coordinates in this collection.
            
             @return the coordinates
            <summary>
             Returns the Coordinates in this collection as a <see cref="T:GeoAPI.Coordinates.ICoordinateSequenceFactory`1"/>.
            </summary>
            <param name="factory">factory to create the sequence</param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.CoordinateList`1.Clone">
            <summary>
             Returns a deep copy of this <tt>CoordinateList</tt> instance.
            </summary>
            <returns>clone of this <tt>CoordinateList</tt> instance</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator`1" -->
        <member name="F:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator`1.MaxEnvDiffFrac">
            Maximum allowable fraction of buffer _distance the 
            actual _distance can differ by.
            1% sometimes causes an error - 1.2% should be safe.
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator`1.IsValid(GeoAPI.Geometries.IGeometry{`0},System.Double,GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            </summary>
            <param name="g"></param>
            <param name="distance"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator`1.IsValidMsg(GeoAPI.Geometries.IGeometry{`0},System.Double,GeoAPI.Geometries.IGeometry{`0})">
            Checks whether the geometry buffer is valid, 
            and returns an error message if not.
            
            @param g
            @param _distance
            @param _result
            @return an appropriate error message
            @return null if the buffer is valid
            <summary>
            </summary>
            <param name="g"></param>
            <param name="distance"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator`1.#ctor(GeoAPI.Geometries.IGeometry{`0},System.Double,GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            </summary>
            <param name="input"></param>
            <param name="distance"></param>
            <param name="result"></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator`1.IsValid">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator`1.ErrorMessage">
            <summary>
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.Validate.BufferResultValidator`1.ErrorLocation">
            <summary>
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.IPointInAreaLocator`1">
            <summary>
             An interface for classes which determine the <see cref="T:GeoAPI.Geometries.Locations"/> of points in an areal <see cref="T:GeoAPI.Geometries.IGeometry`1"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.IPointInAreaLocator`1.Locate(`0)">
            Determines the {@link Location} of a point in an areal {@link Geometry}.
            
            @param p the point to test
            @return the location of the point in the geometry  
        </member>
        <member name="T:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder`1">
            <summary>
             A utility class which creates Conforming Delaunay Trianglulations
             from collections of points and linear constraints, and extract the resulting 
             triangulation edges or triangles as geometries. 
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
             Creates an instance of this class
            </summary>
            <param name="geomFactory"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder`1.SetSites(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Sets the sites (point or vertices) which will be triangulated.
             All vertices of the given geometry will be used as sites.
            </summary>
            <param name="geom">the geometry from which the sites will be extracted.</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder`1.SetConstraints(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Sets the linear constraints to be conformed to.
             All linear components in the input will be used as constraints.
            </summary>
            <param name="constraintLines">the lines to constraint to</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder`1.GetSubdivision">
            <summary>
             Gets the QuadEdgeSubdivision which models the computed triangulation.
            </summary>
            <returns>the subdivision containing the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder`1.GetEdges">
            <summary>
             Gets the edges of the computed triangulation as a <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/>.
            </summary>
            <returns>the edges of the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder`1.GetTriangles">
            <summary>
             Gets the faces of the computed triangulation as a <see cref="T:GeoAPI.Geometries.IMultiPolygon`1"/>.
            </summary>
            <returns>the faces of the triangulation</returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.ConformingDelaunayTriangulationBuilder`1.Tolerance">
            <summary>Sets the snapping tolerance which will be used to improved the robustness of the triangulation computation. A tolerance of 0.0 specifies that no snapping will take place.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.SimpleNestedRingTester`1">
            <summary>
            Tests whether any of a set of <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>s are
            nested inside another ring in the set, using a simple O(n^2)
            comparison.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.MaximalEdgeRing`1">
            <summary>
            A ring of edges which may contain nodes of degree &gt; 2.
            </summary>
            <remarks>
            A <see cref="T:NetTopologySuite.Operation.Overlay.MaximalEdgeRing`1"/> may represent two different spatial entities:
            <list type="bullet">
            <item>
            <description>
            a single polygon possibly containing inversions (if the ring is oriented CW)
            </description>
            </item>
            <item>
            <description>
            a single hole possibly containing exversions (if the ring is oriented CCW)    
            </description>
            </item>
            </list>
            If the <see cref="T:NetTopologySuite.Operation.Overlay.MaximalEdgeRing`1"/> represents a polygon,
            the interior of the polygon is strongly connected.
            These are the form of rings used to define polygons under some spatial data models.
            However, under the OGC SFS model, <see cref="T:NetTopologySuite.Operation.Overlay.MinimalEdgeRing`1"/>s are required.
            A MaximalEdgeRing can be converted to a list of MinimalEdgeRings using
            <see cref="M:NetTopologySuite.Operation.Overlay.MaximalEdgeRing`1.BuildMinimalRings"/>.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeRing`1">
            <summary>
            A base class for a ring of <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>s of a graph.
            </summary>
            <typeparam name="TCoordinate">The type of the coordinate to use.</typeparam>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing`1.ComputeRing">
            <summary>
            Compute a LinearRing from the point list previously collected.
            Test if the ring is a hole (i.e. if it is CCW) and set the hole flag
            accordingly.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing`1.ComputePoints(NetTopologySuite.GeometriesGraph.DirectedEdge{`0})">
            <summary> 
            Collect all the points from the <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/>s 
            of this ring into a contiguous list.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing`1.ContainsPoint(`0)">
            <summary> 
            This method will cause the ring to be computed.
            It will also check any holes, if they have been assigned.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeRing`1.MergeLabel(NetTopologySuite.GeometriesGraph.Label,System.Int32)">
            <summary> 
            Merge the RHS label from a DirectedEdge into the label for this EdgeRing.
            The DirectedEdge label may be null.  This is acceptable - it results
            from a node which is NOT an intersection node between the Geometries
            (e.g. the end node of a LinearRing).  In this case the DirectedEdge label
            does not contribute any information to the overall labeling, and is simply skipped.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeRing`1.Edges">
            <summary> 
            Returns the list of DirectedEdges that make up this EdgeRing.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.MaximalEdgeRing`1.LinkDirectedEdgesForMinimalEdgeRings">
            <summary> 
            For all nodes in this EdgeRing,
            link the DirectedEdges at the node to form minimalEdgeRings
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferSubgraph`1">
            <summary>
            A connected subset of the graph of
            <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/>s 
            and <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/>s.
            Its edges will generate either
            a single polygon in the complete buffer, with zero or more holes, or
            one or more connected holes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph`1.CompareTo(NetTopologySuite.Operation.Buffer.BufferSubgraph{`0})">
            <summary>
            BufferSubgraphs are compared on the x-value of their rightmost Coordinate.
            This defines a partial ordering on the graphs such that:
            g1 >= g2 - Ring(g2) does not contain Ring(g1)
            where Polygon(g) is the buffer polygon that is built from g.
            This relationship is used to sort the BufferSubgraphs so that shells are guaranteed to
            be built before holes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph`1.Create(NetTopologySuite.GeometriesGraph.Node{`0})">
            <summary>
            Creates the subgraph consisting of all edges reachable from this node.
            Finds the edges in the graph and the rightmost coordinate.
            </summary>
            <param name="node">A node to start the graph traversal from.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph`1.FindResultEdges">
            <summary>
            Find all edges whose depths indicates that they are in the result area(s).
            Since we want polygon shells to be
            oriented CW, choose dirEdges with the interior of the result on the RHS.
            Mark them as being in the result.
            Interior Area edges are the result of dimensional collapses.
            They do not form part of the result area boundary.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph`1.addReachable(NetTopologySuite.GeometriesGraph.Node{`0})">
            <summary>
            Adds all nodes and edges reachable from this node to the subgraph.
            Uses an explicit stack to avoid a large depth of recursion.
            </summary>
            <param name="startNode">A node known to be in the subgraph.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph`1.add(NetTopologySuite.GeometriesGraph.Node{`0},System.Collections.Generic.Stack{NetTopologySuite.GeometriesGraph.Node{`0}})">
            <summary>
            Adds the argument node and all its out edges to the subgraph
            </summary>
            <param name="node">The node to add.</param>
            <param name="nodeStack">The current set of nodes being traversed.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferSubgraph`1.computeDepths(NetTopologySuite.GeometriesGraph.DirectedEdge{`0})">
            <summary>
            Compute depths for all dirEdges via breadth-first traversal of nodes in graph.
            </summary>
            <param name="startEdge">Edge to start processing with.</param>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferSubgraph`1.RightMostCoordinate">
            <summary>
            Gets the rightmost coordinate in the edges of the subgraph.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferBuilder`1">
            <summary> 
            Builds the buffer point for a given input point and precision model.
            </summary>
            <typeparam name="TCoordinate">The type of coordinate.</typeparam>
            <remarks>
            Allows setting the level of approximation for circular arcs,
            and the precision model in which to carry out the computation.
            When computing buffers in floating point Double-precision
            it can happen that the process of iterated noding can fail to converge (terminate).
            In this case a <see cref="T:NetTopologySuite.Geometries.TopologyException"/> will be thrown.
            Retrying the computation in a fixed precision
            can produce more robust results.    
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a new <see cref="T:NetTopologySuite.Operation.Buffer.BufferBuilder`1"/>
            with the given <paramref name="geoFactory"/>.
            </summary>
            <param name="geoFactory">
            The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> to use 
            to construct geometries.
            </param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double)">
            <summary>
            Generates a new <see cref="T:GeoAPI.Geometries.IGeometry`1"/>
            which is the buffer of the given geometry, <paramref name="g"/>.
            </summary>
            <param name="g">The input geometry to compute the buffer for.</param>
            <param name="distance">
            The distance from the input geometry's border at which 
            to construct the new geometry.
            </param>
            <returns>
            A newly constructed geometry whose border is <paramref name="distance"/>
            from the input geometry's border.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder`1.InsertEdge(NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            Inserted edges are checked to see if an identical edge already exists.
            If so, the edge is not inserted, but its label is merged
            with the existing edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder`1.buildSubgraphs(System.Collections.Generic.IEnumerable{NetTopologySuite.Operation.Buffer.BufferSubgraph{`0}},NetTopologySuite.Operation.Overlay.PolygonBuilder{`0})">
            <summary>
            Completes the building of the input subgraphs by depth-labeling them,
            and adds them to the <see cref="T:NetTopologySuite.Operation.Overlay.PolygonBuilder`1"/>.
            The subgraph list must be sorted in rightmost-coordinate order.
            </summary>
            <param name="subgraphList">The subgraphs to build.</param>
            <param name="polyBuilder">The PolygonBuilder which will build the final polygons.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferBuilder`1.depthDelta(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
            Compute the change in depth as an edge is crossed from R to L.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder`1.QuadrantSegments">
            <summary>
            Gets or sets the number of segments used to approximate a angle fillet.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder`1.WorkingPrecisionModel">
            <summary>
            Gets or sets the precision model to use during the curve 
            computation and noding, if it is different to the precision model 
            of the Geometry.
            If the precision model is less than the precision of the Geometry 
            precision model, the Geometry must have previously been rounded to 
            that precision.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder`1.EndCapStyle">
            <summary>
            Gets or sets the style of the buffer's end.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Buffer.BufferBuilder`1.Noder">
            <summary>
            Gets or sets the <see cref="T:NetTopologySuite.Noding.INoder`1"/>
            used to create nodes for intersections in the buffer graph.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SimpleNoder`1">
            <summary>
            Nodes a set of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s by
            performing a brute-force comparison of every segment to every other one.
            This has n^2 performance, so is too slow for use on large numbers of segments.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleNoder`1.#ctor(NetTopologySuite.Noding.ISegmentIntersector{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SimpleNoder`1"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SimpleNoder`1.Node(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s
            and returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of fully noded 
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            The <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s have the same context as their parent.
            Some noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s;
            others may only add some or none at all.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.AbstractNodeKey`2">
            <summary> 
            A key is a unique identifier for a node in regular region indexes.
            It contains a lower-left point and a level number. The level number
            is the log with the base of the scale of the decomposition.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.AbstractNodeKey`2.ComputeLevel(`0)">
            <summary>
            Return a square envelope containing the argument envelope,
            whose extent is a power of two and which is based at a power of 2.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction`1">
            <summary> 
            The action for the internal iterator for performing
            overlap queries on a MonotoneChain.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction`1.Overlap(NetTopologySuite.Index.Chain.MonotoneChain{`0},System.Int32,NetTopologySuite.Index.Chain.MonotoneChain{`0},System.Int32)">
            <summary>
            This function can be overridden if the original chains are needed.
            </summary>
            <param name="start1">
            The index of the start of the overlapping segment from mc1.
            </param>
            <param name="start2">
            The index of the start of the overlapping segment from mc2.
            </param>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction`1.Overlap(NetTopologySuite.Geometries.LineSegment{`0},NetTopologySuite.Geometries.LineSegment{`0})">
            <summary> 
            This is a convenience function which can be overridden to obtain the actual
            line segments which overlap.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction`1.SearchExtents1">
            <summary>
            Gets one of the <see cref="T:GeoAPI.Geometries.IExtents`1"/>s 
            used during the MonotoneChain search process.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChainOverlapAction`1.SearchExtents2">
            <summary>
            Gets the other <see cref="T:GeoAPI.Geometries.IExtents`1"/>
            used during the MonotoneChain search process.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Chain.MonotoneChain`1">
            <summary> 
            A <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain`1"/> is a way of partitioning 
            the segments of a linestring to allow for fast searching of intersections.
            </summary>
            <remarks>
            Monotone chains have the following properties:
            <list type="bullet">
            <item>
            <description>
            the segments within a monotone chain will never intersect each other, and
            </description>
            </item>
            <item>
            <description>
            the envelope of any contiguous subset of the segments in a monotone chain
            is simply the envelope of the endpoints of the subset.
            </description>
            </item>
            </list>
            <para>
            Property 1 means that there is no need to test pairs of segments from within
            the same monotone chain for intersection.
            </para>
            <para>
            Property 2 allows binary search to be used to find the intersection points 
            of two monotone chains.
            </para>
            <para>
            For many types of real-world data, these properties eliminate a large number of
            segment comparisons, producing substantial speed gains.
            </para>
            <para>
            One of the goals of this implementation of MonotoneChains is to be
            as space and time efficient as possible. One design choice that aids this
            is that a MonotoneChain is based on a subset of a list of points.
            This means that new arrays of points (potentially very large) do not
            have to be allocated.
            </para>
            MonotoneChains support the following kinds of queries:
            <list type="table">
            <item>
            <term>Envelope select</term>
            <description>
            Determines all the segments in the chain which
            intersect a given envelope.
            </description>
            </item>
            <item>
            <term>Overlap</term>
            <description>
            Determines all the pairs of segments in two chains whose
            envelopes overlap.
            </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},GeoAPI.Coordinates.ICoordinateSequence{`0},System.Int32,System.Int32,System.Object)">
            <summary>
             Creates an instance of this class
            </summary>
            <param name="geoFactory">Factory to create Extents of chain</param>
            <param name="pts">Points that make up the chain</param>
            <param name="start">Starting point of chain segment</param>
            <param name="end">Endpoint of chain segment</param>
            <param name="context">user-defined information</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:NetTopologySuite.Index.Chain.MonotoneChain`1.Select(GeoAPI.Geometries.IExtents{`0})">
            <summary> 
            Determine all the line segments in the chain whose envelopes intersect
            the <paramref name="searchExtents"/>, and return them.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain`1.Id">
            <summary>
            Useful for opimizing chain comparisions
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain`1.Context">
            <summary>
            User-defined information
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.Chain.MonotoneChain`1.Coordinates">
            <summary>
            Return the subsequence of coordinates forming this chain.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.Root`1">
            <summary> 
            The root node of a single <see cref="T:NetTopologySuite.Index.Bintree.BinTree`1"/>.
            It is centered at the origin, and does not have a defined extent.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Root`1.Insert(`0)">
            <summary> 
            Insert an item into the tree this is the root of.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Root`1.IsSearchMatch(GeoAPI.DataStructures.Interval)">
            <summary>
            The root node matches all searches.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Root`1.insertContained(NetTopologySuite.Index.Bintree.Node{`0},GeoAPI.DataStructures.Interval,`0)">
            <summary> 
            Insert an item which is known to be contained in the tree rooted at
            the given Node.  Lower levels of the tree will be created
            if necessary to hold the item.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Triangle`1">
            <summary> 
            Represents a planar triangle, and provides methods for calculating various
            properties of triangles.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle`1.IsAcute(`0,`0,`0)">
            <summary>
             Tests whether a triangle is acute.
             A triangle is acute iff all interior angles are acute.
             This is a strict test - right triangles will return <tt>false</tt>
             A triangle which is not acute is either right or obtuse.
             Note: this implementation is not robust for angles very close to 90 degrees.
            </summary>
            <param name="a">a vertex of the triangle</param>
            <param name="b">a vertex of the triangle</param>
            <param name="c">a vertex of the triangle</param>
            <returns>true if the triangle is acute</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle`1.PerpendicularBisector(GeoAPI.Coordinates.ICoordinateFactory{`0},`0,`0)">
            **
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Triangle`1.Circumcentre(GeoAPI.Coordinates.ICoordinateFactory{`0},`0,`0,`0)" -->
        <member name="M:NetTopologySuite.Geometries.Triangle`1.Det(System.Double,System.Double,System.Double,System.Double)">
            
            
            
            
            @param m00 the [0,0] entry of the matrix
            @param m01 the [0,1] entry of the matrix
            @param m10 the [1,0] entry of the matrix
            @param m11 the [1,1] entry of the matrix
            @return the determinant
            <summary>
             Computes the determinant of a 2x2 matrix. Uses standard double-precision arithmetic, 
             so is susceptible to round-off error.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle`1.InCentre(GeoAPI.Coordinates.ICoordinateFactory{`0},`0,`0,`0)">
            <summary>
             Computes the incentre of a triangle.
             The <i>inCentre</i> of a triangle is the point which is equidistant
             from the sides of the triangle.
             It is also the point at which the bisectors
             of the triangle's angles meet.
             It is the centre of the triangle's <i>incircle</i>,
             which is the unique circle that is tangent to each of the triangle's three sides.
            </summary>
            <param name="factory"></param>
            <param name="a">a vertx of the triangle</param>
            <param name="b">a vertx of the triangle</param>
            <param name="c">a vertx of the triangle</param>
            <returns>the point which is the incentre of the triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle`1.Centroid(GeoAPI.Coordinates.ICoordinateFactory{`0},`0,`0,`0)">
             Computes the centroid (centre of mass) of a triangle.
             This is also the point at which the triangle's three
             medians intersect (a triangle median is the segment from a vertex of the triangle to the
             midpoint of the opposite side).
             The centroid divides each median in a ratio of 2:1.
             The centroid always lies within the triangle.
            
            
             @param a a vertex of the triangle
             @param b a vertex of the triangle
             @param c a vertex of the triangle
             @return the centroid of the triangle
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle`1.LongestSideLength(`0,`0,`0)">
             Computes the length of the longest side of a triangle
            
             @param a a vertex of the triangle
             @param b a vertex of the triangle
             @param c a vertex of the triangle
             @return the length of the longest side of the triangle
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle`1.AngleBisector(GeoAPI.Coordinates.ICoordinateFactory{`0},`0,`0,`0)">
             Computes the point at which the bisector of the angle ABC
             cuts the segment AC.
            
             @param a a vertex of the triangle
             @param b a vertex of the triangle
             @param c a vertex of the triangle
             @return the angle bisector cut point
        </member>
        <member name="M:NetTopologySuite.Geometries.Triangle`1.Area(`0,`0,`0)">
             Computes the 2D area of a triangle.
             The area value is always non-negative.
            
             @param a a vertex of the triangle
             @param b a vertex of the triangle
             @param c a vertex of the triangle
             @return the area of the triangle
             
             @see signedArea
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Triangle`1.SignedArea(`0,`0,`0)" -->
        <member name="M:NetTopologySuite.Geometries.Triangle`1.Area3D(`0,`0,`0)">
                     * Computes the 3D area of a triangle.
                     * The value computed is alway non-negative.
                     * 
                   * @param a a vertex of the triangle
                   * @param b a vertex of the triangle
                   * @param c a vertex of the triangle
                   * @return the 3D area of the triangle
        </member>
        <member name="P:NetTopologySuite.Geometries.Triangle`1.InCenter">
            <summary>
            The InCenter of a triangle is the point which is equidistant
            from the sides of the triangle.  
            This is also the point at which the bisectors
            of the angles meet.
            </summary>
            <returns>
            The point which is the InCenter of the triangle.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedLineString`1">
            <summary>
             A prepared version for <see cref="T:GeoAPI.Geometries.ILineString`1"/> geometries.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedLineString`1.#ctor(GeoAPI.Geometries.ILineal{`0})">
            <summary>
             Constructs a <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedLineString`1"/>.
            </summary>
            <param name="line"><see cref="T:GeoAPI.Geometries.ILineString`1"/> to prepare</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Prepared.PreparedLineString`1.IntersectionFinder">
            <summary>
            Intersection Finder
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Point`1">
            <summary>
            Basic implementation of <see cref="T:GeoAPI.Geometries.IPoint`1"/>,
            <see cref="T:GeoAPI.Geometries.IPoint2D"/> and <see cref="T:GeoAPI.Geometries.IPoint3D"/>.
            </summary>
            <typeparam name="TCoordinate">Type of coordinate to use.</typeparam>
        </member>
        <member name="M:NetTopologySuite.Geometries.Point`1.#ctor(`0,GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.Point`1"/> with the given coordinate.
            </summary>
            <param name="coordinate">
            Contains the single coordinate on which to base this <see cref="T:NetTopologySuite.Geometries.Point`1"/>,
            or <see langword="null"/> to create the empty point.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.PointM`1.#ctor(`0,System.Double,GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.Point`1"/> with the given coordinate.
            </summary>
            <param name="coordinate">
            Contains the single coordinate on which to base this <see cref="T:NetTopologySuite.Geometries.Point`1"/>,
            or <see langword="null"/> to create the empty point.
            </param>
        </member>
        <member name="T:NetTopologySuite.Algorithm.SimplePointInAreaLocator`1">
            <summary>
            Computes whether a point
            lies in the interior of an area <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <remarks>
            The algorithm used is only guaranteed to return correct results
            for points which are not on the boundary of the Geometry.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.SimplePointInAreaLocator`1.Locate(`0,GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Locate is the main location function.  It handles both single-element
            and multi-element <see cref="T:GeoAPI.Geometries.IGeometry`1"/> instances.
            The algorithm for multi-element geometries is more complex, 
            since it has to take into account the boundary determination rule.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.MultiValentEndPointBoundaryNodeRule">
            <summary>
             A <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> which determines that only
             endpoints with valency greater than 1 are on the boundary.
             This corresponds to the boundary of a <see cref="T:GeoAPI.Geometries.IMultiLineString"/>
             being all the "attached" endpoints, but not
             the "unattached" ones.
            </summary>
            <author>Martin Davis</author>
            <version>1.7</version>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Match.SimilarityMeasureCombiner">
            <summary>
             Provides methods to mathematically combine <see cref="T:NetTopologySuite.Algorithm.Match.ISimilarityMeasure`1"/> values.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.CentroidLine`1">
            <summary> 
            Computes the centroid of a linear point.
            Algorithm:
            Compute the average of the midpoints
            of all line segments weighted by the segment length.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CentroidLine`1.Add(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Adds the linestring(s) defined by a Geometry to the centroid total.
            If the geometry is not linear it does not contribute to the centroid.
            </summary>
            <param name="geom">The geometry to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CentroidLine`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Adds the length defined by a set of coordinates.
            </summary>
            <param name="points">A set of <typeparamref name="TCoordinate"/>s.</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.ITraversalVisitor`1">
            <summary>
             Interface for classes which process triangles visited during travesals of a <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.ITraversalVisitor`1.Visit(NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle{`0},System.Int32,NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle{`0})">
            <summary>
             Visits a triangle during a traversal of a <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/>. An implementation of
             this method may perform processing on the current triangle. It must also decide whether a
             neighbouring triangle should be added to the queue so its neighbours are visited. Often it
             will perform processing on the neighbour triangle as well, in order to mark it as processed
             (visited) and/or to determine if it should be visited. Note that choosing <b>not</b> to
             visit the neighbouring triangle is the terminating condition for many traversal algorithms.
             In particular, if the neighbour triangle has already been visited, it should not be visited
             again.
            </summary>
            <param name="currTri">the current triangle being processed</param>
            <param name="edgeIndex">the index of the edge in the current triangle being traversed</param>
            <param name="neighbTri">a neighbouring triangle next in line to visit</param>
            <returns>true if the neighbour triangle should be visited</returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.ConstraintEnforcementException`1">
            <summary>
             Indicates a failure during constraint enforcement.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="F:NetTopologySuite.Triangulate.ConstraintEnforcementException`1.Coordinate">
            <summary>
            The approximate location of this error.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConstraintEnforcementException`1.#ctor(System.String)">
            <summary>
             Creates a new instance with a given message.
            </summary>
            <param name="msg"> a string</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.ConstraintEnforcementException`1.#ctor(System.String,`0)">
            <summary>
             Creates a new instance with a given message and approximate location.
            </summary>
            <param name="msg">a string</param>
            <param name="pt">the location of the error</param>
        </member>
        <member name="T:NetTopologySuite.Simplify.TaggedLineSegment`1">
            <summary>
            A LineSegment which is tagged with its location in a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            Used to index the segments in a point and recover the segment locations
            from the index.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.NodeMap`1">
            <summary>
            A map of <see cref="T:NetTopologySuite.Planargraph.Node`1"/>s, indexed by the coordinate of the node.
            </summary>   
        </member>
        <member name="M:NetTopologySuite.Planargraph.NodeMap`1.Add(NetTopologySuite.Planargraph.Node{`0})">
            <summary>
            Adds a node to the map, replacing any that is already at that location.
            </summary>
            <param name="n">The <see cref="T:NetTopologySuite.Planargraph.Node`1"/> to add.</param>
            <returns>The added <see cref="T:NetTopologySuite.Planargraph.Node`1"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.NodeMap`1.Remove(`0,NetTopologySuite.Planargraph.Node{`0}@)">
            <summary>
            Removes the <see cref="T:NetTopologySuite.Planargraph.Node`1"/> at the given location, and returns it 
            in <paramref name="removedNode"/> (or sets <paramref name="removedNode"/> to 
            <see langword="null"/> if no <see cref="T:NetTopologySuite.Planargraph.Node`1"/> existed with the given 
            <paramref name="key"/>).
            </summary>
            <param name="key">The key to remove the node at.</param>
            <param name="removedNode">The node which was removed.</param>
            <returns>
            <see langword="true"/> if the node at <paramref name="key"/> was found and 
            removed; <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Planargraph.NodeMap`1.Find(`0)">
            <summary>
            Returns the Node at the given location, or <see langword="null"/> 
            if no <see cref="T:NetTopologySuite.Planargraph.Node`1"/> was there.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.NodeMap`1.Values">
            <summary>
            Returns the Nodes in this NodeMap, sorted in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateNodeGraph`1">
            <summary>
            Implements a simple graph of <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/>s and 
            <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s which is all that is
            required to determine topological relationships between Geometries.
            Also supports building a topological graph of a single Geometry, to
            allow verification of valid topology.    
            It is not necessary to create a fully linked
            PlanarGraph to determine relationships, since it is sufficient
            to know how the Geometries interact locally around the nodes.
            In fact, this is not even feasible, since it is not possible to compute
            exact intersection points, and hence the topology around those nodes
            cannot be computed robustly.
            The only Nodes that are created are for improper intersections;
            that is, nodes which occur at existing vertices of the Geometries.
            Proper intersections (e.g. ones which occur between the interior of line segments)
            have their topology determined implicitly, without creating a Node object
            to represent them.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNodeGraph`1.ComputeIntersectionNodes(NetTopologySuite.GeometriesGraph.GeometryGraph{`0},System.Int32)">
            <summary>
            Insert nodes for all intersections on the edges of a Geometry.
            Label the created nodes the same as the edge label if they do not already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labeled.
            Endpoint nodes will already be labeled from when they were inserted.
            Precondition: edge intersections have been computed.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNodeGraph`1.CopyNodesAndLabels(NetTopologySuite.GeometriesGraph.GeometryGraph{`0},System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.EdgeEndBundleStar`1">
            <summary>
            An ordered list of <see cref="T:NetTopologySuite.Operation.Relate.EdgeEndBundle`1"/>s around a 
            <see cref="T:NetTopologySuite.Operation.Relate.RelateNode`1"/>.
            </summary>
            <remarks>
            They are maintained in CCW order (starting with the positive x-axis) 
            around the node for efficient lookup and topology building.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeEndStar`1">
            <summary>
            An <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEndStar`1"/> is an ordered list of 
            <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/> around a node.
            They are maintained in CCW order (starting with the positive x-axis) 
            around the node for efficient lookup and topology building.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar`1.Insert(NetTopologySuite.GeometriesGraph.EdgeEnd{`0})">
            <summary> 
            Insert a EdgeEnd into this EdgeEndStar.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeEndStar`1.InsertEdgeEnd(NetTopologySuite.GeometriesGraph.EdgeEnd{`0},NetTopologySuite.GeometriesGraph.EdgeEnd{`0})">
            <summary> 
            Insert an EdgeEnd into the map, and clear the <see cref="P:NetTopologySuite.GeometriesGraph.EdgeEndStar`1.Edges"/> cache,
            since the list of edges has now changed.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeEndStar`1.Coordinate">
            <returns>
            Gets the coordinate for the node this star is based at.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundleStar`1.Insert(NetTopologySuite.GeometriesGraph.EdgeEnd{`0})">
            <summary>
            Insert a <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/> in order in the list.
            If there is an existing <see cref="T:NetTopologySuite.Operation.Relate.EdgeEndBundle`1"/> 
            which is parallel, <paramref name="e"/> is added to the bundle.
            Otherwise, a new <see cref="T:NetTopologySuite.Operation.Relate.EdgeEndBundle`1"/>
            is created to contain it.
            </summary>
            <param name="e">
            The <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/> to add to the list.
            </param>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundleStar`1.UpdateIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Update the <see cref="T:GeoAPI.Geometries.IntersectionMatrix"/> with the 
            contribution for the <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s 
            around the node.
            </summary>
            <param name="im">
            The <see cref="T:GeoAPI.Geometries.IntersectionMatrix"/> to update.
            </param>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge`1">
            <summary>
            A <c>DirectedEdge</c> of a <c>PolygonizeGraph</c>, which represents
            an edge of a polygon formed by the graph.
            May be logically deleted from the graph by setting the <c>marked</c> flag.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge`1.#ctor(NetTopologySuite.Planargraph.Node{`0},NetTopologySuite.Planargraph.Node{`0},`0,System.Boolean)">
            <summary>
            Constructs a directed edge connecting the <c>from</c> node to the
            <c>to</c> node.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <param name="directionPt">
            Specifies this DirectedEdge's direction (given by an imaginary
            line from the <c>from</c> node to <c>directionPt</c>).
            </param>
            <param name="edgeDirection">
            Whether this DirectedEdge's direction is the same as or
            opposite to that of the parent Edge (if any).
            </param>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge`1.Label">
            <summary> 
            Returns the identifier attached to this directed edge.
            Attaches an identifier to this directed edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge`1.Next">
            <summary>
            Returns the next directed edge in the EdgeRing that this directed edge is a member of.
            Sets the next directed edge in the EdgeRing that this directed edge is a member of.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge`1.IsInRing">
            <summary>
            Returns the ring of directed edges that this directed edge is
            a member of, or null if the ring has not been set.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Polygonize.PolygonizeDirectedEdge`1.Ring">
            <summary> 
            Gets or sets the ring of directed edges that this directed edge is
            a member of.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.MinimalEdgeRing`1">
            <summary>
            A ring of edges with the property that no node
            has degree greater than 2.  These are the form of rings required
            to represent polygons under the OGC SFS spatial data model.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder`1">
            <summary>
            Creates all the raw offset curves for a buffer of a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            Raw curves need to be noded together and polygonized to form the final buffer area.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder`1.GetCurves">
            <summary>
            Computes the set of raw offset curves for the buffer.
            Each offset curve has an attached {Label} indicating
            its left and right location.
            </summary>
            <returns>
            A set of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s 
            representing the raw buffer curves.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder`1.addCurve(GeoAPI.Coordinates.ICoordinateSequence{`0},GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/> for a coordinate list
            which is a raw offset curve, and adds it to the list of buffer curves.
            </summary>
            <remarks>
            The SegmentString is tagged with a Label giving the topology of the curve.
            The curve may be oriented in either direction.
            If the curve is oriented CW, the locations will be:
            Left: Locations.Exterior.
            Right: Locations.Interior.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder`1.addPoint(GeoAPI.Geometries.IPoint{`0})">
            <summary>
            Add a Point to the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder`1.addPolygonRing(System.Collections.Generic.IEnumerable{`0},System.Double,NetTopologySuite.GeometriesGraph.Positions,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Add an offset curve for a ring.
            The side and left and right topological location arguments
            assume that the ring is oriented CW.
            If the ring is in the opposite orientation,
            the left and right locations must be interchanged and the side flipped.
            </summary>
            <param name="coord">The coordinates of the ring (must not contain repeated points).</param>
            <param name="offsetDistance">The distance at which to create the buffer.</param>
            <param name="side">The side of the ring on which to construct the buffer line.</param>
            <param name="cwLeftLoc">The location on the L side of the ring (if it is CW).</param>
            <param name="cwRightLoc">The location on the R side of the ring (if it is CW).</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder`1.isErodedCompletely(System.Collections.Generic.IEnumerable{`0},System.Double)">
            <summary>
            The ringCoord is assumed to contain no repeated points.
            It may be degenerate (i.e. contain only 1, 2, or 3 points).
            In this case it has no area, and hence has a minimum diameter of 0.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveSetBuilder`1.isTriangleErodedCompletely(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Collections.Generic.IEnumerable{`0},System.Double)">
            <summary>
            Tests whether a triangular ring would be eroded completely by the given
            buffer distance.
            This is a precise test.  It uses the fact that the inner buffer of a
            triangle converges on the inCentre of the triangle (the point
            equidistant from all sides).  If the buffer distance is greater than the
            distance of the inCentre from a side, the triangle will be eroded completely.
            This test is important, since it removes a problematic case where
            the buffer distance is slightly larger than the inCentre distance.
            In this case the triangle buffer curve "inverts" with incorrect topology,
            producing an incorrect hole in the buffer.       
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.RTree.RTreeLeafNode`2">
            <summary>
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Index.RTree.RTreeLeafNode`2.#ctor(GeoAPI.Indexing.IBoundsFactory{`0},`1)">
            <summary>
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.Node`1">
            <summary>
            A node of a <see cref="T:NetTopologySuite.Index.Bintree.BinTree`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.GetNode(GeoAPI.DataStructures.Interval)">
            <summary>
            Returns the subnode containing the envelope.
            Creates the node if it does not already exist.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.Node`1.Find(GeoAPI.DataStructures.Interval)">
            <summary>
            Returns the smallest existing
            node containing the envelope.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.BinTree`1">
            <summary>
            A <see cref="T:NetTopologySuite.Index.Bintree.BinTree`1"/> indexes values along a field of values
            (such as  - the set of real numbers), to decompose the field into 
            nested intervals. This nesting allows searches on a range of values.
            </summary>
            <remarks>
            <para>
            A <see cref="T:NetTopologySuite.Index.Bintree.BinTree`1"/> (or "Binary Interval Tree")
            is a 1-dimensional version of a quadtree. It indexes 1-dimensional 
            intervals (which of course may be the projection of 2-D objects on an axis).
            It supports range searching (where the range may be a single point).
            This implementation does not require specifying the extent of the inserted
            items beforehand.  It will automatically expand to accomodate any extent
            of dataset.
            </para>
            <para>
            This index is different to the Interval Tree of Edelsbrunner
            or the Segment Tree of Bentley.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.BinTree`1.EnsureExtent(GeoAPI.DataStructures.Interval,System.Double)">
            <summary>
            Ensure that the <see cref="T:GeoAPI.DataStructures.Interval"/> for the inserted item has non-zero extents.
            Use the current <paramref name="minExtent"/> to pad it, if necessary.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Bintree.BinTree`1.Query(GeoAPI.DataStructures.Interval)">
            <remarks>
            <paramref name="interval"/> might have a 0 width, representing a point.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.Index.Bintree.BinTree`1.TotalNodeCount">
            <summary>
            Gets the total number of nodes in the tree.
            </summary>
            <returns>The number of nodes in the tree.</returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.QuadrantOp`1">
            <summary> 
            Utility functions for working with quadrants, which are numbered as follows:
            <para>
            1 | 0
            --+--
            2 | 3
            </para>
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp`1.Quadrant(System.Double,System.Double)">
            <summary> 
            Returns the quadrant of a directed line segment (specified as x and y
            displacements, which cannot both be 0).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp`1.Quadrant(`0)">
            <summary> 
            Returns the <see cref="T:NetTopologySuite.GeometriesGraph.Quadrants"/> value of the <paramref name="coordinate"/>.
            </summary>
            <param name="coordinate">The coordinate to compute the quadrant for.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp`1.Quadrant(GeoAPI.DataStructures.Pair{`0})">
            <summary> 
            Returns the quadrant of a directed line segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp`1.Quadrant(`0,`0)">
            <summary> 
            Returns the quadrant of a directed line segment from p0 to p1.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp`1.IsOpposite(NetTopologySuite.GeometriesGraph.Quadrants,NetTopologySuite.GeometriesGraph.Quadrants)">
            <summary>
            Returns true if the quadrants are 1 and 3, or 2 and 4.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp`1.CommonHalfPlane(NetTopologySuite.GeometriesGraph.Quadrants,NetTopologySuite.GeometriesGraph.Quadrants)">
            <summary>
            Returns the right-hand quadrant of the halfplane defined by the two quadrants,
            or -1 if the quadrants are opposite, or the quadrant if they are identical.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp`1.IsInHalfPlane(NetTopologySuite.GeometriesGraph.Quadrants,NetTopologySuite.GeometriesGraph.Quadrants)">
            <summary> 
            Returns whether the given quadrant lies within the given halfplane (specified
            by its right-hand quadrant).
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.QuadrantOp`1.IsNorthern(NetTopologySuite.GeometriesGraph.Quadrants)">
            <summary> 
            Returns true if the given quadrant is <see cref="F:NetTopologySuite.GeometriesGraph.Quadrants.I"/> 
            or <see cref="F:NetTopologySuite.GeometriesGraph.Quadrants.II"/>.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Node`1">
            <summary>
            Represents a node in a <see cref="T:NetTopologySuite.GeometriesGraph.GeometryGraph`1"/>.
            </summary>
            <typeparam name="TCoordinate">The type of coordinate.</typeparam>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.#ctor(`0,NetTopologySuite.GeometriesGraph.EdgeEndStar{`0})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/> instance at the given
            <typeparamref name="TCoordinate"/> and with an 
            <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEndStar`1"/> to maintain an ordered list of
            incident edges.
            </summary>
            <param name="coord">The coordinate which the node models.</param>
            <param name="edges">
            An <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEndStar`1"/> to maintain incident edges.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.IsIncidentEdgeInResult">
            <summary>
             Tests whether any incident edge is flagged as being in the result.
             This test can be used to determine if the node is in the result,
             since if any incident edge is in the result, the node must be in the result as well.
            </summary>
            <returns>true if any indicident edge in the in the result</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.ComputeIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Basic nodes do not compute intersection matrixes.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.Add(NetTopologySuite.GeometriesGraph.EdgeEnd{`0})">
            <summary> 
            Add the edge to the list of edges at this node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.MergeLabel(NetTopologySuite.GeometriesGraph.Node{`0})">
            <summary>
            Merges the given <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/>'s
            <see cref="!:Node&lt;TCoordinate&gt;.Label"/> to this <see cref="T:NetTopologySuite.GeometriesGraph.Label"/>.
            </summary>
            <seealso cref="M:NetTopologySuite.GeometriesGraph.Node`1.MergeLabel(NetTopologySuite.GeometriesGraph.Label)"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.MergeLabel(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
            Merges the given <see cref="T:NetTopologySuite.GeometriesGraph.Label"/>'s locations to this node's label's
            locations.
            </summary>
            <remarks>
            To merge labels for two nodes, the merged location for each 
            <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> is computed.
            The location for the corresponding node <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> 
            is set to the result, as long as the location is non-null.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.SetLabel(System.Int32,GeoAPI.Geometries.Locations)">
            <summary>
            Sets this node's <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> for the given geometry
            (at <paramref name="geometryIndex"/>) to the given location for the 
            'On' position.
            </summary>
            <param name="geometryIndex">
            The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> to set the label location of.
            </param>
            <param name="onLocation">
            The <see cref="T:GeoAPI.Geometries.Locations"/> value to set the 'On' position of the
            given geometry to.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.SetLabelBoundary(System.Int32)">
            <summary> 
            Updates the label of a node to <see cref="F:GeoAPI.Geometries.Locations.Boundary"/>,
            obeying the mod-2 boundary determination rule.
            </summary>
            <seealso cref="T:NetTopologySuite.Algorithm.Mod2BoundaryNodeRule"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Node`1.ComputeMergedLocation(NetTopologySuite.GeometriesGraph.Label,System.Int32)">
            <summary>
            Merges the given <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with this 
            <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/>'s label, choosing the greatest
            <see cref="T:GeoAPI.Geometries.Locations"/> value.
            </summary>
            <remarks>
            The location for a given <paramref name="elementIndex"/> for a node 
            will be one of  { <see cref="F:GeoAPI.Geometries.Locations.None"/>, 
            <see cref="F:GeoAPI.Geometries.Locations.Interior"/>, <see cref="F:GeoAPI.Geometries.Locations.Boundary"/> }.
            A node may be on both the boundary and the interior of a point;
            in this case, the rule is that the node is considered to be in the boundary.
            The merged location is the maximum of the two input values.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Node`1.Edges">
            <summary>
            An <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEndStar`1"/> used to keep an ordered
            list of incident edges on the node.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Label">
            <summary> 
            A <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> indicates the topological relationship of a component
            of a topology graph to a given <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> or pair of 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> instances.
            </summary>
            <remarks>
            <para>
            This class supports labels for relationships to two 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s, which is sufficient for 
            algorithms for binary operations.
            </para>
            <para>
            Topology graphs support the concept of labeling nodes and edges in the graph.
            The label of a node or edge specifies its topological relationship to one or
            more geometries.  (In fact, since NTS operations have only two arguments, labels
            are required for only two geometries).  A label for a node or edge has one or
            two elements, known as <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>s, depending on 
            whether the node or edge occurs in one or both of the input 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s.  <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>s contain 
            attributes of type <see cref="T:GeoAPI.Geometries.Locations"/> which categorize the 
            topological location of the node or edge relative to the parent 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>; that is, whether 
            the node or edge is in the interior, boundary or exterior of the 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </para>
            <para>
            Attributes have a value from the set <c>{Interior, Boundary, Exterior}</c>.  
            In a node each element has a single attribute <c>On</c>. For an edge each element 
            has a triplet of attributes <c>Left, On, Right</c>.
            It is up to the client code to associate the 0 and 1 
            <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>s with specific geometries.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(GeoAPI.Geometries.Locations)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with a single location for 
            both geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary> 
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with the given 
            <see cref="F:NetTopologySuite.GeometriesGraph.Positions.On"/> location 
            for the respective geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with <see cref="F:NetTopologySuite.GeometriesGraph.Positions.On"/>, 
            <see cref="F:NetTopologySuite.GeometriesGraph.Positions.Left"/> and <see cref="F:NetTopologySuite.GeometriesGraph.Positions.Right"/>
            locations for both geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with <see cref="F:NetTopologySuite.GeometriesGraph.Positions.On"/>, 
            <see cref="F:NetTopologySuite.GeometriesGraph.Positions.Left"/> and <see cref="F:NetTopologySuite.GeometriesGraph.Positions.Right"/> 
            locations for each respective geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(System.Int32,GeoAPI.Geometries.Locations)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/>
            location for the geometry at <paramref name="geometryIndex"/>.
            </summary>
            <param name="geometryIndex">
            The geometry to label the <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/> with the value
            <paramref name="on"/>.
            </param>
            <param name="on">The <see cref="T:GeoAPI.Geometries.Locations"/> value to label with.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(System.Int32,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/>,
            <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left"/>, and <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right"/>
            locations set to <paramref name="on"/>, <paramref name="left"/> and 
            <paramref name="right"/>, respectively, for the geometry at 
            <paramref name="geometryIndex"/>.
            </summary>
            <param name="geometryIndex">
            The geometry to label the <see cref="F:NetTopologySuite.GeometriesGraph.Positions.On"/> with the value
            <paramref name="on"/>.
            </param>
            <param name="on">
            The <see cref="T:GeoAPI.Geometries.Locations"/> value to set the corresponding 
            <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/> to.
            </param>
            <param name="left">
            The <see cref="T:GeoAPI.Geometries.Locations"/> value to set the corresponding 
            <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left"/> to.
            </param>
            <param name="right">
            The <see cref="T:GeoAPI.Geometries.Locations"/> value to set the corresponding 
            <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right"/> to.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(NetTopologySuite.GeometriesGraph.TopologyLocation,NetTopologySuite.GeometriesGraph.TopologyLocation)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with the given labels for 
            each respective geometry.
            </summary>
            <param name="geometry1Label">The label for the first geometry.</param>
            <param name="geometry2Label">The label for the second geometry.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(NetTopologySuite.GeometriesGraph.Label,System.Int32,GeoAPI.Geometries.Locations)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with the same values as 
            <paramref name="other"/>, except for the geometry at 
            <paramref name="geometryIndex"/>, where <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/>
            will be set to <paramref name="on"/>.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> to copy.</param>
            <param name="geometryIndex">
            The geometry to set a new <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/> value for.
            </param>
            <param name="on">
            The value to set the <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/> position of 
            <paramref name="geometryIndex"/> to.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(NetTopologySuite.GeometriesGraph.Label,System.Int32,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with the same values as 
            <paramref name="other"/>, except for the geometry at 
            <paramref name="geometryIndex"/>, where the positions 
            <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/>, <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left"/>
            and <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right"/> will be set to
            <paramref name="on"/>, <paramref name="left"/> and <paramref name="right"/>,
            respectively.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> to copy.</param>
            <param name="geometryIndex">
            The geometry to set a new <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/> value for.
            </param>
            <param name="on">
            The value to set the <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/> position of 
            <paramref name="geometryIndex"/> to.
            </param>
            <param name="left">
            The value to set the <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left"/> position of 
            <paramref name="geometryIndex"/> to.
            </param>
            <param name="right">
            The value to set the <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right"/> position of 
            <paramref name="geometryIndex"/> to.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.#ctor(NetTopologySuite.GeometriesGraph.Label,System.Int32,NetTopologySuite.GeometriesGraph.Positions,GeoAPI.Geometries.Locations)">
            <summary>
            Construct a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with the same values as 
            <paramref name="other"/>, except for the geometry at 
            <paramref name="geometryIndex"/>, where the position
            <paramref name="side"/> will be set to
            <paramref name="location"/> respectively.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> to copy.</param>
            <param name="geometryIndex">
            The geometry to set a new value at <paramref name="side"/> for.
            </param>
            <param name="side">
            The position of the <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> to set to 
            <paramref name="location"/>.
            </param>
            <param name="location">
            The value to set the given <paramref name="side"/> to.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.ToLineLabel(NetTopologySuite.GeometriesGraph.Label)">
            <summary>
            Converts a label to a line label (that is, one with no side Locations).
            </summary>
            <param name="label">Label to convert.</param>
            <returns>Label as line label.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.Flip">
            <summary>
            Computes a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> which has each of the 
            <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>s flipped.
            </summary>
            <returns>
            A <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> which has each <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            flipped.
            </returns>
            <seealso cref="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Flip"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetAllPositions(NetTopologySuite.GeometriesGraph.Label,System.Int32,GeoAPI.Geometries.Locations)">
            <summary>
            Makes a copy of a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with all the positions
            for the geometry at <paramref name="geometryIndex"/> set to 
            <paramref name="location"/>.
            </summary>
            <param name="label">The <see cref="!:label"/> to copy.</param>
            <param name="geometryIndex">
            The index of the geometry to set all locations.
            </param>
            <param name="location">
            The <see cref="T:GeoAPI.Geometries.Locations"/> value to set all the positions to.
            </param>
            <returns>
            A copy of <paramref name="label"/> with all positions set to 
            <paramref name="location"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetAllPositionsIfNone(NetTopologySuite.GeometriesGraph.Label,System.Int32,GeoAPI.Geometries.Locations)">
            <summary>
            Makes a copy of a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with all the positions
            for the geometry at <paramref name="geometryIndex"/> set to 
            <paramref name="location"/> if they are equal to 
            <see cref="F:GeoAPI.Geometries.Locations.None"/>.
            </summary>
            <param name="label">The <see cref="!:label"/> to copy.</param>
            <param name="geometryIndex">
            The index of the geometry to set all locations.
            </param>
            <param name="location">
            The <see cref="T:GeoAPI.Geometries.Locations"/> value to set any positions 
            equal to <see cref="F:GeoAPI.Geometries.Locations.None"/> to.
            </param>
            <returns>
            A copy of <paramref name="label"/> with any positions
            which had been <see cref="F:GeoAPI.Geometries.Locations.None"/> set to 
            <paramref name="location"/> for the geometry at 
            <paramref name="geometryIndex"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.SetAllPositionsIfNone(NetTopologySuite.GeometriesGraph.Label,GeoAPI.Geometries.Locations)">
            <summary>
            Makes a copy of a <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> with all the positions
            for both geometries, if they are equal to <see cref="F:GeoAPI.Geometries.Locations.None"/>,
            set to <paramref name="location"/>.
            </summary>
            <param name="label">The <see cref="!:label"/> to copy.</param>
            <param name="location">
            The <see cref="T:GeoAPI.Geometries.Locations"/> value to set any positions 
            equal to <see cref="F:GeoAPI.Geometries.Locations.None"/> to.
            </param>
            <returns>
            A copy of <paramref name="label"/> with any positions
            which had been <see cref="F:GeoAPI.Geometries.Locations.None"/> set to 
            <paramref name="location"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.Merge(System.Nullable{NetTopologySuite.GeometriesGraph.Label})">
            <summary> 
            Merge this label with another one.
            Merging updates any positions of this label which equal 
            <see cref="F:GeoAPI.Geometries.Locations.None"/> with the 
            positions from <paramref name="label"/>.
            </summary>
            <param name="label">The <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> to merge with.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsNone(System.Int32)">
            <summary>
            Returns <see langword="true"/> if the geometry at
            <paramref name="geometryIndex"/> has no set value.
            </summary>
            <param name="geometryIndex">
            The index of geometry to check.
            </param>
            <returns>
            <see langword="true"/> if the geometry represented at 
            <paramref name="geometryIndex"/> has no value; 
            <see langword="false"/> otherwise.
            </returns>
            <seealso cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsNone"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.AreAnyNone(System.Int32)">
            <summary>
            Returns <see langword="true"/> if any position geometry at
            <paramref name="geometryIndex"/> has no set value.
            </summary>
            <param name="geometryIndex">
            The index of geometry to check.
            </param>
            <returns>
            <see langword="true"/> if any position of the geometry represented at 
            <paramref name="geometryIndex"/> has no value; 
            <see langword="false"/> otherwise.
            </returns>
            <seealso cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.AreAnyNone"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsArea">
            <summary>
            Gets a value indicating whether any <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            represents an area.
            </summary>
            <seealso cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsArea"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsArea(System.Int32)">
            <summary>
            Gets a value indicating whether the <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            of the geometry at <paramref name="geometryIndex"/>
            represents an area.
            </summary>
            <param name="geometryIndex">
            The index of the represented geometry to check.
            </param>
            <returns>
            <see langword="true"/> if the geometry at <paramref name="geometryIndex"/> 
            is an area; <see langword="false"/> otherwise.
            </returns>
            <seealso cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsArea"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsLine(System.Int32)">
            <summary>
            Gets a value indicating whether the <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            of the geometry at <paramref name="geometryIndex"/>
            represents a line.
            </summary>
            <param name="geometryIndex">
            The index of the represented geometry to check.
            </param>
            <returns>
            <see langword="true"/> if the geometry at <paramref name="geometryIndex"/> 
            is a line; <see langword="false"/> otherwise.
            </returns>
            <seealso cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsLine"/>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.IsEqualOnSide(NetTopologySuite.GeometriesGraph.Label,NetTopologySuite.GeometriesGraph.Positions)">
            <summary>
            Compares the <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> and another Label to determine
            if all the <see cref="T:GeoAPI.Geometries.Locations"/> values are the same on the given
            <paramref name="side"/>.
            </summary>
            <param name="other">The other <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> to compare.</param>
            <param name="side">
            The <see cref="T:NetTopologySuite.GeometriesGraph.Positions"/> value indicating the side to compare.
            </param>
            <returns>
            <see langword="true"/> if the labels share the same values on the given 
            <paramref name="side"/>; <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.AllPositionsEqual(System.Int32,GeoAPI.Geometries.Locations)">
            <summary>
            Compares the <see cref="T:GeoAPI.Geometries.Locations"/> values of all the positions
            for the geometry represented at <paramref name="geometryIndex"/>
            are equal to <paramref name="location"/>.
            </summary>
            <param name="geometryIndex">
            The index of the represented geometry to check.
            </param>
            <param name="location">The <see cref="T:GeoAPI.Geometries.Locations"/> value to compare to.</param>
            <returns>
            <see langword="true"/> if the positions equal the given 
            <paramref name="location"/>; <see langword="false"/> otherwise.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Label.ToLine(System.Int32)">
            <summary> 
            Converts the <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> at 
            <paramref name="geometryIndex"/> to a line location.
            </summary>
            <param name="geometryIndex">
            The index of the geometry location to convert.
            </param>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Label.Item(System.Int32,NetTopologySuite.GeometriesGraph.Positions)">
            <summary>
            Gets the <see cref="T:GeoAPI.Geometries.Locations"/> value for the given 
            <paramref name="position"/> for the geometry at
            <paramref name="geometryIndex"/>.
            </summary>
            <param name="geometryIndex">The index of the geometry to lookup.</param>
            <param name="position">T
            he <see cref="T:NetTopologySuite.GeometriesGraph.Positions"/> to get the <see cref="T:GeoAPI.Geometries.Locations"/> value at.
            </param>
            <returns>
            The <see cref="T:GeoAPI.Geometries.Locations"/> value stored for the geometry at 
            the given position.
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Label.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> for the geometry
            at <paramref name="geometryIndex"/>.
            </summary>
            <param name="geometryIndex">
            The index of the geometry to get the corresponding 
            <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> for.
            </param>
            <returns>
            The <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> for the geometry
            at <paramref name="geometryIndex"/>.
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Label.GeometryCount">
            <summary>
            The number of geometries represented by this <see cref="T:NetTopologySuite.GeometriesGraph.Label"/>.
            </summary>
            <remarks>
            Each <see cref="T:NetTopologySuite.GeometriesGraph.Label"/> might represent 0, 1 or 2 geometries.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1">
            <summary> 
            A <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1"/> is an ordered list of 
            outgoing <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/>s around a node.
            It supports labeling the edges as well as linking the edges to form both
            <see cref="T:NetTopologySuite.Operation.Overlay.MaximalEdgeRing`1"/>s and 
            <see cref="T:NetTopologySuite.Operation.Overlay.MinimalEdgeRing`1"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1.Insert(NetTopologySuite.GeometriesGraph.EdgeEnd{`0})">
            <summary> 
            Insert a directed edge in the list.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1.ComputeLabeling(System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.GeometryGraph{`0}})">
            <summary> 
            Compute the labeling for all dirEdges in this star, as well
            as the overall labeling.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1.MergeSymLabels">
            <summary> 
            For each <see cref="T:NetTopologySuite.GeometriesGraph.DirectedEdge`1"/> 
            in the star, merge the label.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1.UpdateLabeling(NetTopologySuite.GeometriesGraph.Label)">
            <summary> 
            Update incomplete dirEdge labels from the labeling for the node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1.LinkResultDirectedEdges">
            <summary> 
            Traverse the star of DirectedEdges, linking the included edges together.
            </summary>
            <remarks>
            <para>
            To link two directed edges, the next pointer for an incoming directed edge
            is set to the next outgoing edge.
            </para>
            <list type="bullet">
            <listheader>
            DirEdges are only linked if:
            </listheader>
            <item>
            <description>
            they belong to an area (i.e. they have sides)
            </description>
            </item>
            <item>
            <description>
            they are marked as being in the result
            </description>
            </item>
            </list>
            <para>
            Edges are linked in CCW order (the order they are stored). 
            This means that rings have their face on the Right
            (in other words, the topological location of the face is given 
            by the RHS label of the DirectedEdge).
            </para>
            <para>
            PRECONDITION: No pair of directed edges are both marked as being in the result.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1.FindCoveredLineEdges">
            <summary> 
            Traverse the star of edges, maintaing the current location in the result
            area at this node (if any).
            If any L edges are found in the interior of the result, mark them as covered.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.DirectedEdgeStar`1.computeDepths(System.Int32,System.Int32,System.Int32)">
            <summary> 
            Compute the DirectedEdge depths for a subsequence of the edge array.
            </summary>
            <returns>
            The last depth assigned (from the R side of the last edge visited).
            </returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SimpleMonotoneChainSweepLineIntersector`1">
            <summary> 
            A <see cref="T:NetTopologySuite.GeometriesGraph.Index.SimpleMonotoneChainSweepLineIntersector`1"/> 
            creates monotone chains from the edges
            and compares them using a simple sweep-line along the x-axis.
            </summary>
            <remarks>
            <para>
            Finds all intersections in one or two sets of edges,
            using an x-axis sweepline algorithm in conjunction with Monotone Chains.
            </para>
            <para>
            While still O(n^2) in the worst case, this algorithm
            drastically improves the average-case time.
            </para>
            <para>
            The use of <see cref="T:NetTopologySuite.GeometriesGraph.Index.MonotoneChain`1"/>s as the items in the index
            seems to offer an improvement in performance over a sweep-line alone.
            </para>
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.BufferOp_110`1.MaxPrecisionDigits">
            A number of digits of precision which leaves some computational "headroom"
            for floating point operations.
            
            This value should be less than the decimal precision of double-precision values (16).
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp_110`1.PrecisionScaleFactor(GeoAPI.Geometries.IGeometry{`0},System.Double,System.Int32)">
             Compute a scale factor to limit the precision of
             a given combination of Geometry and buffer distance.
             The scale factor is determined by a combination of
             the number of digits of precision in the (geometry + buffer distance),
             limited by the supplied <code>maxPrecisionDigits</code> value.
            
             @param g the Geometry being buffered
             @param distance the buffer distance
             @param maxPrecisionDigits the max # of digits that should be allowed by
                      the precision determined by the computed scale factor
            
             @return a scale factor for the buffer computation
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp_110`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double)">
             Computes the buffer of a geometry for a given buffer distance.
            
             @param g the geometry to buffer
             @param distance the buffer distance
             @return the buffer of the input geometry
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp_110`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double,GeoAPI.Operations.Buffer.BufferParameters)">
             Comutes the buffer for a geometry for a given buffer distance
             and accuracy of approximation.
            
             @param g the geometry to buffer
             @param distance the buffer distance
             @param params the buffer parameters to use
             @return the buffer of the input geometry
            
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp_110`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double,System.Int32)">
             Comutes the buffer for a geometry for a given buffer distance
             and accuracy of approximation.
            
             @param g the geometry to buffer
             @param distance the buffer distance
             @param quadrantSegments the number of segments used to approximate a quarter circle
             @return the buffer of the input geometry
            
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp_110`1.Buffer(GeoAPI.Geometries.IGeometry{`0},System.Double,System.Int32,GeoAPI.Operations.Buffer.BufferStyle)">
             Comutes the buffer for a geometry for a given buffer distance
             and accuracy of approximation.
            
             @param g the geometry to buffer
             @param distance the buffer distance
             @param quadrantSegments the number of segments used to approximate a quarter circle
             @param endCapStyle the end cap style to use
             @return the buffer of the input geometry
            
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp_110`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
             Initializes a buffer computation for the given geometry
            
             @param g the geometry to buffer
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp_110`1.#ctor(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Operations.Buffer.BufferParameters)">
             Initializes a buffer computation for the given geometry
             with the given set of parameters
            
             @param g the geometry to buffer
             @param bufParams the buffer parameters to use
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferOp_110`1.GetResultGeometry(System.Double)">
             Returns the buffer computed for a geometry for a given buffer distance.
            
             @param distance the buffer distance
             @return the buffer of the input geometry
        </member>
        <member name="T:NetTopologySuite.Operation.BoundaryOp`1.Counter">
             Stores an integer count, for use as a Map entry.
            
             @author Martin Davis
             @version 1.7
        </member>
        <member name="F:NetTopologySuite.Operation.BoundaryOp`1.Counter.Count">
            The value of the count
        </member>
        <member name="T:NetTopologySuite.Noding.ScaledNoder`1">
            <summary>
            Wraps a <see cref="!:INoder"/> and transforms its input into the integer domain.
            This is intended for use with Snap-Rounding noders,
            which typically are only intended to work in the integer domain.
            Offsets can be provided to increase the number of digits of available precision.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder`1.#ctor(GeoAPI.Coordinates.ICoordinateSequenceFactory{`0},NetTopologySuite.Noding.INoder{`0},System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.ScaledNoder`1"/> class.
            </summary>
            <param name="noder"></param>
            <param name="scaleFactor"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder`1.#ctor(GeoAPI.Coordinates.ICoordinateSequenceFactory{`0},NetTopologySuite.Noding.INoder{`0},System.Double,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="sequenceFactory"></param>
            <param name="noder"></param>
            <param name="scaleFactor"></param>
            <param name="offsetX"></param>
            <param name="offsetY"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder`1.Scale(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            
            </summary>
            <param name="segStrings"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder`1.Scale(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder`1.Rescale(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            
            </summary>
            <param name="pts"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Noding.ScaledNoder`1.Rescale(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            
            </summary>
            <param name="segStrings"></param>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.Noding.ScaledNoder`1.IsIntegerPrecision">
            <summary>
            
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Mod2BoundaryNodeRule">
            <summary>
            The Mod-2 Boundary Node Rule (as used in the OGC SFS). 
            It specifies that points are in the boundary of a lineal geometry 
            iff the point lies on the boundary of an odd number of components. 
            Under this rule <see cref="T:GeoAPI.Geometries.ILinearRing"/>s and closed
            <see cref="T:GeoAPI.Geometries.ILineString"/>s have empty boundaries. 
            </summary>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Creates a new locator for a given <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            </summary>
            <param name="g">the Geometry to locate in</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:NetTopologySuite.Algorithm.Locate.IndexedPointInAreaLocator`1.Locate(`0)">
            Determines the {@link Location} of a point in an areal <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
            
            @param p the point to test
            @return the location of the point in the geometry  
        </member>
        <member name="T:NetTopologySuite.IO.WellKnownBinary.WkbGeometryType">
            <summary>
            Enumeration to determine geometry type in a Well-Known Binary String.
            </summary>
            <remarks>
            <para>
            From section 8.2.3, A common list of codes for geometric types
            OpenGIS Implementation Specification for Geographic information - Simple feature access - Part 1: Common architecture
            Reference Number: OGC 06-103r3; Version: 1.2.0
            </para>
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1">
            <summary>
             A utility class which creates Delaunay Trianglulations
             from collections of points and extract the resulting 
             triangulation edges or triangles as geometries.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.ExtractUniqueCoordinates(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Extracts the unique <see cref="!:TCoordinate"/>s from the given <see cref="T:GeoAPI.Geometries.IGeometry`1"/>
            </summary>
            <param name="geom">the geometry to extract from</param>
            <returns>a List of the unique Coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.Unique(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary>
            </summary>
            <param name="coords"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.ToVertices(System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Converts all <see cref="!:TCoordinate"/>s in a collection to <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/>es.
            </summary>
            <param name="coords">the coordinates to convert</param>
            <returns>a List of Vertex objects</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.Extents(GeoAPI.Geometries.IGeometryFactory{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Computes the <see cref="T:GeoAPI.Geometries.IExtents`1"/> of a collection of <see cref="!:TCoordinate"/>s.
            </summary>
            <param name="geomFactory">Factory to create empty extents</param>
            <param name="coords">a set of Coordinates</param>
            <returns>the envelope of the set of coordinates</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
             Creates an instance of this class
            </summary>
            <param name="geometryFactory">factory to create geometries and extent</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.SetSites(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Sets the sites (point or vertices) which will be triangulated.
             All vertices of the given geometry will be used as sites.
            </summary>
            <param name="geom">the geometry from which the sites will be extracted.</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.SetSites(System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Sets the sites (point or vertices) which will be triangulated
             from a collection of <see cref="!:TCoordinate"/>s
            </summary>
            <param name="coords">a set of coordinates</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.GetSubdivision">
            <summary>
             Gets the <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/> which models the computed triangulation.
            </summary>
            <returns>the subdivision containing the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.GetEdges">
            <summary>
             Gets the edges of the computed triangulation as a <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/>.
            </summary>
            <returns>the edges of the triangulation</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.GetTriangles">
            <summary>
             Gets the faces of the computed triangulation as a <see cref="T:GeoAPI.Geometries.IMultiPolygon`1"/>.
            </summary>
            <returns>the faces of the triangulation</returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.DelaunayTriangulationBuilder`1.Tolerance">
            <summary>
             Sets the snapping tolerance which will be used
             to improved the robustness of the triangulation computation.
             A tolerance of 0.0 specifies that no snapping will take place.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.RectangleContains`1">
            <summary>
            Optimized implementation of spatial predicate "contains"
            for cases where the first <see cref="T:GeoAPI.Geometries.IGeometry`1"/> is a rectangle.    
            As a further optimization, this class can be used directly to test 
            many geometries against a single rectangle.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Predicate.RectangleContains`1.#ctor(GeoAPI.Geometries.IPolygon{`0})">
            <summary>
            Create a new contains computer for two geometries.
            </summary>
            <param name="rectangle">A rectangular geometry.</param>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.OverlayNodeFactory`1">
            <summary>
            Creates nodes for use in the <see cref="T:NetTopologySuite.GeometriesGraph.PlanarGraph`1"/>s 
            constructed during overlay operations.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentNodeList`1">
            <summary>
            An ordered enumeration of the <see cref="T:NetTopologySuite.Noding.SegmentNode`1"/>s 
            present along a noded <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList`1.#ctor(NetTopologySuite.Noding.NodedSegmentString{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.SegmentNodeList`1"/> class.
            </summary>
            <param name="segments">The edge.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList`1.GetEnumerator">
            <summary>
            Returns an iterator of SegmentNodes.
            </summary>
            <returns>An iterator of SegmentNodes.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList`1.Add(`0,System.Int32)">
            <summary>
            Adds an intersection into the list, if it isn't already there.
            The input <paramref name="segmentIndex"/> is expected to be normalized.
            </summary>
            <returns>The <see cref="T:NetTopologySuite.Noding.SegmentNode`1"/> found or added.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNodeList`1.CreateSplitEdges">
            <summary>
            Creates new edges for all the edges that the intersections in this
            list split the parent edge into.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1">
            <summary>
             A prepared version for <see cref="T:GeoAPI.Geometries.IPolygonal"/> geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1.#ctor(GeoAPI.Geometries.IPolygonal{`0})">
            <summary>
             Constructs an instance of <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1"/>.
            </summary>
            <param name="polygon">the polygon to prepare</param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1.IntersectionFinder">
            <summary>
             Intersection Finder
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.Prepared.PreparedPolygon`1.PointLocator">
            <summary>
             Point Locator
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.Prepared.PreparedPoint`1">
            <summary>
             Tests whether this point intersects a <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.
             The optimization here is that computing topology for the test geometry
             is avoided. This can be significant for large geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Prepared.PreparedPoint`1.#ctor(GeoAPI.Geometries.IPuntal{`0})">
            <summary>
             Constructs an instance of <see cref="T:NetTopologySuite.Geometries.Prepared.PreparedPoint`1"/>
            </summary>
            <param name="point">base geometry</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory`1" -->
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory`1.Prepare(GeoAPI.Geometries.IGeometry{`0})" -->
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Geometries.Prepared.PreparedGeometryFactory`1.Create(GeoAPI.Geometries.IGeometry{`0})" -->
        <member name="T:NetTopologySuite.Geometries.Polygon`1">
            <summary> 
            Represents a linear polygon, which may include holes.
            The shell and holes of the polygon are represented by 
            <see cref="T:GeoAPI.Geometries.ILinearRing`1"/>s.
            </summary>
            <remarks>
            In a valid polygon, holes may touch the shell or other holes at a single point.
            However, no sequence of touching holes may split the polygon into two pieces.
            The orientation of the rings in the polygon does not matter.
            The shell and holes must conform to the assertions specified in the
            <see href="http://www.opengis.org/techno/specs.htm">
            OpenGIS Simple Features Specification for SQL </see>.     
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Geometries.Polygon`1._shell">
            <summary>
            The exterior boundary, or <see langword="null"/> if this 
            <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> is the empty point.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Geometries.Polygon`1._holes">
            <summary>
            The interior boundaries, if any.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon`1.#ctor(GeoAPI.Geometries.ILinearRing{`0},System.Collections.Generic.IEnumerable{GeoAPI.Geometries.ILineString{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> class.
            </summary>
            <param name="shell">
            The outer boundary of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
            or <see langword="null"/> or an empty 
            <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> if the empty
            point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>, 
            or <see langword="null"/> or empty 
            <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>s if the empty
            point is to be created.
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> 
            is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> 
            with <see cref="!:PrecisionModel&lt;TCoordinate&gt;"/> <c> == </c> 
            <see cref="!:PrecisionModelType.Floating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon`1.#ctor(GeoAPI.Geometries.ILinearRing{`0},System.Collections.Generic.IEnumerable{GeoAPI.Geometries.ILineString{`0}},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> 
            with the given exterior boundary and
            interior boundaries.
            </summary>       
            <param name="shell">
            The outer boundary of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
            or <see langword="null"/> or an empty 
            <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> if the empty
            point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
            or <see langword="null"/> or empty 
            <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>s if the empty
            point is to be created.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon`1.#ctor(GeoAPI.Coordinates.ICoordinateSequence{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> 
            with the given exterior boundary and
            interior boundaries.
            </summary>       
            <param name="sequence">
            The outer boundary of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
            or <see langword="null"/> or an empty 
            <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> if the empty
            point is to be created.
            </param>
            <param name="factory">
            The inner boundaries of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
            or <see langword="null"/> or empty 
            <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>s if the empty
            point is to be created.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon`1.#ctor(GeoAPI.Geometries.ILinearRing{`0},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> with the given exterior boundary.
            </summary>
            <param name="shell">
            The outer boundary of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
            or <see langword="null"/> or an empty <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> if the empty
            polygon is to be created.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.Polygon`1.#ctor(GeoAPI.Geometries.ILinearRing{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> with the given exterior boundary.
            </summary>
            <param name="shell">
            The outer boundary of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
            or <see langword="null"/> or an empty <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> if the empty
            polygon is to be created.
            </param>
        </member>
        <member name="P:NetTopologySuite.Geometries.Polygon`1.Length">
            <summary>
            Returns the perimeter of this <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator`1.MaxDistanceDiffFrac">
            Maximum allowable fraction of buffer distance the 
            actual distance can differ by.
            1% sometimes causes an error - 1.2% should be safe.
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator`1.CheckMinimumDistance(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0},System.Double)">
            Checks that two geometries are at least a minumum distance apart.
            
            @param g1 a geometry
            @param g2 a geometry
            @param minDist the minimum distance the geometries should be separated by
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.Validate.BufferDistanceValidator`1.CheckMaximumDistance(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0},System.Double)">
            Checks that the furthest distance from the buffer curve to the _input
            is less than the given maximum distance.
            This uses the Oriented Hausdorff distance metric.
            It corresponds to finding
            the point on the buffer curve which is furthest from <i>some</i> point on the _input.
            
            @param _input a geometry
            @param bufCurve a geometry
            @param maxDist the maximum distance that a buffer _result can be from the _input
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.GeometryNoder`1">
            <summary>
             Nodes a list of <see cref="T:GeoAPI.Geometries.IGeometry`1"/>s using Snap Rounding
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.GeometryNoder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
             Creates an instance of this class
            </summary>
            <param name="geomFactory">Geometry Factory with desired Precision model</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.GeometryNoder`1.Node(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            Nodes the linework of a set of Geometrys using SnapRounding. 
            
            @param geoms a Collection of Geometrys of any type
            @return a List of LineStrings representing the noded linework of the input
        </member>
        <member name="P:NetTopologySuite.Noding.Snapround.GeometryNoder`1.Validate">
            <summary>
             
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.FastNodingValidator`1">
             Validates that a collection of {@link SegmentString}s is correctly noded.
             Indexing is used to improve performance.
             This class assumes that at least one round of noding has already been performed
             (which may still leave intersections, due to rounding issues).
             Does NOT check a-b-a collapse situations. 
             Also does not check for endpt-interior vertex intersections.
             This should not be a problem, since the noders should be
             able to compute intersections between vertices correctly.
             User may either test the valid condition, or request that a 
             {@link TopologyException} 
             be thrown.
            
             @version 1.7
        </member>
        <member name="M:NetTopologySuite.Noding.FastNodingValidator`1.GetErrorMessage">
            <summary>
             Returns an error message indicating the segments containing the intersection.
            </summary>
            <returns>an error message documenting the intersection location</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.FastNodingValidator`1.CheckValid">
            <summary>
             Checks for an intersection and throws
             a TopologyException if one is found.
            </summary>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">if an intersection is found</exception>
        </member>
        <member name="P:NetTopologySuite.Noding.FastNodingValidator`1.IsValid">
            <summary>
             Checks for an intersection and reports if one is found.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Planargraph.Edge`1">
            <summary>
            Represents an undirected edge of a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/>. 
            An undirected edge in fact simply acts as a central point of reference 
            for two opposite <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s.
            </summary>
            <remarks>
            Usually a client using a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/> will subclass 
            <see cref="T:NetTopologySuite.Planargraph.Edge`1"/> to add its own application-specific 
            data and methods.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge`1.#ctor(NetTopologySuite.Planargraph.DirectedEdge{`0},NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Constructs an Edge initialized with the given DirectedEdges, and for each
            DirectedEdge: sets the Edge, sets the symmetric DirectedEdge, and adds
            this Edge to its from-Node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge`1.SetDirectedEdges(NetTopologySuite.Planargraph.DirectedEdge{`0},NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Initializes this Edge's two DirectedEdges, and for each DirectedEdge: sets the
            Edge, sets the symmetric DirectedEdge, and adds this Edge to its from-Node.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge`1.GetDirectedEdge(System.Int32)">
            <summary> 
            Returns one of the DirectedEdges associated with this Edge.
            </summary>
            <param name="i">0 or 1.</param>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge`1.GetDirectedEdge(NetTopologySuite.Planargraph.Node{`0})">
            <summary>
            Returns the DirectedEdge that starts from the given node, or null if the
            node is not one of the two nodes associated with this Edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge`1.GetOppositeNode(NetTopologySuite.Planargraph.Node{`0})">
            <summary> 
            If <paramref name="node"/> is one of the two nodes associated 
            with this <see cref="T:NetTopologySuite.Planargraph.Edge`1"/>,
            returns the other node; otherwise returns null.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.Edge`1.Remove">
            <summary>
            Removes this edge from its containing graph.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.Edge`1.IsRemoved">
            <summary>
            Tests whether this component has been removed from its containing graph.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.IsSimpleOp`1">
            <summary>
            Tests whether a <see cref="T:GeoAPI.Geometries.IGeometry`1"/> is simple.
            </summary>
            <remarks>
            Only <see cref="T:GeoAPI.Geometries.IGeometry`1"/>s whose definition allows them
            to be simple or non-simple are tested. (e.g. <see cref="T:GeoAPI.Geometries.IPolygon`1"/>s
            must be simple by definition, so no test is provided.  
            To test whether a given Polygon is valid, use <see cref="P:GeoAPI.Geometries.IGeometry.IsValid"/>)
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp`1.#ctor">
            <summary>
             Creates a simplicity checker using the default SFS Mod-2 Boundary Node Rule
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Creates a simplicity checker using the default SFS Mod-2 Boundary Node Rule
            </summary>
            <param name="geometry">the geometry to test</param>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp`1.#ctor(GeoAPI.Geometries.IGeometry{`0},NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
             Creates a simplicity checker using a given <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/>
            </summary>
            <param name="geometry">the geometry to test</param>
             <param name="boundaryNodeRule">the rule to use.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp`1.IsSimple(GeoAPI.Geometries.IMultiPoint{`0})">
            <summary>
            A MultiPoint is simple if it has no repeated points.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp`1.hasNonEndpointIntersection(NetTopologySuite.GeometriesGraph.PlanarGraph{`0})">
            <summary>
            For all edges, check if there are any intersections which are NOT at an endpoint.
            The Geometry is not simple if there are intersections not at endpoints.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp`1.hasClosedEndpointIntersection(NetTopologySuite.GeometriesGraph.PlanarGraph{`0})">
            <summary> 
            Test that no edge intersection is the
            endpoint of a closed line.  To check this we compute the
            degree of each endpoint. The degree of endpoints of closed lines
            must be exactly 2.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.IsSimpleOp`1.addEndpoint(System.Collections.Generic.IDictionary{`0,NetTopologySuite.Operation.IsSimpleOp{`0}.EndpointInfo},`0,System.Boolean)">
            <summary>
            Add an endpoint to the map, creating an entry for it if none exists.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1">
            <summary>
            Locates a subgraph inside a set of subgraphs,
            in order to determine the outside depth of the subgraph.
            The input subgraphs are assumed to have had depths
            already calculated for their edges.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.findStabbedSegments(`0)">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <returns>A set of <see cref="T:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.DepthSegment"/>s intersecting the stabbing line.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.findStabbedSegments(`0,System.Collections.Generic.IEnumerable{NetTopologySuite.GeometriesGraph.DirectedEdge{`0}})">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line
            in the list of dirEdges.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <returns>
            A set of <see cref="T:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.DepthSegment"/>s intersecting the stabbing line.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.findStabbedSegments(`0,NetTopologySuite.GeometriesGraph.DirectedEdge{`0})">
            <summary>
            Finds all non-horizontal segments intersecting the stabbing line
            in the input dirEdge.
            The stabbing line is the ray to the right of stabbingRayLeftPt.
            </summary>
            <param name="stabbingRayLeftPt">The left-hand origin of the stabbing line.</param>
            <returns>
            A set of <see cref="T:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.DepthSegment"/>s intersecting the stabbing line.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.DepthSegment">
            <summary>
            A segment from a directed edge which has been assigned a depth value
            for its sides.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.DepthSegment.CompareTo(NetTopologySuite.Operation.Buffer.SubgraphDepthLocater{`0}.DepthSegment)">
            <summary>
            Defines a comparision operation on DepthSegments
            which orders them left to right:
            DS1 smaller DS2   if   DS1.seg is left of DS2.seg.
            DS1 bigger  DS2   if   DS1.seg is right of DS2.seg.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.SubgraphDepthLocater`1.DepthSegment.compareXOrdinate(NetTopologySuite.Geometries.LineSegment{`0},NetTopologySuite.Geometries.LineSegment{`0})">
            <summary>
            Compare two collinear segments for left-most ordering.
            If segs are vertical, use vertical ordering for comparison.
            If segs are equal, return 0.
            Segments are assumed to be directed so that the second coordinate is >= to the first
            (e.g. up and to the right).
            </summary>
            <param name="seg0">A segment to compare.</param>
            <param name="seg1">A segment to compare.</param>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            </summary>
            <remarks>
            <para>
            Implements the Snap Rounding technique described in Hobby, 
            Guibas and Marimont, and Goodrich et al.
            Snap Rounding assumes that all vertices lie on a uniform grid
            (hence the precision model of the input must be fixed precision,
            and all the input vertices must be rounded to that precision).
            </para>
            <para>
            This implementation uses simple iteration over the line segments.
            This implementation appears to be fully robust using an integer precision model.
            It will function with non-integer precision models, but the
            results are not 100% guaranteed to be correctly noded.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1"/> class.
            </summary>
            <param name="geoFactory">The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> to use.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1.Node(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            Some Noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s;
            others may only add some or none at all.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1.AddSnappedNode(NetTopologySuite.Noding.Snapround.HotPixel{`0},NetTopologySuite.Noding.INodableSegmentString{`0},System.Int32)">
            <summary>
            Adds a new node (equal to the snap pt) to the segment
            if the segment passes through the hot pixel.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1.ComputeVertexSnaps(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Computes nodes introduced as a result of
            snapping segments to vertices of other segments.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1.findInteriorIntersections(GeoAPI.Geometries.IGeometryFactory{`0},System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}},NetTopologySuite.Algorithm.LineIntersector{`0})">
            <summary>
            Computes all interior intersections in the collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s,
            and returns their <typeparamref name="TCoordinate"/>s.
            Does NOT node the segStrings.
            </summary>
            <returns>A list of <typeparamref name="TCoordinate"/>s for the intersections.</returns>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1.computeSnaps(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Computes nodes introduced as a result of snapping segments to snap points (hot pixels).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.SimpleSnapRounder`1.computeVertexSnaps(NetTopologySuite.Noding.NodedSegmentString{`0},NetTopologySuite.Noding.NodedSegmentString{`0})">
            <summary>
            Performs a brute-force comparison of every segment in each <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>.
            This has O(n^2) performance.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1">
            <summary>
            Uses Snap Rounding to compute a rounded,
            fully noded arrangement from a set of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            </summary>
            <remarks>
            <para>
            Implements the Snap Rounding technique described in 
            Hobby, Guibas and Marimont, and Goodrich et al.
            Snap Rounding assumes that all vertices lie on a uniform grid
            (hence the precision model of the input must be fixed precision,
            and all the input vertices must be rounded to that precision).
            </para>
            <para>
            This implementation uses a monotone chains and a spatial index to
            speed up the intersection tests.
            This implementation appears to be fully robust using an integer precision model.
            It will function with non-integer precision models, but the
            results are not 100% guaranteed to be correctly noded.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Initializes a new instance of the 
            <see cref="T:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1"/> class.
            </summary>
            <param name="geoFactory">The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> to use.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},GeoAPI.Coordinates.IPrecisionModel{`0})">
            <summary>
            Initializes a new instance of the 
            <see cref="T:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1"/> class.
            </summary>
            <param name="geoFactory">The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> to use.</param>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1.Node(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s
            and returns a set of fully noded <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            The <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s have the same context as 
            their parent.
            </summary>
            <remarks>
            Some noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s;
            others may only add some or none at all.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1.computeIntersectionSnaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Computes nodes introduced as a result of snapping segments to snap points (hot pixels).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1.computeVertexSnaps(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Computes nodes introduced as a result of
            snapping segments to vertices of other segments.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.Snapround.MonotoneChainIndexSnapRounder`1.computeVertexSnaps(NetTopologySuite.Noding.NodedSegmentString{`0})">
            <summary>
            Performs a brute-force comparison of every segment in each 
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>.
            This has O(n^2) performance.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentNode`1">
            <summary>
            Represents an intersection point between two 
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNode`1.#ctor(NetTopologySuite.Noding.NodedSegmentString{`0},`0,System.Int32,NetTopologySuite.Noding.Octants)">
            <summary>
            Initializes a new instance of the 
            <see cref="T:NetTopologySuite.Noding.SegmentNode`1"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentNode`1.CompareTo(NetTopologySuite.Noding.SegmentNode{`0})">
            <returns>
            -1 this SegmentNode is located before the argument location, or
             0 this SegmentNode is at the argument location, or
             1 this SegmentNode is located after the argument location.   
            </returns>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LinearGeometryBuilder`1">
            <summary>
            Builds a linear geometry (<see cref="T:GeoAPI.Geometries.ILineString`1"/> 
            or <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/>)
            incrementally (point-by-point).
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder`1.Add(`0)">
            <summary>
            Adds a point to the current line.
            </summary>
            <param name="pt">The <typeparamref name="TCoordinate"/> to add.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder`1.Add(`0,System.Boolean)">
            <summary>
            Adds a point to the current line.
            </summary>
            <param name="pt">The <typeparamref name="TCoordinate"/> to add.</param>
            <param name="allowRepeatedPoints">If <see langword="true"/>, allows the insertions of repeated points.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder`1.EndLine">
            <summary>
            Terminate the current <see cref="T:GeoAPI.Geometries.ILineString`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearGeometryBuilder`1.GetGeometry">
            <summary>
            Builds and returns the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearGeometryBuilder`1.FixInvalidLines">
            <summary>
            Allows invalid lines to be fixed rather than causing Exceptions.
            An invalid line is one which has only one unique point.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearGeometryBuilder`1.IgnoreInvalidLines">
            <summary>
            Allows invalid lines to be ignored rather than causing Exceptions.
            An invalid line is one which has only one unique point.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.RTree.SortedPackedRTree`2">
            <summary>
             A static index on a set of 1-dimensional intervals, using an R-Tree packed based on the order of the interval midpoints.
             It supports range searching, where the range is an interval of the real line (which may be a single point).
             A common use is to index 1-dimensional intervals which are the projection of 2-D objects onto an axis of the coordinate system.
             This index structure is <i>static</i>
             - items cannot be added or removed once the first query has been made.
             The advantage of this characteristic is that the index performance can be optimized based on a fixed set of items.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.RTree.SortedPackedRTree`2.#ctor(GeoAPI.Indexing.IBoundsFactory{`0})">
            <summary>
             constructor of this class
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.RTree.SortedPackedRTree`2.Query(`0)">
            <summary>
             Search for intervals in the index which intersect the given closed interval
            </summary>
            <param name="interval">query interval</param>
            <returns>enumerable of {TItems}</returns>
        </member>
        <member name="M:NetTopologySuite.Index.RTree.SortedPackedRTree`2.Insert(`0,`1)">
            <summary>
            </summary>
            <param name="interval"></param>
            <param name="item"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryFactory`1">
            <summary>
            Supplies a set of utility methods for building Geometry objects 
            from lists of Coordinates.
            </summary>            
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.#ctor(System.String,GeoAPI.Coordinates.ICoordinateSequenceFactory{`0},GeoAPI.CoordinateSystems.ICoordinateSystem{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> that generates 
            geometries having the given <see cref="T:GeoAPI.Coordinates.ICoordinateSequenceFactory`1"/> 
            implementation and the given spatial-reference ID and the given 
            <see cref="T:GeoAPI.CoordinateSystems.ICoordinateSystem`1"/>.
            </summary>
            <param name="coordinateSequenceFactory">The coordinate factory to use.</param>
            <param name="srid">An id code for a given spatial reference.</param>
            <param name="spatialReference">The spatial reference system for the created geometries.</param>   
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.#ctor(System.String,GeoAPI.Coordinates.ICoordinateSequenceFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> that generates 
            geometries having the given <see cref="T:GeoAPI.Coordinates.ICoordinateSequenceFactory`1"/> 
            implementation and the given spatial-reference ID and a <see langword="null"/> 
            <see cref="T:GeoAPI.CoordinateSystems.ICoordinateSystem`1"/>.
            </summary>  
            <remarks>
            The <see cref="T:GeoAPI.Coordinates.IPrecisionModel`1"/> for this factory is 
            gotten from <paramref name="coordinateSequenceFactory"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.#ctor(GeoAPI.Coordinates.ICoordinateSequenceFactory{`0},GeoAPI.CoordinateSystems.ICoordinateSystem{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> that generates 
            geometries having the given <see cref="T:GeoAPI.Coordinates.ICoordinateSequenceFactory`1"/> 
            implementation and a <see langword="null"/> spatial-reference ID and the given 
            <see cref="T:GeoAPI.CoordinateSystems.ICoordinateSystem`1"/>.
            </summary>
            <remarks>
            The <see cref="T:GeoAPI.Coordinates.IPrecisionModel`1"/> for this factory is 
            gotten from <paramref name="coordinateSequenceFactory"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.#ctor(GeoAPI.Coordinates.ICoordinateSequenceFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> that generates 
            geometries having the given CoordinateSequence implementation, and a
            <see langword="null"/> spatial-reference ID and a <see langword="null"/> 
            <see cref="T:GeoAPI.CoordinateSystems.ICoordinateSystem`1"/>.
            </summary>
            <remarks>
            The <see cref="T:GeoAPI.Coordinates.IPrecisionModel`1"/> for this factory is 
            gotten from <paramref name="coordinateSequenceFactory"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.BuildGeometry(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <summary>  
            Build an appropriate <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>, multi-geometry, or
            <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> to contain the 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s in it.
            <example>
            If <paramref name="geometries"/> contains a single <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>,
            the <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> is returned.
            If <paramref name="geometries"/> contains several <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>s, a
            <see cref="T:GeoAPI.Geometries.IMultiPolygon`1"/> is returned.
            If <paramref name="geometries"/> contains some <see cref="T:GeoAPI.Geometries.IPolygon`1"/>s and
            some <see cref="T:GeoAPI.Geometries.ILineString`1"/>s, a 
            <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> is returned.
            If <paramref name="geometries"/> is empty, an empty 
            <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> is returned.
            Note that this method does not "flatten" geometries in the input, and hence if
            any multi-geometries are contained in the input an 
            <see cref="T:GeoAPI.Geometries.IGeometryCollection`1"/> containing them will be returned.
            </example>
            </summary>
            <param name="geometries">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> to combine.</param>
            <returns>
            A <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> of the "smallest", "most type-specific" 
            class that can contain the elements of <paramref name="geometries"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.ToGeometry(GeoAPI.Geometries.IExtents{`0})">
            <summary>
            Converts the <see cref="T:GeoAPI.Geometries.IExtents`1"/> instance
            into an <see cref="T:GeoAPI.Geometries.IGeometry`1"/> with the same 
            coordinates.
            </summary>
            <remarks>
            If the <see cref="T:NetTopologySuite.Geometries.Extents`1"/> is a null 
            <see cref="T:NetTopologySuite.Geometries.Extents`1"/>, returns an
            empty <see cref="T:GeoAPI.Geometries.IPoint`1"/>. 
            If the <see cref="T:NetTopologySuite.Geometries.Extents`1"/> 
            is a point, returns a non-empty <see cref="T:NetTopologySuite.Geometries.Point`1"/>. 
            If the <see cref="T:NetTopologySuite.Geometries.Extents`1"/> is a rectangle, returns a 
            <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> whose points are (minx, miny),
            (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny).
            </remarks>
            <param name="envelope">
            The <see cref="T:NetTopologySuite.Geometries.Extents`1"/> to convert to a 
            <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </param>       
            <returns>
            An empty <see cref="T:NetTopologySuite.Geometries.Point`1"/> 
            (for null <see cref="T:NetTopologySuite.Geometries.Extents`1"/>s), 
            a <see cref="T:NetTopologySuite.Geometries.Point`1"/> 
            (when min x = max x and min y = max y) or a
            <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> (in all other cases).
            </returns>
            <exception cref="T:NetTopologySuite.Geometries.TopologyException">
            If <c>coordinates</c> is not a closed linestring, 
            that is, if the first and last coordinates are not equal.
            </exception>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreatePoint(`0)">
            <summary>
            Creates a Point using the given Coordinate; a null Coordinate will create
            an empty Geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreatePoint(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary>
            Creates an <see cref="T:GeoAPI.Geometries.IPoint`1"/> using the given 
            <see cref="T:GeoAPI.Coordinates.ICoordinateSequence`1"/>; a null or empty
            coordinate sequence will create an empty point.
            </summary>
            <remarks>
            Uses the first coordinate in <paramref name="coordinates"/> to create the point.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateLineString(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Creates a LineString using the given Coordinates; a null or empty array will
            create an empty LineString. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateLineString(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary>
            Creates a LineString using the given CoordinateSequence; a null or empty CoordinateSequence will
            create an empty LineString. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">A CoordinateSequence possibly empty, or null.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateLinearRing">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> using the given 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>; a <see langword="null"/> 
            or empty array will create an empty <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>. 
            The points must form a closed and simple linestring. 
            Consecutive points must not be equal.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateLinearRing(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> using the given 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>; a <see langword="null"/> 
            or empty array will create an empty <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>. 
            The points must form a closed and simple linestring. 
            Consecutive points must not be equal.
            </summary>
            <param name="coordinates">
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> without null elements, 
            or an empty array, or <see langword="null"/>.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateLinearRing(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary> 
            Creates a <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> using the given 
            <see cref="T:GeoAPI.Coordinates.ICoordinateSequence`1"/>; a null or empty 
            <see cref="T:GeoAPI.Coordinates.ICoordinateSequence`1"/> will
            create an empty <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>. 
            The points must form a closed and simple
            linestring. Consecutive points must not be equal.
            </summary>
            <param name="coordinates">
            An <see cref="T:GeoAPI.Coordinates.ICoordinateSequence`1"/> possibly empty, 
            or <see langword="null"/>.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreatePolygon(GeoAPI.Geometries.ILinearRing{`0},System.Collections.Generic.IEnumerable{GeoAPI.Geometries.ILinearRing{`0}})">
            <summary> 
            Constructs a <see cref="T:NetTopologySuite.Geometries.Polygon`1"/> with the given exterior boundary and
            interior boundaries.
            </summary>
            <param name="shell">
            The outer boundary of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>, or
            <see langword="null"/> or an empty <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> if
            the empty point is to be created.
            </param>
            <param name="holes">
            The inner boundaries of the new <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>, or
            <see langword="null"/> or empty <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/> s if
            the empty point is to be created.        
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateMultiPoint">
            <summary> 
            Creates an empty MultiPoint.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateMultiPoint(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IPoint{`0}})">
            <summary> 
            Creates a MultiPoint using the given Points; a null or empty array will
            create an empty MultiPoint.
            </summary>
            <param name="point">An array without null elements, or an empty array, or null.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateMultiPoint(System.Collections.Generic.IEnumerable{`0})">
            <summary> 
            Creates a MultiPoint using the given Coordinates; a null or empty array will create an empty MultiPoint.
            </summary>
            <param name="coordinates">An array without null elements, or an empty array, or null.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateMultiPoint(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary> 
            Creates a MultiPoint using the given CoordinateSequence; a null or empty CoordinateSequence will
            create an empty MultiPoint.
            </summary>
            <param name="coordinates">A CoordinateSequence possibly empty, or null.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateMultiLineString(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.ILineString{`0}})">
            <summary>
            Creates a <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/> using the 
            given <see cref="T:GeoAPI.Geometries.ILineString`1"/>s; a null or empty
            enumeration will create an empty <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/>.
            </summary>
            <param name="lineStrings">
            <see cref="T:GeoAPI.Geometries.ILineString`1"/>s, each of which may be 
            empty but not null.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateMultiPolygon(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IPolygon{`0}})">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.MultiPolygon`1"/> using the given 
            <see cref="T:NetTopologySuite.Geometries.Polygon`1"/>s; a null or empty array
            will create an empty Polygon. The polygons must conform to the
            assertions specified in the <see href="http://www.opengis.org/techno/specs.htm"/> 
            OpenGIS Simple Features Specification for SQL.
            </summary>
            <param name="polygons">Polygons, each of which may be empty but not null.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateGeometryCollection(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <summary>
            Creates a <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> using the given <c>Geometries</c>; a null or empty
            array will create an empty GeometryCollection.
            </summary>
            <param name="geometries">Geometries, each of which may be empty but not null.</param>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.SafeCreateHomogenousGeometryCollection(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <summary>
            Attempts to create a homogenous geometry collection falls back with an untyped one.
            </summary>
            <param name="geometries"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryFactory`1.CreateGeometry(GeoAPI.Geometries.IGeometry{`0})">
            <returns>
            A clone of g based on a CoordinateSequence created by this
            GeometryFactory's CoordinateSequenceFactory.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactory`1.PrecisionModel">
            <summary>
            Returns the <see cref="T:GeoAPI.Coordinates.IPrecisionModel`1"/> that geometries 
            created by this factory will be associated with.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryFactory`1.GeoAPI#Geometries#IGeometryFactory#SpatialReference">
            <summary>
            Gets or sets the spatial reference system to associate with the geometry.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.EndPointBoundaryNodeRule">
            <summary>
            A <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> which specifies that any points 
            which are endpoints of lineal components are in the boundary of the
            parent geometry. This corresponds to the "intuitive" topological definition
            of boundary.
            </summary>
            <remarks>
            <para>
            Under this rule <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>s have a non-empty boundary
            (the common endpoint of the underlying <see cref="T:NetTopologySuite.Geometries.LineString`1"/>).
            </para>
            <para>
            This rule is useful when dealing with linear networks.
            For example, it can be used to check
            whether linear networks are correctly noded.
            The usual network topology constraint is that linear segments may touch 
            only at endpoints.
            In the case of a segment touching a closed segment (ring) at one point,
            the Mod2 rule cannot distinguish between the permitted case of touching at the
            node point and the invalid case of touching at some other interior (non-node) point.
            The EndPoint rule does distinguish between these cases,
            so is more appropriate for use.
            </para>
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Algorithm.MCPointInRing`1">
            <summary>
            Implements <see cref="T:NetTopologySuite.Algorithm.IPointInRing`1"/>
            using a <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain`1"/> and a <see cref="T:NetTopologySuite.Index.Bintree.BinTree`1"/> 
            index to increase performance.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPointPoint`1">
            <summary> 
            Computes a point in the interior of an point point.
            </summary>
            <remarks>
            Algorithm:
            Find a point which is closest to the centroid of the point.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointPoint`1.add(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Tests the point(s) defined by a Geometry for the best inside 
            point. If a Geometry is not of dimension 0 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="T:GeoAPI.IO.WellKnownText.GeometryToWkt">
            <summary>
            Outputs the textual representation of a <see cref="T:GeoAPI.Geometries.IGeometry"/> instance.
            </summary>
            <remarks>
            <para>The Well-Known Text (WKT) representation of Geometry is designed to exchange geometry data in ASCII form.</para>
            Examples of WKT representations of geometry objects are:
            <list type="table">
            <listheader><term>Geometry </term><description>WKT Representation</description></listheader>
            <item><term>A Point</term>
            <description>POINT(15 20)<br/> Note that point coordinates are specified with no separating comma.</description></item>
            <item><term>A LineString with four points:</term>
            <description>LINESTRING(0 0, 10 10, 20 25, 50 60)</description></item>
            <item><term>A Polygon with one exterior ring and one interior ring:</term>
            <description>POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))</description></item>
            <item><term>A MultiPoint with three Point values:</term>
            <description>MULTIPOINT(0 0, 20 20, 60 60)</description></item>
            <item><term>A MultiLineString with two LineString values:</term>
            <description>MULTILINESTRING((10 10, 20 20), (15 15, 30 15))</description></item>
            <item><term>A MultiPolygon with two Polygon values:</term>
            <description>MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0)),((5 5,7 5,7 7,5 7, 5 5)))</description></item>
            <item><term>A GeometryCollection consisting of two Point values and one LineString:</term>
            <description>GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.Write``1(GeoAPI.Geometries.IGeometry{``0})">
            <summary>
            Converts a Geometry to its Well-Known Text representation.
            </summary>
            <param name="geometry">A Geometry to write.</param>
            <returns>A &lt;Geometry Tagged Text&gt; String (see the OpenGIS Simple
             Features Specification)</returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.Write``1(GeoAPI.Geometries.IGeometry{``0},System.IO.TextWriter)">
            <summary>
            Converts a Geometry to its Well-Known Text representation.
            </summary>
            <param name="geometry">A geometry to process.</param>
            <param name="writer">Stream to write out the geometry's text representation.</param>
            <remarks>
            Geometry is written to the output stream as &lt;Gemoetry Tagged Text&gt; String (see the OpenGIS
            Simple Features Specification).
            </remarks>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendGeometryTaggedText``1(GeoAPI.Geometries.IGeometry{``0},System.IO.TextWriter)">
            <summary>
            Converts a Geometry to &lt;Geometry Tagged Text &gt; format, then appends it to the writer.
            </summary>
            <param name="geometry">The Geometry to process.</param>
            <param name="writer">The output stream to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendPointTaggedText``1(GeoAPI.Geometries.IPoint{``0},System.IO.TextWriter)">
            <summary>
            Converts a Coordinate to &lt;Point Tagged Text&gt; format,
            then appends it to the writer.
            </summary>
            <param name="coordinate">the <code>Coordinate</code> to process</param>
            <param name="writer">the output writer to append to</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendLineStringTaggedText``1(GeoAPI.Geometries.ILineString{``0},System.IO.TextWriter)">
            <summary>
            Converts a LineString to LineString tagged text format, 
            </summary>
            <param name="lineString">The LineString to process.</param>
            <param name="writer">The output stream writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendPolygonTaggedText``1(GeoAPI.Geometries.IPolygon{``0},System.IO.TextWriter)">
            <summary>
             Converts a Polygon to &lt;Polygon Tagged Text&gt; format,
             then appends it to the writer.
            </summary>
            <param name="polygon">Th Polygon to process.</param>
            <param name="writer">The stream writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendMultiPointTaggedText``1(GeoAPI.Geometries.IMultiPoint{``0},System.IO.TextWriter)">
            <summary>
            Converts a MultiPoint to &lt;MultiPoint Tagged Text&gt;
            format, then appends it to the writer.
            </summary>
            <param name="multipoint">The MultiPoint to process.</param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendMultiLineStringTaggedText``1(GeoAPI.Geometries.IMultiLineString{``0},System.IO.TextWriter)">
            <summary>
            Converts a MultiLineString to &lt;MultiLineString Tagged
            Text&gt; format, then appends it to the writer.
            </summary>
            <param name="multiLineString">The MultiLineString to process</param>
            <param name="writer">The output stream writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendMultiPolygonTaggedText``1(GeoAPI.Geometries.IMultiPolygon{``0},System.IO.TextWriter)">
            <summary>
            Converts a MultiPolygon to &lt;MultiPolygon Tagged
            Text&gt; format, then appends it to the writer.
            </summary>
            <param name="multiPolygon">The MultiPolygon to process</param>
            <param name="writer">The output stream writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendGeometryCollectionTaggedText``1(GeoAPI.Geometries.IGeometryCollection{``0},System.IO.TextWriter)">
            <summary>
            Converts a GeometryCollection to &lt;GeometryCollection Tagged
            Text&gt; format, then appends it to the writer.
            </summary>
            <param name="geometryCollection">The GeometryCollection to process</param>
            <param name="writer">The output stream writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendPointText``1(GeoAPI.Geometries.IPoint{``0},System.IO.TextWriter)">
            <summary>
            Converts a Coordinate to Point Text format then appends it to the writer.
            </summary>
            <param name="point">The point to process.</param>
            <param name="writer">The output stream writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendCoordinate``1(``0,System.IO.TextWriter)">
            <summary>
            Converts a coordinate to &lt;Point&gt; format, then appends
            it to the writer. 
            </summary>
            <param name="coordinate">The Coordinate to process.</param>
            <param name="writer">The output writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.writeNumber(System.Double)">
            <summary>
            Converts a Double to a String, not in scientific notation.
            </summary>
            <param name="d">The Double to convert.</param>
            <returns>The <see cref="T:System.Double"/> value as a string, not in scientific notation.</returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendLineStringText``1(GeoAPI.Geometries.ILineString{``0},System.IO.TextWriter)">
            <summary>
            Converts a LineString to &lt;LineString Text&gt; format, then
            Appends it to the writer.
            </summary>
            <param name="lineString">The LineString to process.</param>
            <param name="writer">The output stream to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendPolygonText``1(GeoAPI.Geometries.IPolygon{``0},System.IO.TextWriter)">
            <summary>
            Converts a Polygon to &lt;Polygon Text&gt; format, then
            Appends it to the writer.
            </summary>
            <param name="polygon">The Polygon to process.</param>
            <param name="writer"></param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendMultiPointText``1(GeoAPI.Geometries.IMultiPoint{``0},System.IO.TextWriter)">
            <summary>
            Converts a MultiPoint to &lt;MultiPoint Text&gt; format, then
            Appends it to the writer.
            </summary>
            <param name="multiPoint">The MultiPoint to process.</param>
            <param name="writer">The output stream writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendMultiLineStringText``1(GeoAPI.Geometries.IMultiLineString{``0},System.IO.TextWriter)">
            <summary>
            Converts a MultiLineString to &lt;MultiLineString Text&gt;
            format, then appends it to the writer.
            </summary>
            <param name="multiLineString">The MultiLineString to process.</param>
            <param name="writer">The output stream writer to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendMultiPolygonText``1(GeoAPI.Geometries.IMultiPolygon{``0},System.IO.TextWriter)">
            <summary>
            Converts a MultiPolygon to &lt;MultiPolygon Text&gt; format, then Appends to it to the writer.
            </summary>
            <param name="multiPolygon">The MultiPolygon to process.</param>
            <param name="writer">The output stream to append to.</param>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryToWkt.appendGeometryCollectionText``1(GeoAPI.Geometries.IGeometryCollection{``0},System.IO.TextWriter)">
            <summary>
            Converts a GeometryCollection to &lt;GeometryCollection Text &gt; format, then appends it to the writer.
            </summary>
            <param name="geometryCollection">The GeometryCollection to process.</param>
            <param name="writer">The output stream writer to append to.</param>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.LastFoundQuadEdgeLocator`1">
            <summary>
             Locates <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1"/>s in a <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1"/>,
             optimizing the search by starting in the locality of the last edge found.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.LastFoundQuadEdgeLocator`1.#ctor(NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision{`0})">
            <summary>
             Creates a new <see cref="T:NetTopologySuite.Triangulate.Quadedge.LastFoundQuadEdgeLocator`1"/>.
            </summary>
            <param name="subdiv"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.LastFoundQuadEdgeLocator`1.Locate(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Locates an edge e, such that either v is on e, or e is an edge of a triangle containing v.
             The search starts from the last located edge amd proceeds on the general direction of v.
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Triangulate.IConstraintVertexFactory`1">
            <summary>
             An interface for factories which create a <see cref="T:NetTopologySuite.Triangulate.ConstraintVertex`1"/>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="T:NetTopologySuite.Simplify.TopologyPreservingSimplifier`1">
            <summary>
            Simplifies a point, ensuring that
            the result is a valid point having the
            same dimension and number of components as the input.
            </summary>
            <remarks>
            The simplification uses a maximum distance difference algorithm
            similar to the one used in the Douglas-Peucker algorithm.
            In particular, if the input is an areal point
            ( <see cref="T:GeoAPI.Geometries.IPolygon`1"/> or <see cref="T:GeoAPI.Geometries.IMultiPolygon`1"/> )
            The result has the same number of shells and holes (rings) as the input,
            in the same order
            The result rings touch at no more than the number of touching point in the input
            (although they may touch at fewer points).
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.TopologyValidationErrors">
            <summary>
            Contains information about the nature and location of 
            a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> validation error.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.Unknown">
            <summary>
            Unknown error; default value.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.GenericTopologyValidationError">
            <summary>
            Indicates a generic topology validation error which doesn't 
            fit into any of the other <see cref="T:NetTopologySuite.Operation.Valid.TopologyValidationErrors"/> values.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.HoleOutsideShell">
            <summary>
            Indicates that a hole of a polygon lies partially 
            or completely in the exterior of the shell.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.NestedHoles">
            <summary>
            Indicates that a hole lies 
            in the interior of another hole in the same polygon.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.DisconnectedInteriors">
            <summary>
            Indicates that the interior of a polygon is disjoint
            (often caused by set of contiguous holes splitting 
            the polygon into two parts).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.SelfIntersection">
            <summary>
            Indicates that two rings of a polygonal geometry intersect.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.RingSelfIntersection">
            <summary>
            Indicates that a ring self-intersects.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.NestedShells">
            <summary>
            Indicates that a polygon component of a 
            <see cref="T:GeoAPI.Geometries.IMultiPolygon"/> lies inside another polygonal component.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.DuplicateRings">
            <summary>
            Indicates that a polygonal geometry 
            contains two rings which are identical.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.TooFewPoints">
            <summary>
            Indicates that either:
            - An <see cref="T:GeoAPI.Geometries.ILineString"/> contains a single point.
            - An <see cref="T:GeoAPI.Geometries.ILinearRing"/> contains 2 or 3 points.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.InvalidCoordinate">
            <summary>
            Indicates that the <see cref="F:GeoAPI.Coordinates.Ordinates.X">X</see>
            or <see cref="F:GeoAPI.Coordinates.Ordinates.Y">Y</see> ordinate of
            an <see cref="T:GeoAPI.Coordinates.ICoordinate"/> is not a valid 
            numeric value (e.g. <see cref="F:System.Double.NaN"/>).
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationErrors.RingNotClosed">
            <summary>
            Indicates that a ring is not correctly closed
            (the first and the last coordinate are different).
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.TopologyValidationError">
            <summary>
            Contains information about the nature and location of an <see cref="T:GeoAPI.Geometries.IGeometry`1"/>
            validation error.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Valid.TopologyValidationError._errMsg">
            <summary>
            These messages must match one-to-one up with the indexes above
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.SweeplineNestedRingTester`1">
            <summary>
            Tests whether any of a set of <see cref="T:NetTopologySuite.Geometries.LinearRing`1"/>s are
            nested inside another ring in the set, using a <c>SweepLineIndex</c>
            index to speed up the comparisons.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Valid.RepeatedPointTester`1">
            <summary> 
            Implements the appropriate checks for repeated points
            (consecutive identical coordinates) as defined in the
            NTS spec.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateComputer`1">
            <summary>
            Computes the topological relationship between two Geometries.
            </summary>
            <remarks>
            RelateComputer does not need to build a complete graph structure to compute
            the IntersectionMatrix.  The relationship between the geometries can
            be computed by simply examining the labeling of edges incident on each node.
            RelateComputer does not currently support arbitrary GeometryCollections.
            This is because GeometryCollections can contain overlapping Polygons.
            In order to correct compute relate on overlapping Polygons, they
            would first need to be noded and merged (if not explicitly, at least
            implicitly).
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.copyNodesAndLabels(System.Int32)">
            <summary>
            Copy all nodes from an arg point into this graph.
            The node label in the arg point overrides any previously computed
            label for that argIndex.
            (E.g. a node may be an intersection node with
            a computed label of Boundary,
            but in the original arg Geometry it is actually
            in the interior due to the Boundary Determination Rule)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.computeIntersectionNodes(System.Int32)">
            <summary>
            Insert nodes for all intersections on the edges of a Geometry.
            Label the created nodes the same as the edge label if they do not already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labeled.
            Endpoint nodes will already be labeled from when they were inserted.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.labelIntersectionNodes(System.Int32)">
            <summary>
            For all intersections on the edges of a Geometry,
            label the corresponding node IF it doesn't already have a label.
            This allows nodes created by either self-intersections or
            mutual intersections to be labeled.
            Endpoint nodes will already be labeled from when they were inserted.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.computeDisjointIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            If the Geometries are disjoint, we need to enter their dimension and
            boundary dimension in the Ext rows in the IM
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.updateIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the sum of the IMs for each component.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.labelIsolatedEdges(System.Int32,System.Int32)">
            <summary> 
            Processes isolated edges by computing their labeling and adding them
            to the isolated edges list.
            Isolated edges are guaranteed not to touch the boundary of the target (since if they
            did, they would have caused an intersection to be computed and hence would
            not be isolated).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.labelIsolatedEdge(NetTopologySuite.GeometriesGraph.Edge{`0},System.Int32,GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Label an isolated edge of a graph with its relationship to the target point.
            If the target has dim 2 or 1, the edge can either be in the interior or the exterior.
            If the target has dim 0, the edge must be in the exterior.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.labelIsolatedNodes">
            <summary>
            Isolated nodes are nodes whose labels are incomplete
            (e.g. the location for one Geometry is null).
            This is the case because nodes in one graph which don't intersect
            nodes in the other are not completely labeled by the initial process
            of adding nodes to the nodeList.
            To complete the labeling we need to check for nodes that lie in the
            interior of edges, and in the interior of areas.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateComputer`1.labelIsolatedNode(NetTopologySuite.GeometriesGraph.Node{`0},System.Int32)">
            <summary>
            Label an isolated node with its relationship to the target point.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Polygonize.PolygonizeEdge`1">
            <summary>
            An edge of a polygonization graph.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMerger`1">
            <summary>
            Merges a set of fully noded LineStrings.
            </summary>
            <remarks>
            <para>
            Merging stops at nodes of degree 1
            or 3 or more -- the exception is an isolated loop, which only has degree-2 nodes,
            in which case a node is simply chosen as a starting point. The direction of each
            merged LineString will be that of the majority of the LineStrings from which it
            was derived.
            </para>
            <para>
            Any dimension of Geometry is handled -- the constituent linework is extracted to 
            form the edges. The edges must be correctly noded; that is, they must only meet
            at their endpoints.  The LineMerger will still run on incorrectly noded input
            but will not form polygons from incorrected noded edges.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger`1.Add(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Adds a Geometry to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMerger`1.Add(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <summary>
            Adds a collection of Geometries to be processed. May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be
            extracted.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Linemerge.LineMerger`1.MergedLineStrings">
            <summary>
            Gets the <see cref="T:GeoAPI.Geometries.ILineString`1"/>s built by the merging process.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineMergeEdge`1">
            <summary>
            An edge of a <see cref="T:NetTopologySuite.Operation.Linemerge.LineMergeGraph`1"/>. 
            The <c>marked</c> field indicates whether this 
            Edge has been logically deleted from the graph.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineMergeEdge`1.#ctor(GeoAPI.Geometries.ILineString{`0},NetTopologySuite.Planargraph.DirectedEdge{`0},NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Constructs a LineMergeEdge with vertices given by the specified LineString.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Linemerge.LineMergeEdge`1.Line">
            <summary>
            Returns the LineString specifying the vertices of this edge.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.DistanceOp`1">
            <summary>
            Computes the distance and
            closest points between two <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s.
            </summary>
            <remarks>
            The distance computation finds a pair of points in the input geometries
            which have minimum distance between them.  These points may
            not be vertices of the geometries, but may lie in the interior of
            a line segment. In this case the coordinate computed is a close
            approximation to the exact point.
            The algorithms used are straightforward O(n^2)
            comparisons.  This worst-case performance could be improved on
            by using Voronoi techniques.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.#ctor(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Operation.Distance.DistanceOp`1"/>  that computes the distance and closest points between
            the two specified geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.#ctor(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0},System.Double)">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Operation.Distance.DistanceOp`1"/> that computes the distance and closest points between
            the two specified geometries.
            </summary>
            <param name="terminateDistance">The distance on which to terminate the search.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.FindDistance(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Compute the distance between the closest points of two geometries.
            </summary>
            <param name="g0">A <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.</param>
            <param name="g1">Another <see cref="T:GeoAPI.Geometries.IGeometry`1"/>.</param>
            <returns>The distance between the geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.IsWithinDistance(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0},System.Double)">
            <summary>
            Test whether two geometries lie within a given distance of each other.
            </summary>
            <param name="g0">The first <see cref="T:GeoAPI.Geometries.IGeometry`1"/> to comapre.</param>
            <param name="g1">The second <see cref="T:GeoAPI.Geometries.IGeometry`1"/> to comapre.</param>
            <param name="distance">The distance value to test.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.IsWithinDistance(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0},System.Double,GeoAPI.Coordinates.Tolerance)">
            <summary>
            Test whether two geometries lie within a given distance of each other, within
            the specified <paramref name="tolerance"/>.
            </summary>
            <param name="g0">The first <see cref="T:GeoAPI.Geometries.IGeometry`1"/> to comapre.</param>
            <param name="g1">The second <see cref="T:GeoAPI.Geometries.IGeometry`1"/> to comapre.</param>
            <param name="distance">The distance value to test.</param>
            <param name="tolerance">The tolerance which the comparison should be in.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.ClosestPoints(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Compute the the closest points of two geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <param name="g0">A <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.</param>
            <param name="g1">Another <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.</param>
            <returns>The closest points in the geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.ClosestPoints">
            <summary>
            Report the coordinates of the closest points in the input geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of <c>Coordinate</c>s of the closest points.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.ClosestLocations">
            <summary>
            Report the locations of the closest points in the input geometries.
            The locations are presented in the same order as the input Geometries.
            </summary>
            <returns>
            A <see cref="T:GeoAPI.DataStructures.Pair`1"/> of <see cref="T:NetTopologySuite.Operation.Distance.GeometryLocation`1"/>s 
            for the closest points.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.NearestPoints(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Compute the the nearest points of two geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <param name="g0">A <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.</param>
            <param name="g1">Another <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.</param>
            <returns>The nearest points in the geometries.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.NearestPoints">
            <summary>
            Report the coordinates of the nearest points in the input geometries.
            The points are presented in the same order as the input Geometries.
            </summary>
            <returns>A pair of <c>Coordinate</c>s of the nearest points.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.DistanceOp`1.NearestLocations">
            <summary>
            Report the locations of the nearest points in the input geometries.
            The locations are presented in the same order as the input Geometries.
            </summary>
            <returns>
            A <see cref="T:GeoAPI.DataStructures.Pair`1"/> of <see cref="T:NetTopologySuite.Operation.Distance.GeometryLocation`1"/>s 
            for the nearest points.
            </returns>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.DistanceOp`1.Distance">
            <summary>
            Gets the distance between the closest points on the input geometries.
            </summary>
            <returns>The distance between the geometries.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.RightmostEdgeFinder`1">
            <summary>
            A RightmostEdgeFinder find the DirectedEdge in a list which has the highest coordinate,
            and which is oriented L to R at that point. (I.e. the right side is on the RHS of the edge.)
            
            The DirectedEdge returned is guaranteed to have the R of the world on its RHS.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.SegmentPointComparator">
            <summary>
            Implements a robust method of comparing the relative position of two points 
            along the same segment.
            The coordinates are assumed to lie "near" the segment.
            This means that this algorithm will only return correct results
            if the input coordinates have the same precision and correspond to rounded values
            of exact coordinates lying on the segment.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.SegmentPointComparator.Compare``1(NetTopologySuite.Noding.Octants,``0,``0)">
            <summary>
            Compares two <typeparamref name="TCoordinate"/>s for their relative 
            position along a segment lying in the specified <see cref="T:NetTopologySuite.Noding.Octant"/>.
            </summary>
            <returns>
            -1 if node0 occurs first, or
             0 if the two nodes are equal, or
             1 if node1 occurs first.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Noding.IntersectionAdder`1">
            <summary>
            Computes the intersections between two line segments in 
            <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s and adds them to each string.
            The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> is passed to a 
            <see cref="T:NetTopologySuite.Noding.INoder`1"/>. The 
            <see cref="M:NetTopologySuite.Noding.NodedSegmentString`1.AddIntersections(NetTopologySuite.Algorithm.Intersection{`0},System.Int32,System.Int32)"/> method is called 
            whenever the <see cref="T:NetTopologySuite.Noding.INoder`1"/>
            detects that two <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s might intersect.
            This class is an example of the Strategy pattern.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Noding.IntersectionAdder`1._li">
            These variables keep track of what types of intersections were
            found during ALL edges that have been intersected.
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionAdder`1.#ctor(NetTopologySuite.Algorithm.LineIntersector{`0})">
            <summary>
            Initializes a new instance of the 
            <see cref="T:NetTopologySuite.Noding.IntersectionAdder`1"/> class.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionAdder`1.ProcessIntersections(NetTopologySuite.Noding.ISegmentString{`0},System.Int32,NetTopologySuite.Noding.ISegmentString{`0},System.Int32)">
            <summary>
            This method is called by clients
            of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> class to process
            intersections for two segments of the <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/> being intersected.
            Note that some clients (such as <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain`1"/>s) may optimize away
            this call for segment pairs which they have determined do not intersect
            (e.g. by an disjoint envelope test).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.IntersectionAdder`1.isTrivialIntersection(NetTopologySuite.Algorithm.Intersection{`0},NetTopologySuite.Noding.ISegmentString{`0},System.Int32,NetTopologySuite.Noding.ISegmentString{`0},System.Int32)">
            <summary>
            A trivial intersection is an apparent self-intersection which in fact
            is simply the point shared by adjacent line segments.
            Note that closed edges require a special check for the point shared by the beginning and end segments.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder`1.ProperIntersectionPoint">
            <summary>
            Returns the proper intersection point, or <see langword="null" /> 
            if none was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder`1.HasProperIntersection">
            <summary>
            A proper intersection is an intersection which is interior to at least two
            line segments.  Note that a proper intersection is not necessarily
            in the interior of the entire <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>, 
            since another edge may have an endpoint equal to the intersection, 
            which according to SFS semantics can result in the point being on the 
            Boundary of the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder`1.HasProperInteriorIntersection">
            <summary>
            A proper interior intersection is a proper intersection which is not
            contained in the set of boundary nodes set for this <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.IntersectionAdder`1.HasInteriorIntersection">
            <summary>
            An interior intersection is an intersection which is
            in the interior of some segment.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1">
            <summary>
            Computes the intersections of segments of <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>s.
            </summary>
            <typeparam name="TCoordinate">The coordinate type.</typeparam>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1.#ctor(NetTopologySuite.Algorithm.LineIntersector{`0},System.Boolean,System.Boolean)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1"/>
            with the given <see cref="T:NetTopologySuite.Algorithm.LineIntersector`1"/>
            and values indicating whether proper intersections should be included
            in the edges and if edges should be marked as not isolated 
            when adding intersections.
            </summary>
            <param name="li">
            The <see cref="T:NetTopologySuite.Algorithm.LineIntersector`1"/> to use to compute 
            intersections.
            </param>
            <param name="includeProper">
            A flag indicating whether proper intersections should be included
            in the edges' intersection lists.
            </param>
            <param name="recordIsolated">
            A flag indicating whether edges should be marked as not isolated
            when adding intersections.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1.AreAdjacentSegments(System.Int32,System.Int32)">
            <summary>
            Computes if two segments, referred to by their indexes, 
            are sequential in either direction.
            </summary>
            <param name="i1">The index of the first segment to test.</param>
            <param name="i2">The index of the second segment to test.</param>
            <returns>
            <see langword="true"/> if the indexes differ by 1 or -1.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1.AddIntersections(NetTopologySuite.GeometriesGraph.Edge{`0},System.Int32,NetTopologySuite.GeometriesGraph.Edge{`0},System.Int32)">
            <summary> 
            This method is called by clients of the 
            <see cref="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1"/> class 
            to test for and add intersections for two segments of the edges 
            being intersected.
            Note that clients (such as MonotoneChainEdges) may choose not to intersect
            certain pairs of segments for efficiency reasons.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1.ProperIntersectionPoint">
            <summary> 
            Gets the proper intersection point, or an empty
            <typeparamref name="TCoordinate"/> if none was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1.HasProperIntersection">
            <summary>
            Gets whether the line segments have a proper intersection.
            </summary>
            <remarks>
            A proper intersection is an intersection which is interior to at least two
            line segments.  Note that a proper intersection is not necessarily
            in the interior of the entire Geometry, since another edge may have
            an endpoint equal to the intersection, which according to SFS semantics
            can result in the point being on the Boundary of the Geometry.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1.HasProperInteriorIntersection">
            <summary> 
            A proper interior intersection is a proper intersection which is not
            contained in the set of boundary nodes set for this 
            <see cref="T:NetTopologySuite.GeometriesGraph.Index.SegmentIntersector`1"/>.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.TopologyException">
            <summary> 
            Indicates an invalid or inconsistent topological 
            situation encountered during processing.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.EdgeConnectedTriangleTraversal`1">
            <summary>
             A framework to visit sets of edge-connected <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1"/>s in breadth-first order
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.EdgeConnectedTriangleTraversal`1.Init(NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle{`0})">
            <summary>
             Called to initialize the traversal queue with a given <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1"/>
            </summary>
            <param name="tri"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.EdgeConnectedTriangleTraversal`1.Init(System.Collections.Generic.IEnumerable{NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle{`0}})">
            <summary>
            Called to initialize the traversal queue with a set of <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeTriangle`1"/>s
            </summary>
            <param name="tris"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.EdgeConnectedTriangleTraversal`1.VisitAll(NetTopologySuite.Triangulate.Quadedge.ITraversalVisitor{`0})">
            <summary>
             Subclasses call this method to perform the visiting process.
            </summary>
            <param name="visitor"></param>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper`1">
            <summary>
             Snaps the vertices and segments of a {@link LineString} to a set of target snap vertices.
             A snapping distance tolerance is used to control where snapping is performed.
             
             author Martin Davis
             version 1.7
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper`1.#ctor(GeoAPI.Geometries.ILineString{`0},System.Double)">
            <summary>
             Creates a new snapper using the points in the given <see cref="T:GeoAPI.Geometries.ILineString`1"/>
            </summary>
            <param name="srcLline">a LineString to snap</param>
            <param name="snapTolerance">the snap tolerance to use</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper`1.#ctor(GeoAPI.Coordinates.ICoordinateSequence{`0},System.Double)">
            <summary>
             Creates a new snapper using the given points as source points to be snapped.
            </summary>
            <param name="srcPts">the points to snap</param>
            <param name="snapTolerance">the snap tolerance to use</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper`1.SnapTo(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary>
             Snaps the vertices and segments of the source LineString to the given set of target snap points.
            </summary>
            <param name="snapPts">the vertices to snap to</param>
            <returns>the snapped points</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper`1.SnapVertices(NetTopologySuite.Geometries.CoordinateList{`0}@,GeoAPI.Coordinates.ICoordinateSequence{`0})">
            Snap source vertices to vertices in the target.
            
            @param srcCoords the points to snap
            @param snapPts the points to snap to
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper`1.SnapSegments(NetTopologySuite.Geometries.CoordinateList{`0},GeoAPI.Coordinates.ICoordinateSequence{`0})">
            Snap segments of the source to nearby snap vertices.
            Source segments are "cracked" at a snap vertex, and further
            snapping takes place on the modified list of segments.
            For each distinct snap vertex, at most one source segment
            is snapped to.  This prevents "cracking" multiple segments 
            at the same point, which would almost certainly cause the result to be invalid.
            
            @param srcCoords
            @param snapPts
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.LineStringSnapper`1.FindSegmentIndexToSnap(`0,NetTopologySuite.Geometries.CoordinateList{`0})">
             Finds a src segment which snaps to (is close to) the given snap point
             Only one segment is determined - this is to prevent
             snapping to multiple segments, which would almost certainly cause invalid geometry
             to be created.
             (The heuristic approach of snapping is really only appropriate when
             snap pts snap to a unique spot on the src geometry.)
            
             @param snapPt the point to snap to
             @param srcCoords the source segment coordinates
             @return the index of the snapped segment
             @return -1 if no segment snaps
        </member>
        <member name="T:NetTopologySuite.Operation.Linemerge.LineSequencer`1">
            <summary>
            Builds a sequence from a set of <see cref="T:GeoAPI.Geometries.ILineString"/>s,
            so that they are ordered end to end.
            A sequence is a complete non-repeating list of the linear
            components of the input.  Each linestring is oriented
            so that identical endpoints are adjacent in the list.
            </summary>
            <remarks>
            <para>
            The input linestrings may form one or more connected sets.
            The input linestrings should be correctly noded, or the results may
            not be what is expected.
            The output of this method is a single <see cref="T:GeoAPI.Geometries.IMultiLineString"/>,
            containing the ordered linestrings in the sequence.
            </para>
            <para>
            The sequencing employs the classic 'Eulerian path' graph algorithm.
            Since Eulerian paths are not uniquely determined, further rules are used to
            make the computed sequence preserve as much as possible of the input ordering.
            Within a connected subset of lines, the ordering rules are:    
             - If there is degree-1 node which is the start
            node of an linestring, use that node as the start of the sequence.
             - If there is a degree-1 node which is the end
            node of an linestring, use that node as the end of the sequence.
             - If the sequence has no degree-1 nodes, use any node as the start
            </para>
            <para>
            Not all arrangements of lines can be sequenced.
            For a connected set of edges in a graph,
            Euler's Theorem states that there is a sequence containing each edge once
            if and only if there are no more than 2 nodes of odd degree.
            If it is not possible to find a sequence, the <see cref="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.IsSequenceable"/> 
            property will return <c>false</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.IsSequenced(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Tests whether a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is sequenced correctly.
            <see cref="T:GeoAPI.Geometries.ILineString"/>s are trivially sequenced.
            <see cref="T:GeoAPI.Geometries.IMultiLineString"/>s are checked for correct sequencing.
            Otherwise, <c>IsSequenced</c> is defined
            to be <see langword="true"/> for geometries that are not lineal.
            </summary>
            <param name="geom">The <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> to test.</param>
            <returns>
            <see langword="true"/> if the <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> is sequenced or is not lineal.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.Add(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry})">
            <summary>
            Adds a <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>s to be sequenced.
            May be called multiple times.
            Any dimension of Geometry may be added; the constituent linework will be extracted.
            </summary>
            <param name="geometries">A <see cref="T:System.Collections.IEnumerable"/> of geometries to add.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.Add(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Adds a <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> to be sequenced.
            May be called multiple times.
            Any dimension of <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> may be added; 
            the constituent linework will be extracted.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.IsSequenceable">
            <summary>
            Tests whether the arrangement of linestrings has a valid sequence.
            </summary>
            <returns><see langword="true"/> if a valid sequence exists.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.GetSequencedLineStrings">
            <summary>
            Returns the <see cref="T:NetTopologySuite.Geometries.LineString`1"/> or <see cref="T:NetTopologySuite.Geometries.MultiLineString`1"/>
            built by the sequencing process, if one exists.
            </summary>
            <returns>The sequenced linestrings,
            or <see langword="null"/> if a valid sequence does not exist.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.HasSequence(NetTopologySuite.Planargraph.Subgraph{`0})">
            <summary>
            Tests whether a complete unique path exists in a graph
            using Euler's Theorem.
            </summary>
            <param name="graph">The <see cref="T:NetTopologySuite.Planargraph.Subgraph`1"/> containing the edges.</param>
            <returns><see langword="true"/> if a sequence exists.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.FindUnvisitedBestOrientedDE(NetTopologySuite.Planargraph.Node{`0})">
            <summary>
            Finds an <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/> for an unvisited edge (if any),
            choosing the <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/> which preserves orientation, if possible.
            </summary>
            <param name="node">The <see cref="T:NetTopologySuite.Planargraph.Node`1"/> to examine.</param>
            <returns>
            The <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/> found, 
            or <see langword="null"/> if none were unvisited.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.Orient(System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.DirectedEdge{`0}})">
            <summary>
            Computes a version of the sequence which is optimally
            oriented relative to the underlying geometry.
            <para>
            Heuristics used are:   
             - If the path has a degree-1 node which is the start
            node of an linestring, use that node as the start of the sequence.
             - If the path has a degree-1 node which is the end
            node of an linestring, use that node as the end of the sequence.
             - If the sequence has no degree-1 nodes, use any node as the start
            (NOTE: in this case could orient the sequence according to the majority of the
            linestring orientations).
            </para>
            </summary>
            <param name="seq">A set of <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s.</param>
            <returns>
            A set of <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s oriented appropriately.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Linemerge.LineSequencer`1.BuildSequencedGeometry(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{NetTopologySuite.Planargraph.DirectedEdge{`0}}})">
            <summary>
            Builds a geometry (<see cref="T:GeoAPI.Geometries.ILineString`1"/> 
            or <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/>)
            representing the sequence.
            </summary>
            <param name="sequences">
            A set of sets of <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s
            with <see cref="T:NetTopologySuite.Operation.Linemerge.LineMergeEdge`1"/>s as their parent edges.
            </param>
            <returns>
            The sequenced geometry, or <see langword="null"/> if no sequence exists.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Distance.GeometryLocation`1">
            <summary>
            Represents the location of a point on a Geometry.
            Maintains both the actual point location (which of course
            may not be exact) as well as information about the component
            and segment index where the point occurs.
            </summary>
            <remarks>
            Locations inside area Geometries will not have an associated segment index,
            so in this case the segment index will be null.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.GeometryLocation`1.#ctor(GeoAPI.Geometries.IGeometry{`0},System.Nullable{System.Int32},`0)">
            <summary>
            Constructs a GeometryLocation specifying a point on a point, as well as the 
            segment that the point is on (or InsideArea if the point is not on a segment).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Distance.GeometryLocation`1.#ctor(GeoAPI.Geometries.IGeometry{`0},`0)">
            <summary> 
            Constructs a GeometryLocation specifying a point inside an area point.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.GeometryLocation`1.GeometryComponent">
            <summary>
            Gets the point associated with this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.GeometryLocation`1.SegmentIndex">
            <summary>
            Gets the segment index for this location. If the location is inside an
            area, the index will be null.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.GeometryLocation`1.Coordinate">
            <summary>
            Returns the location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Operation.Distance.GeometryLocation`1.IsInsideArea">
            <summary>
            Returns whether this GeometryLocation represents a point inside an area point.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1">
            <summary>
            Computes the raw offset curve for a
            single <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> component (ring, line or point).
            A raw offset curve line is not noded -
            it may contain self-intersections (and usually will).
            The final buffer polygon is computed by forming a topological graph
            of all the noded raw curves and tracing outside contours.
            The points in the raw curve are rounded to the required precision model.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.DefaultQuadrantSegments">
            <summary>
            The default number of facets into which to divide a fillet of 90 degrees.
            A value of 8 gives less than 2% max error in the buffer distance.
            For a max error smaller of 1%, use QS = 12
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.GetLineCurve(System.Collections.Generic.IEnumerable{`0},System.Double)">
            <summary>
            This method handles single points as well as lines.
            Lines are assumed to not be closed (the function will not
            fail for closed lines, but will generate superfluous line caps).
            </summary>
            <returns> A set of coordinate sets.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.GetRingCurve(System.Collections.Generic.IEnumerable{`0},NetTopologySuite.GeometriesGraph.Positions,System.Double)">
            <summary>
            This method handles the degenerate cases of single points and lines,
            as well as rings.
            </summary>
            <returns>A set of coordinate sets.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.addLastSegment">
            <summary>
            Add last offset point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.computeOffsetSegment(NetTopologySuite.Geometries.LineSegment{`0},NetTopologySuite.GeometriesGraph.Positions,System.Double)">
            <summary>
            Compute an offset segment for an input segment on a given side and at a given distance.
            The offset points are computed in full Double precision, for accuracy.
            </summary>
            <param name="seg">The segment to offset.</param>
            <param name="side">The side of the segment the offset lies on.</param>
            <param name="distance">The offset distance.</param>
            <returns>The points computed for the offset segment.</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.addLineEndCap(`0,`0)">
            <summary>
            Add an end cap around point p1, terminating a line segment coming from p0.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.addFillet(`0,`0,`0,NetTopologySuite.Algorithm.Orientation,System.Double)">
            <param name="p">Base point of curve.</param>
            <param name="p0">Start point of fillet curve.</param>
            <param name="p1">Endpoint of fillet curve.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.addFillet(`0,System.Double,System.Double,NetTopologySuite.Algorithm.Orientation,System.Double)">
            <summary>
            Adds points for a fillet.  The start and end point for the fillet are not added -
            the caller must add them if required.
            </summary>
            <param name="direction">Is -1 for a CW angle, 1 for a CCW angle.</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.addCircle(`0,System.Double)">
            <summary>
            Adds a CW circle around a point.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.OffsetCurveBuilder`1.addSquare(GeoAPI.Coordinates.ICoordinate,System.Double)">
            <summary>
            Adds a CW square around a point
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.MonotoneChainIndexNoder`1">
            <summary>
            Nodes a set of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s using a index based
            on <see cref="T:NetTopologySuite.Index.Chain.MonotoneChain`1"/>s and a <see cref="T:GeoAPI.Indexing.ISpatialIndex`2"/>.
            The <see cref="T:GeoAPI.Indexing.ISpatialIndex`2"/> used should be something that supports
            envelope (range) queries efficiently (such as a <see cref="T:NetTopologySuite.Index.Quadtree.Quadtree`2"/>
            or <see cref="T:NetTopologySuite.Index.Strtree.StrTree`2"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MonotoneChainIndexNoder`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},NetTopologySuite.Noding.ISegmentIntersector{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.Noding.MonotoneChainIndexNoder`1"/> class.
            </summary>
            <param name="segInt">
            The <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> to use.
            </param>
        </member>
        <member name="M:NetTopologySuite.Noding.MonotoneChainIndexNoder`1.Node(System.Collections.Generic.IEnumerable{NetTopologySuite.Noding.ISegmentString{`0}})">
            <summary>
            Computes the noding for a collection of <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s.
            </summary>
            <remarks>
            Some noders may add all these nodes to the input <see cref="T:NetTopologySuite.Noding.NodedSegmentString`1"/>s;
            others may only add some or none at all.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LinearIterator`1">
            <summary>
            An iterator over the components and coordinates of a linear geometry
            (<see cref="T:GeoAPI.Geometries.ILineString`1"/>s 
            and <see cref="T:GeoAPI.Geometries.IMultiLineString`1"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Creates an iterator initialized to the start of a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="linear">The linear geometry to iterate over.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.#ctor(GeoAPI.Geometries.IGeometry{`0},NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Creates an iterator starting at a <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> 
            on a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="linear">The linear geometry to iterate over.</param>
            <param name="start">The location to start at.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.#ctor(GeoAPI.Geometries.IGeometry{`0},System.Int32,System.Int32)">
            <summary>
            Creates an iterator starting at
            a component and vertex in a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="linear">The linear geometry to iterate over.</param>
            <param name="componentIndex">The component to start at.</param>
            <param name="vertexIndex">The vertex to start at.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used 
            to iterate through the collection.
            </returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator (of <see cref="T:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement"/>elements) 
            that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object 
            that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.HasNext">
            <summary>
            Evaluate if the iterator could step over.
            Does not perform the step at all.
            </summary>
            <returns><see langword="true"/> if there are more vertices to scan.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.Next">
            <summary>
            Jump to the next element of the iteration.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.MoveNext">
            <summary>
            Tests whether there are any vertices left to iterator over.
            If <see langword="true"/>, then moves the iterator ahead to the next vertex and (possibly) linear component,
            so that <see cref="P:NetTopologySuite.LinearReferencing.LinearIterator`1.Current"/> exposes the elements.
            </summary>
            <returns><see langword="true"/> if there are more vertices to scan.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.Reset">
            <summary>
            Sets the enumerator to its initial position, 
            which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The collection was modified after the enumerator was created. 
            </exception>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, 
            releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.Current">
            <summary>
            Gets the <see cref="T:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement">element</see> in the collection 
            at the current position of the enumerator.
            </summary>
            <value></value>
            <returns>
            The <see cref="T:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement">element</see> in the collection 
            at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.isEndOfLine">
            <summary>
            Checks whether the iterator cursor is pointing to the
            endpoint of a linestring.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.componentIndex">
            <summary>
            The component index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.vertexIndex">
            <summary>
            The vertex index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.line">
            <summary>
            Gets the <see cref="T:GeoAPI.Geometries.ILineString`1"/> component the iterator is current at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.segmentStart">
            <summary>
            Gets the first <typeparamref name="TCoordinate"/> of the current segment
            (the coordinate of the current vertex).
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.segmentEnd">
            <summary>
            Gets the second <typeparamref name="TCoordinate"/> of the current segment
            (the coordinate of the next vertex).
            If the iterator is at the end of a line, <see langword="null" /> is returned.
            </summary>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement">
            <summary>
            A class that exposes <see cref="T:NetTopologySuite.LinearReferencing.LinearIterator`1"/> elements.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement.#ctor(NetTopologySuite.LinearReferencing.LinearIterator{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement"/> class.
            </summary>
            <param name="iterator">The iterator.</param>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement.ComponentIndex">
            <summary>
            The component index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement.VertexIndex">
            <summary>
            The vertex index of the vertex the iterator is currently at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement.Line">
            <summary>
            Gets the <see cref="T:GeoAPI.Geometries.ILineString`1"/> component 
            the iterator is current at.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement.IsEndOfLine">
            <summary>
            Checks whether the iterator cursor is pointing to the
            endpoint of a linestring.
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement.SegmentStart">
            <summary>
            Gets the first <typeparamref name="TCoordinate"/> of the 
            current segment (the coordinate of the current vertex).
            </summary>
        </member>
        <member name="P:NetTopologySuite.LinearReferencing.LinearIterator`1.LinearElement.SegmentEnd">
            <summary>
            Gets the second <typeparamref name="TCoordinate"/> of the current segment
            (the coordinate of the next vertex).
            If the iterator is at the end of a line, <see langword="null" /> is returned.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Sweepline.SweepLineIndex">
            <summary>
            A sweepline implements a sorted index on a set of intervals.
            It is used to compute all overlaps between the interval in the index.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Bintree.BinTreeKey">
            <summary>
            A <see cref="T:NetTopologySuite.Index.Bintree.BinTreeKey"/> is a unique identifier for a node in a tree.
            </summary>
            <remarks>
            It contains a lower-left point and a level number. The level number
            is the power of two for the size of the node envelope.
            </remarks>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeNodingValidator`1">
            <summary>
            Validates that a collection of SegmentStrings is correctly noded.
            Throws an appropriate exception if an noding error is found.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier_110`1">
            <summary>
             Simplifies a buffer input line to 
             remove concavities with shallow depth.
             
             The most important benefit of doing this
             is to reduce the number of points and the complexity of
             shape which will be buffered.
             It also reduces the risk of gores created by
             the quantized fillet arcs (although this issue
             should be eliminated in any case by the 
             offset curve generation logic).
             
             A key aspect of the simplification is that it
             affects inside (concave or inward) corners only.  
             Convex (outward) corners are preserved, since they
             are required to ensure that the eventual buffer curve
             lies at the correct distance from the input geometry.
             
             Another important heuristic used is that the end segments
             of the input are never simplified.  This ensures that
             the client buffer code is able to generate end caps consistently.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Buffer.BufferInputLineSimplifier_110`1.Simplify(System.Double)">
            <summary>
             Simplify the input geometry.
             If the distance tolerance is positive, 
             concavities on the LEFT side of the line are simplified.
             If the supplied distance tolerance is negative,
             concavities on the RIGHT side of the line are simplified.
            </summary>
            <param name="distanceTol">simplification distance tolerance to use</param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Noding.InteriorIntersectionFinder`1">
            <summary>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Noding.InteriorIntersectionFinder`1.#ctor(NetTopologySuite.Algorithm.LineIntersector{`0})">
            <summary>
             Creates an intersection finder which finds an interior intersection if one exists
            </summary>
            <param name="li">the LineIntersector to use</param>
        </member>
        <member name="M:NetTopologySuite.Noding.InteriorIntersectionFinder`1.ProcessIntersections(NetTopologySuite.Noding.ISegmentString{`0},System.Int32,NetTopologySuite.Noding.ISegmentString{`0},System.Int32)">
            <summary>
             This method is called by clients of the <see cref="T:NetTopologySuite.Noding.ISegmentIntersector`1"/> class to process
             intersections for two segments of the <see cref="T:NetTopologySuite.Noding.ISegmentString`1"/>s being intersected.
             Note that some clients (such as <see cref="!:MonotoneChain&lt;TCoordinate&gt;"/>}s) may optimize away
             this call for segment pairs which they have determined do not intersect
             (e.g. by an disjoint envelope test).
            </summary>
            <param name="e0"></param>
            <param name="segIndex0"></param>
            <param name="e1"></param>
            <param name="segIndex1"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.InteriorIntersectionFinder`1.IsEndSegment(NetTopologySuite.Noding.ISegmentString{`0},System.Int32)">
            <summary>
             Tests whether a segment in a {@link SegmentString} is an end segment.
             (either the first or last).
            </summary>
            <param name="segStr">a segment string</param>
            <param name="index">the index of a segment in the segment string</param>
            <returns>true if the segment is an end segment</returns>
        </member>
        <member name="P:NetTopologySuite.Noding.InteriorIntersectionFinder`1.CheckEndSegmentsOnly">
            <summary>
             Gets/Sets whether only end segments should be tested for interior intersection.
             This is a performance optimization that may be used if
             the segments have been previously noded by an appropriate algorithm.
             It may be known that any potential noding failures will occur only in
             end segments.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.InteriorIntersectionFinder`1.HasIntersection">
            <summary>
             Tests whether an intersection was found.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.InteriorIntersectionFinder`1.InteriorIntersection">
            <summary>
             Gets the computed location of the intersection.
             Due to round-off, the location may not be exact.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Noding.InteriorIntersectionFinder`1.IntersectionSegments">
            <summary>
             Gets the endpoints of the intersecting segments.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.KdTree.KdNode`1">
            <summary>
             A node of a <see cref="T:NetTopologySuite.Index.KdTree.KdTree`1"/>, which represents one or more points in the same location.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdNode`1.#ctor(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Double,System.Double,System.Object)">
            Creates a new KdNode.
            
            @param _x coordinate of point
            @param _y coordinate of point
            @param data a data objects to associate with this node
            <summary>
             Creates a new KdNode
             </summary>
             <param name="factory"><see cref="T:GeoAPI.Coordinates.ICoordinateFactory`1"/> to create Coordinate</param>
             <param name="x">x coordinate of point</param>
             <param name="y">y coordinate of point</param>
             <param name="data">a data object to associate with this node</param>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdNode`1.#ctor(`0,System.Object)">
            <summary>
             Creates a new KdNode
             </summary>
             <param name="p">point location of new node</param>
             <param name="data">a data object to associate with this node</param>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.X">
            <summary>
             Returns the X coordinate of the node
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Y">
            <summary>
             Returns the Y coordinate of the node
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Coordinate">
            <summary>
             Returns the location of this node
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Data">
            <summary>
             Gets the user data object associated with this node.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Left">
            <summary>
             Gets/Sets the left node of the tree
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Right">
            <summary>
             Gets/Sets the right node of the tree
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.Count">
            <summary>
             Returns the number of inserted points that are coincident at this location.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Index.KdTree.KdNode`1.IsRepeated">
            <summary>
             Tests whether more than one point with this value have been inserted (up to the tolerance)
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.InteriorPointArea`1">
            <summary> 
            Computes a point in the interior of an area point.
            </summary>
            <remarks>
            Algorithm:
            Find the intersections between the point
            and the horizontal bisector of the area's envelope
            Pick the midpoint of the largest intersection (the intersections
            will be lines and points)
            Note: If a fixed precision model is used,
            in some cases this method may return a point
            which does not lie in the interior.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea`1.Add(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Tests the interior vertices (if any)
            defined by a linear Geometry for the best inside point.
            If a Geometry is not of dimension 1 it is not tested.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea`1.AddPolygon(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Finds a reasonable point at which to label a Geometry.
            </summary>
            <param name="geometry">The point to analyze.</param>
            <returns> 
            The midpoint of the largest intersection between the point and
            a line halfway down its envelope.
            </returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea`1.Center(GeoAPI.Geometries.IExtents{`0})">
            <summary> 
            Returns the center point of the <see cref="T:GeoAPI.Geometries.IExtents`1"/>.
            </summary>
            <param name="envelope">The extents to analyze.</param>
            <returns> The center of the extents.</returns>
        </member>
        <member name="M:NetTopologySuite.Algorithm.InteriorPointArea`1.WidestGeometry(GeoAPI.Geometries.IGeometry{`0})">
            <returns>
            If point is a collection, the widest sub-point; otherwise,
            the point itself.
            </returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.CentroidPoint`1">
            <summary> 
            Computes the centroid of a point point.
            </summary>
            <remarks>
            Algorithm:
            Compute the average of all points.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CentroidPoint`1.Add(GeoAPI.Geometries.IGeometry{`0})">
            <summary> 
            Adds the point(s) defined by a Geometry to the centroid total.
            If the point is not of dimension 0 it does not contribute to the centroid.
            </summary>
            <param name="geom">The point to add.</param>
        </member>
        <member name="M:NetTopologySuite.Algorithm.CentroidPoint`1.Add(`0)">
            <summary> 
            Adds the length defined by a coordinate.
            </summary>
            <param name="point">A coordinate.</param>
        </member>
        <member name="T:NetTopologySuite.Simplify.DouglasPeuckerSimplifier`1">
            <summary>
            Simplifies an <see cref="T:GeoAPI.Geometries.IGeometry`1"/> using the standard Douglas-Peucker algorithm.
            Ensures that any polygonal geometries returned are valid.
            Simple lines are not guaranteed to remain simple after simplification.
            Note that in general D-P does not preserve topology -
            e.g. polygons can be split, collapse to lines or disappear
            holes can be created or disappear,
            and lines can cross.
            To simplify point while preserving topology use TopologySafeSimplifier.
            (However, using D-P is significantly faster).
            </summary>
        </member>
        <member name="M:NetTopologySuite.Simplify.DouglasPeuckerSimplifier`1.DPTransformer.createValidArea(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Creates a valid area point from one that possibly has
            bad topology (i.e. self-intersections).
            Since buffer can handle invalid topology, but always returns
            valid point, constructing a 0-width buffer "corrects" the
            topology.
            Note this only works for area geometries, since buffer always returns
            areas.  This also may return empty geometries, if the input
            has no actual area.
            </summary>
            <param name="roughAreaGeom">An area point possibly containing self-intersections.</param>
            <returns>A valid area point.</returns>
        </member>
        <member name="T:NetTopologySuite.Operation.Union.UnaryUnionOp`1">
            <summary>
            Unions a collection of Geometry or a single Geometry 
            (which may be a collection) together.
            By using this special-purpose operation over a collection of geometries
            it is possible to take advantage of various optimizations to improve performance.
            Heterogeneous {@link GeometryCollection}s are fully supported.
            
            The result obeys the following contract:
            <list type="Bullet">
            <item>Unioning a set of overlapping {@link Polygons}s has the effect of
            merging the areas (i.e. the same effect as 
            iteratively unioning all individual polygons together).</item>
            <item>Unioning a set of {@link LineString}s has the effect of <b>fully noding</b> 
            and <b>dissolving</b> the input linework.
            In this context "fully noded" means that there will be a node or endpoint in the output 
            for every endpoint or line segment crossing in the input.
            "Dissolved" means that any duplicate (e.g. coincident) line segments or portions
            of line segments will be reduced to a single line segment in the output.  
            This is consistent with the semantics of the 
            {@link Geometry#union(Geometry)} operation.
            If <b>merged</b> linework is required, the {@link LineMerger} class can be used.</item>
            
            <item>Unioning a set of {@link Points}s has the effect of merging
            al identical points (producing a set with no duplicates).</item>
            </list>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
             Constructs an instance of this class
            </summary>
            <param name="geoms">an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:GeoAPI.Geometries.IGeometry`1"/>s</param>
            <param name="geomFact">an <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <summary>
             Constructs an instance of this class
            </summary>
            <param name="geoms">an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:GeoAPI.Geometries.IGeometry`1"/>s</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Constructs an instance of this class
            </summary>
            <param name="geom">an <see cref="T:GeoAPI.Geometries.IGeometry`1"/></param>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.Union(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}})">
            <summary>
            </summary>
            <param name="geoms"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.Union(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IGeometry{`0}},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            </summary>
            <param name="geoms"></param>
            <param name="geomFact"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.Union(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            </summary>
            <param name="geom"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.Union">
            <summary>
             Gets the union of the input geometries.
             If no input geometries were provided, a POINT EMPTY is returned.
            </summary>
            <returns>a Geometry containing the union</returns>
             <returns>an empty GEOMETRYCOLLECTION if no geometries were provided in the input</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.UnionWithNull(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Computes the union of two geometries, either of both of which may be null.
            </summary>"/&gt;
            <param name="g0">a <see cref="T:GeoAPI.Geometries.IGeometry`1"/></param>
            <param name="g1">a <see cref="T:GeoAPI.Geometries.IGeometry`1"/></param>
            <returns>the union of the input(s)</returns>
            <returns>null if both inputs are null</returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.UnaryUnionOp`1.UnionNoOpt(GeoAPI.Geometries.IGeometry{`0})">
                    ///Computes a unary union with no extra optimization,
                    ///and no short-circuiting.
                    ///Due to the way the overlay operations 
                    ///are implemented, this is still efficient in the case of linear 
                    ///and puntal geometries.
                    ///
                    ///@param g0 a geometry
                    ///@return the union of the input geometry
        </member>
        <member name="T:NetTopologySuite.Operation.Union.CascadedPolygonUnion`1">
            <summary>
            <see href="http://code.google.com/p/nettopologysuite/issues/detail?id=44"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Union.CascadedPolygonUnion`1.Factory">
            The effectiveness of the index is somewhat sensitive
            to the node capacity.  
            Testing indicates that a smaller capacity is better.
            For an STRtree, 4 is probably a good number (since
            this produces 2x2 "squares").
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.EdgeEndBundle`1">
            <summary>
            A collection of <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s which 
            obey the following invariant:
            They originate at the same node and have the same direction.
            Contains all <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s which start 
            at the same point and are parallel.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle`1.ComputeLabel(NetTopologySuite.Algorithm.IBoundaryNodeRule)">
            <summary>
            This computes the overall edge label for the set of
            edges in this EdgeStubBundle.  It essentially merges
            the ON and side labels for each edge. 
            These labels must be compatible.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.EdgeEndBundle`1.UpdateIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Update the intersection matrix with the contribution for 
            the computed label for the <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Noding.MonotoneChainIndexSegmentSetMutualIntersector`1">
            <summary>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="F:NetTopologySuite.Noding.MonotoneChainIndexSegmentSetMutualIntersector`1._index">
            <summary>
            The Spatial index used should be something that supports
            envelope (range) queries efficiently (such as a <see cref="T:NetTopologySuite.Index.Quadtree.Quadtree`2"/>
            or <see cref="T:NetTopologySuite.Index.Strtree.StrTree`2"/>
            </summary>
        </member>
        <member name="M:NetTopologySuite.Noding.MonotoneChainIndexSegmentSetMutualIntersector`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
             Creates an instance of this class
            </summary>
            <param name="geoFactory"></param>
        </member>
        <member name="M:NetTopologySuite.Noding.MonotoneChainIndexSegmentSetMutualIntersector`1.SegmentOverlapAction`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`1},NetTopologySuite.Noding.ISegmentIntersector{`1})">
            <summary>
            </summary>
            <param name="geometryFactory"></param>
            <param name="si"></param>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LocationIndexOfLine`1">
            <summary>
            Determines the location of a subline along a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            The location is reported as a pair of <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>s.
            NOTE: Currently this algorithm is not guaranteed to
            return the correct substring in some situations where
            an endpoint of the test line occurs more than once in the input line.
            (However, the common case of a ring is always handled correctly).
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LocationIndexOfLine`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LocationIndexOfLine`1"/> class.
            </summary>
            <param name="linearGeom">The linear geom.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexOfPoint`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LengthIndexOfPoint`1"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexOfPoint`1.IndexOf(`0)">
            <summary>
            Find the nearest location along a linear 
            <see cref="T:GeoAPI.Geometries.IGeometry`1"/> to a given point.
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthIndexOfPoint`1.IndexOfAfter(`0,System.Double)">
            <summary>
            Finds the nearest index along the linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            to a given <typeparamref name="TCoordinate"/> after the specified minimum index.
            If possible the location returned will be strictly 
            greater than the <paramref name="minIndex"/>.
            If this is not possible, the value returned 
            will equal <paramref name="minIndex"/>.
            (An example where this is not possible is when
            <paramref name="minIndex"/> = [end of line] ).
            </summary>
            <param name="inputPt">The coordinate to locate.</param>
            <param name="minIndex">The minimum location for the point location.</param>
            <returns>The location of the nearest point.</returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1">
            <summary> 
            An <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/> represents a point on an
            edge which intersects with another edge by using an index into the 
            <see cref="P:NetTopologySuite.GeometriesGraph.Edge`1.Coordinates"/>
            </summary>
            <remarks>
            <para>
            The intersection may either be a single point, or a line segment
            (in which case this point is the start of the line segment)
            The label attached to this intersection point applies to
            the edge from this point forwards, until the next
            intersection or the end of the edge.
            </para>
            The intersection point must be precise.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersection`1.#ctor(`0,System.Int32,System.Double)">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/>
            described by the given <paramref name="coordinate"/>, 
            <paramref name="segmentIndex"/> of a line segment, and 
            <paramref name="distance"/> along the segment.
            </summary>
            <param name="coordinate">Coordinate of the intersection.</param>
            <param name="segmentIndex">
            Index of the line segment which the edge represents.
            </param>
            <param name="distance">
            Distance along the segment where the intersection is located.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersection`1.Compare(System.Int32,System.Double)">
            <returns>
            -1 this EdgeIntersection is located before the argument location,
            0 this EdgeIntersection is at the argument location,
            1 this EdgeIntersection is located after the argument location.
            </returns>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeIntersection`1.Coordinate">
            <summary>
            The point of intersection.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeIntersection`1.SegmentIndex">
            <summary>
            The index of the containing line segment in the parent edge.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeIntersection`1.Distance">
            <summary>
            The edge distance of this point along the containing line segment.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeUtil`1">
            <summary>
             Utilities for working with <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeUtil`1.FindEdgesIncidentOnOrigin(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
             Gets all edges which are incident on the origin of the given edge.
            </summary>
            <param name="start">the edge to start at</param>
            <returns>an enumeration of edges which have their origin at the origin of the given edge</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1" -->
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetTriangleEdges(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0},NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0}[]@)">
            <summary>
             Gets the edges for the triangle to the left of the given <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1"/>.
            </summary>
             <param name="startQe"></param>
             <param name="triEdge"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},GeoAPI.Geometries.IExtents{`0},System.Double)">
            
            
            
            
            @param env
                     
            @param tolerance
                     
            <summary>
             Creates a new instance of a quad-edge subdivision based on a frame triangle
             that encloses a supplied bounding box. A new super-bounding box that
             contains the triangle is computed and stored.
            </summary>
            <param name="geomFactory">the factory to create geometries</param>
            <param name="env">the bouding box to surround</param>
            <param name="tolerance">the tolerance value for determining if two sites are equal</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.MakeEdge(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>Creates a new quadedge, recording it in the edges list.
            </summary>
            <param name="o"></param>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Connect(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0},NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>Creates a new QuadEdge connecting the destination of a to the origin of b,
             in such a way that all three have the same left face after the connection
             is complete. The quadedge is recorded in the edges list.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Delete(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary> Deletes a quadedge from the subdivision. Linked quadedges are updated to reflect the deletion.
            </summary>
            <param name="e">the quadedge to delete</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.LocateFromEdge(NetTopologySuite.Triangulate.Quadedge.Vertex{`0},NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>
             Locates an edge of a triangle which contains a location specified by a Vertex v.
             The edge returned has the property that either v is on e, or e is an edge of a 
             triangle containing v.
             The search starts from startEdge amd proceeds on the general direction of v.
             <para>
             This locate algorithm relies on the subdivision being Delaunay. For non-Delaunay
             subdivisions, this may loop for ever.
             </para>
            </summary>
            <param name="v">the location to search for</param>
            <param name="startEdge">an edge of the subdivision to start searching at</param>
            <returns>a QuadEdge which contains v, or is on the edge of a triangle containing v</returns>
            <exception cref="T:NetTopologySuite.Triangulate.Quadedge.LocateFailureException`1">if the location algorithm fails to converge in a reasonable number of iterations</exception>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Locate(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>
             Finds a quadedge of a triangle containing a location specified by a <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/>, if one exists.
            </summary>
            <param name="v">the vertex to locate</param>
            <returns>a quadedge on the edge of a triangle which touches or contains the location </returns>
             <returns>null if no such triangle exists</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Locate(`0)">
            <summary>
             Finds a quadedge of a triangle containing a location specified by a <see cref="!:TCoordinate"/>, if one exists.
            </summary>
            <param name="p">the Coordinate to locate</param>
            <returns></returns>
            <returns>a quadedge on the edge of a triangle which touches or contains the location </returns>
            <returns>null if no such triangle exists</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Locate(`0,`0)">
            <summary>
             Locates the edge between the given vertices, if it exists in the subdivision.
            </summary>
            <param name="p0">a coordinate</param>
            <param name="p1">another coordinate</param>
            <returns>the edge joining the coordinates, if present</returns>
            <returns>null if no such triangle exists</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.InsertSite(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})" -->
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.IsFrameEdge(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            
            
            @param e
                     
            @return 
            <summary>
             Tests whether a QuadEdge is an edge incident on a frame triangle vertex.
            </summary>
            <param name="e">the edge to test</param>
            <returns>true if the edge is connected to the frame triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.isFrameBorderEdge(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            Tests whether a QuadEdge is an edge on the border of the frame facets and
            the internal facets. E.g. an edge which does not itself touch a frame
            vertex, but which touches an edge which does.
            
            @param e
                     the edge to test
            @return true if the edge is on the border of the frame
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.IsFrameVertex(NetTopologySuite.Triangulate.Quadedge.Vertex{`0})">
            <summary>Tests whether a vertex is a vertex of the outer triangle.
            </summary>
            <param name="v">the vertex to test</param>
            <returns>true if the vertex is an outer triangle vertex</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.IsOnEdge(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0},`0)">
            Tests whether a {@link Coordinate} lies on a {@link QuadEdge}, up to a
            tolerance determined by the subdivision tolerance.
            
            @param e
                     a QuadEdge
            @param p
                     a point
            @return true if the vertex lies on the edge
            <summary>
            </summary>
            <param name="e"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.IsVertexOfEdge(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0},NetTopologySuite.Triangulate.Quadedge.Vertex{`0})" -->
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetVertices(System.Boolean)">
               * Gets the unique {@link Vertex}es in the subdivision,
               * including the frame vertices if desired.
               * 
            	 * @param includeFrame
            	 *          true if the frame vertices should be included
               * @return a collection of the subdivision vertices
               * 
               * @see #GetVertexUniqueEdges
            <summary>
            </summary>
            <param name="includeFrame"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetVertexUniqueEdges(System.Boolean)" -->
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetPrimaryEdges(System.Boolean)">
            <summary>
             Gets all primary quadedges in the subdivision. A primary edge is a <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1"/>
              which occupies the 0'th position in its array of associated quadedges.
             These provide the unique geometric edges of the triangulation.
            </summary>
            <param name="includeFrame">true if the frame edges are to be included</param>
            <returns>a List of QuadEdges</returns>
        </member>
        <member name="F:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1._triEdges">
            	 * The quadedges forming a single triangle.
                 * Only one visitor is allowed to be active at a
            	 * time, so this is safe.
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.FetchTriangleToVisit(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0},System.Collections.Generic.Stack{NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0}},System.Boolean,System.Collections.Generic.HashSet{NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0}})">
            Stores the edges for a visited triangle. Also pushes sym (neighbour) edges
            on stack to visit later.
            
            @param edge
            @param edgeStack
            @param includeFrame
            @return the visited triangle edges
            @return null if the triangle should not be visited (for instance, if it is
                    outer)
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetTriangleEdges(System.Boolean)">
            <summary>
             Gets a list of the triangles in the subdivision, specified as
             an array of the primary quadedges around the triangle.
            </summary>
            <param name="includeFrame">true if the frame triangles should be included</param>
            <returns>a List of <see cref="T:NetTopologySuite.Triangulate.Quadedge.QuadEdge`1"/>[3] arrays</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetTriangleVertices(System.Boolean)">
            <summary>
             Gets a list of the triangles in the subdivision, specified as an array of the triangle <see cref="T:NetTopologySuite.Triangulate.Quadedge.Vertex`1"/>es.
            </summary>
            <param name="includeFrame">true if the frame triangles should be included </param>
            <returns>a List of Vertex[3] arrays</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetTriangleCoordinates(System.Boolean)">
            <summary>
             Gets the coordinates for each triangle in the subdivision as an array.
            </summary>
            <param name="includeFrame">true if the frame triangles should be included</param>
            <returns>a list of Coordinate[4] representing each triangle</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetEdges">
            Gets the geometry for the edges in the subdivision as a {@link MultiLineString}
            containing 2-point lines.
            
            @param geomFact the GeometryFactory to use
            @return a MultiLineString
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetTriangles">
            Gets the geometry for the triangles in a triangulated subdivision as a {@link GeometryCollection}
            of triangular {@link Polygon}s.
            
            @param geomFact the GeometryFactory to use
            @return a GeometryCollection of triangular Polygons
            <summary>
             
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetVoronoiDiagram">
            <summary>
             Gets the cells in the Voronoi diagram for this triangulation.
             The cells are returned as .
             The userData of each polygon is set to be the <see cref="!:TCoordinate"/>
             of the cell site.  This allows easily associating external
             data associated with the sites to the cells.
            </summary>
            <returns>a <see cref="T:GeoAPI.Geometries.IMultiPolygon`1"/></returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetVoronoiCellPolygons">
            <summary>
             Gets a List of <see cref="T:GeoAPI.Geometries.IPolygon`1"/>s for the Voronoi cells of this triangulation.
             The UserData of each polygon is set to be the <see cref="!:TCoordinate"/> of the cell site.
             This allows easily associating external data associated with the sites to the cells.
            </summary>
            <returns>an enumeration of polygons</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.GetVoronoiCellPolygon(NetTopologySuite.Triangulate.Quadedge.QuadEdge{`0})">
            <summary>Gets the Voronoi cell around a site specified by the origin of a QuadEdge.
             The UserData of the polygon is set to be the <see cref="!:TCoordinate"/> of the site.
             This allows attaching external data associated with the site to this cell polygon.
            </summary>
            <param name="qe">qe a quadedge originating at the cell site</param>
            <returns>a polygon indicating the cell extent</returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Tolerance">
            <summary>
             Gets the vertex-equality tolerance value used in this subdivision
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Extents">
            <summary>
             Gets the envelope of the Subdivision (including the frame).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Edges">
            <summary>
             Gets the collection of base {@link Quadedge}s (one for every pair of
             vertices which is connected).
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.Locator">
            <summary>
             Gets/Sets the <see cref="T:NetTopologySuite.Triangulate.Quadedge.IQuadEdgeLocator`1"/> to use for locating containing triangles
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Quadedge.QuadEdgeSubdivision`1.TriangleCircumcentreVisitor">
            <summary>
             A TriangleVisitor which computes and sets the circumcentre as the origin of the dual 
             edges originating in each triangle.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Relate.RelateNode`1">
            <summary>
            A <see cref="T:NetTopologySuite.Operation.Relate.RelateNode`1"/> is a <see cref="T:NetTopologySuite.GeometriesGraph.Node`1"/> 
            that maintains an ordered list of <see cref="T:NetTopologySuite.Operation.Relate.EdgeEndBundle`1"/>s 
            for the edges that are incident on it.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNode`1.ComputeIntersectionMatrix(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Update the <see cref="T:GeoAPI.Geometries.IntersectionMatrix"/> with the 
            contribution for this component. A component only 
            contributes if it has a labeling for both parent geometries.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Relate.RelateNode`1.UpdateIntersectionMatrixFromEdges(GeoAPI.Geometries.IntersectionMatrix)">
            <summary>
            Update the IM with the contribution for the 
            <see cref="T:NetTopologySuite.GeometriesGraph.EdgeEnd`1"/>s incident on this node.
            </summary>
        </member>
        <member name="T:NetTopologySuite.LinearReferencing.LengthLocationMap`1">
            <summary>
            Computes the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> for a given length
            along a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>
            Negative lengths are measured in reverse from end of the linear geometry.
            Out-of-range values are clamped.
            </summary>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NetTopologySuite.LinearReferencing.LengthLocationMap`1"/> class.
            </summary>
            <param name="linearGeom">A linear geometry.</param>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap`1.GetLocation(GeoAPI.Geometries.IGeometry{`0},System.Double)">
            <summary>
            Computes the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> for a
            given length along a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="linearGeom">The linear geometry to use.</param>
            <param name="length">The length index of the location.</param>
            <returns>The <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> for the length.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap`1.GetLength(GeoAPI.Geometries.IGeometry{`0},NetTopologySuite.LinearReferencing.LinearLocation{`0})">
            <summary>
            Computes the length for a given <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>
            on a linear <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>.
            </summary>
            <param name="linearGeom">The linear geometry to use.</param>
            <param name="loc">The <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> index of the location.</param>
            <returns>The length for the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.LinearReferencing.LengthLocationMap`1.GetLocation(System.Double)">
            <summary>
            Compute the <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/> corresponding to a length.
            Negative lengths are measured in reverse from end of the linear geometry.
            Out-of-range values are clamped.
            </summary>
            <param name="length">The length index.</param>
            <returns>The corresponding <see cref="T:NetTopologySuite.LinearReferencing.LinearLocation`1"/>.</returns>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.TopologyLocation">
            <summary> 
            A <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> is the labeling of a
            <see cref="T:NetTopologySuite.GeometriesGraph.GraphComponent`1"/>'s topological relationship 
            to a single <see cref="T:GeoAPI.Geometries.IGeometry"/>.
            </summary>
            <remarks>
            <para>
            If the labeled component is an area edge, each side and the edge itself
            have a topological location.  These locations are named:
            <list type="table">
            <item>
            <term>On</term>
            <description>on the edge</description>
            </item>
            <item>
            <term>Left</term>
            <description>left-hand side of the edge</description>
            </item>
            <item>
            <term>Right</term>
            <description>right-hand side</description>
            </item>
            </list>
            </para>
            <para>
            If the labeled component is a line edge or node, there is a single
            topological relationship attribute: <see cref="F:NetTopologySuite.GeometriesGraph.Positions.On"/>.
            </para>
            <para>
            The possible values of a topological location are
            { <see cref="F:GeoAPI.Geometries.Locations.None"/>, <see cref="F:GeoAPI.Geometries.Locations.Exterior"/>, 
            <see cref="F:GeoAPI.Geometries.Locations.Boundary"/>, <see cref="F:GeoAPI.Geometries.Locations.Interior"/> }.
            </para>
            <para>
            The labeling is efficiently stored in an <see cref="T:System.Int32"/> 
            where the lower 3 bytes represent the values of 
            <see cref="F:NetTopologySuite.GeometriesGraph.Positions.On"/>, <see cref="F:NetTopologySuite.GeometriesGraph.Positions.Left"/> and 
            <see cref="F:NetTopologySuite.GeometriesGraph.Positions.Right"/>, respectively.
            </para>
            <para>
            In NTS v2.0, <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> was reconceived 
            as a value type due to the semantics of its use as well as the 
            compactness of its scope. This change alters method signatures
            to allow taking a <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> instance and 
            generating a new one based on method and parameters, since all 
            the internal fields are now read-only. This enforces the value 
            semantics of the type, and helps avoid cases of trying to modify 
            the value in a local scope, and having those changes lost when the 
            scope is exited. The internal representation of TopologyLocation has 
            also been modified to fit all <see cref="T:GeoAPI.Geometries.Locations"/> attributes 
            into a single <see cref="T:System.Int32"/> field, creating a highly 
            compact and lightweight representation, reducing memory pressure 
            and GC burden in complex <see cref="T:NetTopologySuite.GeometriesGraph.GeometryGraph`1"/>s.
            </para>
            </remarks>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.#ctor(GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations,GeoAPI.Geometries.Locations)">
            <summary> 
            Constructs a <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> specifying how points on, 
            to the left of, and to the right of some 
            <see cref="T:NetTopologySuite.GeometriesGraph.GraphComponent`1"/> relate
            to some Geometry.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.#ctor(GeoAPI.Geometries.Locations)">
            <summary> 
            Constructs a <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> specifying how points on
            some <see cref="T:NetTopologySuite.GeometriesGraph.GraphComponent`1"/> relate
            to some Geometry.
            </summary>
            <param name="on">
            The location of points on the graph component relative to 
            some geometry.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.#ctor(NetTopologySuite.GeometriesGraph.TopologyLocation)">
            <summary> 
            Constructs a <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> which is a copy of the 
            given <paramref name="other"/> topology location.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> to copy.</param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.#ctor(NetTopologySuite.GeometriesGraph.TopologyLocation,NetTopologySuite.GeometriesGraph.Positions,GeoAPI.Geometries.Locations)">
            <summary> 
            Constructs a <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> which is a copy of the 
            given <paramref name="other"/> topology location, but with
            the given <paramref name="position"/> set to the given 
            <paramref name="location"/>.
            </summary>
            <param name="other">The <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> to copy.</param>
            <param name="position">
            The position within this <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> to set to a new
            <see cref="T:GeoAPI.Geometries.Locations"/> value.
            </param>
            <param name="location">
            The location to use for the given <paramref name="position"/>.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.IsEqualOnSide(NetTopologySuite.GeometriesGraph.TopologyLocation,NetTopologySuite.GeometriesGraph.Positions)">
            <summary>
            Gets a value indicating if the given <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            has the same <see cref="T:GeoAPI.Geometries.Locations"/> value on the side specified by 
            <paramref name="position"/>.
            </summary>
            <param name="other">
            The other <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> to compare.
            </param>
            <param name="position">
            The side to compare.
            </param>
            <returns>
            <see langword="true"/> if the values at <paramref name="position"/>
            are equal; false otherwise.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Flip">
            <summary>
            Computes a <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> which has the
            <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left"/> and <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right"/> <see cref="T:GeoAPI.Geometries.Locations"/>
            values swapped.
            </summary>
            <returns>The flipped <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>.</returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.AllPositionsEqual(GeoAPI.Geometries.Locations)">
            <summary>
            Computes whether all locations in this <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            are equal to the given <paramref name="location"/>.
            </summary>
            <param name="location">The location to test.</param>
            <returns>
            <see langword="true"/> if <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On"/>, 
            <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left"/> and <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right"/> are all equal to
            <paramref name="location"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.TopologyLocation.Merge(NetTopologySuite.GeometriesGraph.TopologyLocation)">
            <summary>
            Merge updates only the attributes of this 
            <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> which are <see cref="F:GeoAPI.Geometries.Locations.None"/>
            with the attributes of another, and returns the result.
            </summary>
            <remarks>
            If one of the the <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> is a line, and  
            other is an area, the destination will be an area.
            </remarks>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Item(NetTopologySuite.GeometriesGraph.Positions)">
            <summary>
            Gets the <see cref="T:GeoAPI.Geometries.Locations"/> value at the 
            given <see cref="T:NetTopologySuite.GeometriesGraph.Positions"/> value.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsNone">
            <summary>
            Gets <see langword="true"/> if all locations are 
            <see cref="F:GeoAPI.Geometries.Locations.None"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.AreAnyNone">
            <summary>
            Gets <see langword="true"/> if any locations are 
            <see cref="F:GeoAPI.Geometries.Locations.None"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsArea">
            <summary>
            Gets a value indicating whether this <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            represents an area, by having a value other than 
            <see cref="F:GeoAPI.Geometries.Locations.None"/> for <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left"/> and <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.IsLine">
            <summary>
            Gets a value indicating whether this <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            represents a line, by having a value <see cref="F:GeoAPI.Geometries.Locations.None"/> 
            for <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left"/> and <see cref="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right"/>.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.On">
            <summary>
            Gets the location of points on this <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/>
            relative to some geometry as a <see cref="T:GeoAPI.Geometries.Locations"/> value.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Left">
            <summary>
            Gets the location of points to the left of this 
            <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> relative to some geometry 
            as a <see cref="T:GeoAPI.Geometries.Locations"/> value.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.TopologyLocation.Right">
            <summary>
            Gets the location of points to the right of this 
            <see cref="T:NetTopologySuite.GeometriesGraph.TopologyLocation"/> relative to some geometry 
            as a <see cref="T:GeoAPI.Geometries.Locations"/> value.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent.CompareTo(NetTopologySuite.GeometriesGraph.Index.SweepLineEvent)">
            <summary>
            <see cref="T:NetTopologySuite.GeometriesGraph.Index.SweepLineEvent"/>s are ordered first by their x-value, 
            and then by their event type. It is important that 
            <see cref="F:NetTopologySuite.GeometriesGraph.Index.SweepLineEventType.Insert"/> events are sorted before 
            <see cref="F:NetTopologySuite.GeometriesGraph.Index.SweepLineEventType.Delete"/> events, so that
            items whose Insert and Delete events occur at the same x-value will be
            correctly handled.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Geometries.MultiPoint`1">
            <summary>  
            Models a collection of <see cref="T:GeoAPI.Geometries.IPoint`1"/>s.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs an empty <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IPoint{`0}},GeoAPI.Geometries.IGeometryFactory{`0})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>.
            </summary>
            <param name="points">
            The <see cref="T:GeoAPI.Geometries.IPoint`1"/>s for this <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>, 
            or <see langword="null"/> or an empty array to create the empty point.
            Elements may be empty <see cref="T:GeoAPI.Geometries.IPoint`1"/>s, 
            but not <see langword="null"/>s.
            </param>
            <param name="factory">
            The <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> used to create the 
            <see cref="T:GeoAPI.Geometries.IPoint`1"/>.
            </param>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint`1.#ctor(System.Collections.Generic.IEnumerable{GeoAPI.Geometries.IPoint{`0}})">
            <summary>
            Constructs a <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>.
            </summary>
            <param name="points">
            The <see cref="T:NetTopologySuite.Geometries.Point`1"/>s for this <see cref="T:NetTopologySuite.Geometries.MultiPoint`1"/>, 
            or <see langword="null"/> or an empty array to create the empty point.
            Elements may be empty <see cref="T:NetTopologySuite.Geometries.Point`1"/>s, 
            but not <see langword="null"/>s.
            </param>
            <remarks>
            For create this <see cref="T:NetTopologySuite.Geometries.Geometry`1"/> 
            is used a standard <see cref="T:NetTopologySuite.Geometries.GeometryFactory`1"/> 
            with <see cref="T:GeoAPI.Coordinates.IPrecisionModel`1"/> <c> == </c> <see cref="F:GeoAPI.Coordinates.PrecisionModelType.DoubleFloating"/>.
            </remarks>
        </member>
        <member name="M:NetTopologySuite.Geometries.MultiPoint`1.GetCoordinate(System.Int32)">
            <summary>
            Returns the <typeparamref name="TCoordinate"/> at the given <paramref name="index"/>.
            </summary>
            <param name="index">
            The index of the <typeparamref name="TCoordinate"/> 
            to retrieve, beginning at 0.
            </param>
            <returns>The <typeparamref name="TCoordinate"/> at <paramref name="index"/>.</returns>
        </member>
        <member name="P:NetTopologySuite.Geometries.MultiPoint`1.Item(System.Int32)">
            <summary>
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:NetTopologySuite.Geometries.GeometryCollectionEnumerator`1">
            <summary>
            Iterates over all <see cref="T:NetTopologySuite.Geometries.Geometry`1"/>'s in a <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>. 
            Implements a pre-order depth-first traversal of the <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>
            (which may be nested). The original <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> is
            returned as well (as the first object), as are all sub-collections. It is
            simple to ignore the <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> objects if they are not
            needed.
            </summary>    
        </member>
        <member name="M:NetTopologySuite.Geometries.GeometryCollectionEnumerator`1.#ctor(GeoAPI.Geometries.IGeometryCollection{`0})">
            <summary>
            Constructs an iterator over the given <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/>.
            </summary>
            <param name="parent">
            The collection over which to iterate; also, the first
            element returned by the iterator.
            </param>
        </member>
        <member name="P:NetTopologySuite.Geometries.GeometryCollectionEnumerator`1.Current">
            <remarks> 
            The parent <see cref="T:NetTopologySuite.Geometries.GeometryCollection`1"/> is the 
            first object returned!
            </remarks>
        </member>
        <member name="T:NetTopologySuite.Index.KdTree.KdTree`1">
            <summary>
             An implementation of a 2-D KD-Tree. KD-trees provide fast range searching on point data.
             <para>
             This implementation supports detecting and snapping points which are closer than a given
             tolerance value. If the same point (up to tolerance) is inserted more than once a new node is
             not created but the count of the existing node is incremented.
             </para>
             
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.#ctor">
            <summary>
             Creates a new instance of a KdTree with a snapping tolerance of 0.0.
             (I.e. distinct points will <c>not</c> be snapped)
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.#ctor(System.Double)">
            <summary>
             Creates a new instance of a KdTree, specifying a snapping distance tolerance.
             Points which lie closer than the tolerance to a point already 
             in the tree will be treated as identical to the existing point.
            </summary>
            <param name="tolerance">the tolerance distance for considering two points equal</param>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.InsertRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Inserts a Range of <see cref="!:TCoordinate"/>s.
            </summary>
            <param name="pts">an enumeration of <see cref="!:TCoordinate"/></param>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Insert(`0)">
            <summary>
             Inserts a new point in the kd-tree, with no data.
            </summary>
            <param name="p">the point to insert</param>
            <returns>the <see cref="T:NetTopologySuite.Index.KdTree.KdTree`1"/> containing the point</returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Insert(`0,System.Object)">
            <summary>
             Inserts a new point into the kd-tree.
            </summary>
            <param name="p">the point to insert</param>
            <param name="data">a data item for the point</param>
            <returns>returns a new KdNode if a new point is inserted, else an existing 
             node is returned with its counter incremented. This can be checked
             by testing returnedNode.getCount() > 1.
             </returns>
        </member>
        <member name="M:NetTopologySuite.Index.KdTree.KdTree`1.Query(GeoAPI.Geometries.IExtents{`0})">
            <summary>
             Performs a range search of the points in the index.
            </summary>
            <param name="queryEnv">the range rectangle to query</param>
            <returns>an enumeration of the KdNodes found</returns>
        </member>
        <member name="T:NetTopologySuite.Algorithm.LineIntersectionDegrees">
            <summary>
            Specifies the degrees of intersection between two lines or line
            segments.
            </summary>
            <remarks>
            The integer values of the members of this enum are also the number
            of intersections between them.
            </remarks>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersectionDegrees.DoesNotIntersect">
            <summary>
            Lines or line segments do not intersect.
            </summary>
            <value>0</value>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersectionDegrees.Intersects">
            <summary>
            Lines or line segments have at most one intersection.
            </summary>
            <value>1</value>
        </member>
        <member name="F:NetTopologySuite.Algorithm.LineIntersectionDegrees.Collinear">
            <summary>
            Lines or line segments have at least two intersections,
            and are therefore collinear.
            </summary>
            <value>2</value>
        </member>
        <member name="T:GeoAPI.IO.WellKnownText.GeometryFromWkt">
            <summary>
            Converts a Well-Known Text representation to a <see cref="T:GeoAPI.Geometries.IGeometry"/> instance.
            </summary>
            <remarks>
            <para>
            The Well-Known Text (WKT) representation of Geometry is designed to 
            exchange geometry data in ASCII form.
            </para>
            Examples of WKT representations of geometry objects are:
            <list type="table">
            <listheader><term>Geometry </term>
            <description>WKT Representation</description>
            </listheader>
            <item><term>A Point</term>
            <description>POINT(15 20)<br/> Note that point coordinates are specified 
            with no separating comma.</description></item>
            <item><term>A LineString with four points:</term>
            <description>LINESTRING(0 0, 10 10, 20 25, 50 60)</description></item>
            <item><term>A Polygon with one exterior ring and one interior ring:</term>
            <description>POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))</description></item>
            <item><term>A MultiPoint with three Point values:</term>
            <description>MULTIPOINT(0 0, 20 20, 60 60)</description></item>
            <item><term>A MultiLineString with two LineString values:</term>
            <description>MULTILINESTRING((10 10, 20 20), (15 15, 30 15))</description></item>
            <item><term>A MultiPolygon with two Polygon values:</term>
            <description>MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0)),((5 5,7 5,7 7,5 7, 5 5)))</description></item>
            <item><term>A GeometryCollection consisting of two Point values and one LineString:</term>
            <description>GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.Parse``1(System.String,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Converts a Well-known text representation to a 
            <see cref="T:GeoAPI.Geometries.IGeometry"/>.
            </summary>
            <param name="wellKnownText">
            A <see cref="T:GeoAPI.Geometries.IGeometry"/> tagged text String 
            (see the OpenGIS Simple Features Specification).
            </param>
            <returns>
            Returns a <see cref="T:GeoAPI.Geometries.IGeometry"/> specified by wellKnownText.  
            Throws an exception if there is a parsing problem.
            </returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.Parse``1(System.IO.TextReader,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Converts a Well-Known Text representation to a 
            <see cref="T:GeoAPI.Geometries.IGeometry"/>.
            </summary>
            <param name="reader">
            A reader which will return a Geometry Tagged Text
            String (see the OpenGIS Simple Features Specification).</param>
            <returns>
            Returns a <see cref="T:GeoAPI.Geometries.IGeometry"/> read from StreamReader. 
            An exception will be thrown if there is a parsing problem.
            </returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.getCoordinates``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Returns the next array of Coordinates in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text format. 
            The next element returned by the stream should be "(" 
            (the beginning of "(x1 y1, x2 y2, ..., xn yn)" or "EMPTY".
            </param>
            <returns>
            The next array of Coordinates in the stream, or an empty array of 
            "EMPTY" is the next element returned by the stream.
            </returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.getNextTokenIfNumber(GeoAPI.IO.WellKnownText.WktTokenizer)">
            <summary>
            Returns the next number in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in well-known text format. 
            The next token must be a number.
            </param>
            <returns>Returns the next number in the stream.</returns>
            <exception cref="T:GeoAPI.ParseException">Thrown if the next token is not a number.</exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.getNextEmptyOrOpener(GeoAPI.IO.WellKnownText.WktTokenizer)">
            <summary>
            Returns the next "EMPTY" or "(" in the stream as uppercase text.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text
            format. The next token must be "EMPTY" or "(".
            </param>
            <returns>
            The next "EMPTY" or "(" in the stream as uppercase text.
            </returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if the next token is not "EMPTY" or "(".
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.getNextCloserOrComma(GeoAPI.IO.WellKnownText.WktTokenizer)">
            <summary>
            Returns the next ")" or "," in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text
            format. The next token must be ")" or ",".
            </param>
            <returns>Returns the next ")" or "," in the stream.</returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if the next token is not ")" or ",".
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.removeNextCloser(GeoAPI.IO.WellKnownText.WktTokenizer)">
            <summary>
            Returns the next ")" in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text
            format. The next token must be ")".
            </param>
            <returns>
            Returns the next ")" in the stream.
            </returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if the next token is not ")".
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.getNextWord(GeoAPI.IO.WellKnownText.WktTokenizer)">
            <summary>
            Returns the next word in the stream as uppercase text.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text
            format. The next token must be a word.
            </param>
            <returns>Returns the next word in the stream as uppercase text.</returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if the next token is not a word.
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.readGeometryTaggedText``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a Geometry using the next token in the stream.
            </summary>
            <param name="tokenizer">Tokenizer over a stream of text in Well-Known Text
            format. The next tokens must form a &lt;Geometry Tagged Text&gt;.</param>
            <returns>Returns a Geometry specified by the next token in the stream.</returns>
            <remarks>
            Exception is thrown if the coordinates used to create a Polygon
            shell and holes do not form closed linestrings, or if an unexpected
            token is encountered.
            </remarks>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if an unexpected token is encountered.
            </exception>
            <exception cref="T:System.NotSupportedException">
            Thrown if an unsupported geometry is encountered.
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.readMultiPointText``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a Point using the next token in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text
            format. The next tokens must form a &lt;Point Text&gt;.
            </param>
            <returns>
            Returns a Point specified by the next token in
            the stream.
            </returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if an unexpected token is encountered.
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.readPointText``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a Point using the next token in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text
            format. The next tokens must form a &lt;Point Text&gt;.
            </param>
            <returns>
            Returns a Point specified by the next token in
            the stream.
            </returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if an unexpected token is encountered.
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.readMultiPolygonText``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a <see cref="T:GeoAPI.Geometries.IMultiPolygon"/> using the next token in the stream.
            </summary>
            <param name="tokenizer">tokenizer over a stream of text in Well-Known Text
            format. The next tokens must form a MultiPolygon.</param>
            <returns>
            A <see cref="T:GeoAPI.Geometries.IMultiPolygon"/> specified by the next token in the 
            stream.
            </returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if an unexpected token is encountered or 
            if if the coordinates used to create the <see cref="T:GeoAPI.Geometries.IPolygon"/>
            shells and holes do not form closed linestrings.
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.readPolygonText``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a Polygon using the next token in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text
            format. The next tokens must form a &lt;Polygon Text&gt;.</param>
            <returns>
            Returns a Polygon specified by the next token
            in the stream.
            </returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if an unexpected token is encountered or 
            if if the coordinates used to create the <see cref="T:GeoAPI.Geometries.IPolygon"/>
            shells and holes do not form closed linestrings.
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.readMultiLineStringText``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a <see cref="T:GeoAPI.Geometries.IMultiLineString"/> using the next token in the stream. 
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text format. 
            The next tokens must form a &lt;MultiLineString Text&gt;.
            </param>
            <returns>
            A <see cref="T:GeoAPI.Geometries.IMultiLineString"/> specified by the next token in the stream.
            </returns>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.readLineStringText``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a LineString using the next token in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text format.  
            The next tokens must form a &lt;LineString Text&gt;.
            </param>
            <returns>
            Returns a LineString specified by the next token in the stream.
            </returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if an unexpected token is encountered.
            </exception>
        </member>
        <member name="M:GeoAPI.IO.WellKnownText.GeometryFromWkt.readGeometryCollectionText``1(GeoAPI.IO.WellKnownText.WktTokenizer,GeoAPI.Geometries.IGeometryFactory{``0})">
            <summary>
            Creates a <see cref="T:GeoAPI.Geometries.IGeometryCollection"/> using the next token in the stream.
            </summary>
            <param name="tokenizer">
            Tokenizer over a stream of text in Well-Known Text
            format. The next tokens must form a GeometryCollection Text.
            </param>
            <returns>
            A <see cref="T:GeoAPI.Geometries.IGeometryCollection"/> specified by the next token in the stream.
            </returns>
            <exception cref="T:GeoAPI.ParseException">
            Thrown if an unexpected token is encountered.
            </exception>
        </member>
        <member name="T:NetTopologySuite.Triangulate.Segment`1">
            <summary>
             Models a constraint segment in a triangulation. 
             A constraint segment is an oriented straight line segment between a start point and an end point.
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment`1.#ctor(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
             Creates a new instance for the given ordinates.
            </summary>
            <param name="factory">a coordinate factory</param>
            <param name="x1">x-ordinate of 1st point</param>
            <param name="y1">y-ordinate of 1st point</param>
            <param name="z1">z-ordinate of 1st point</param>
            <param name="x2">x-ordinate of 2nd point</param>
            <param name="y2">y-ordinate of 2nd point</param>
            <param name="z2">z-ordinate of 2nd point</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment`1.#ctor(GeoAPI.Coordinates.ICoordinateFactory{`0},System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Object)">
            
            <summary>
             Creates a new instance for the given ordinates, with associated external data.
            </summary>
            <param name="factory">a coordinate factory</param>
            <param name="x1">x-ordinate of 1st point</param>
            <param name="y1">y-ordinate of 1st point</param>
            <param name="z1">z-ordinate of 1st point</param>
            <param name="x2">x-ordinate of 2nd point</param>
            <param name="y2">y-ordinate of 2nd point</param>
            <param name="z2">z-ordinate of 2nd point</param>
            <param name="data">external data</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment`1.#ctor(`0,`0,System.Object)">
            <summary>
             Creates a new instance for the given points, with associated external data.
            </summary>
            <param name="p0">the start point</param>
            <param name="p1">the end point</param>
            <param name="data">an external data object</param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment`1.#ctor(`0,`0)">
            <summary>
             Creates a new instance for the given points.
            </summary>
            <param name="p0"></param>
            <param name="p1"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment`1.EqualsTopologically(NetTopologySuite.Triangulate.Segment{`0})">
            <summary>
             Determines whether two segments are topologically equal. I.e. equal up to orientation.
            </summary>
            <param name="otherLs">a segment</param>
            <returns>true if the segments are topologically equal</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.Segment`1.Intersection(GeoAPI.Geometries.IGeometryFactory{`0},NetTopologySuite.Triangulate.Segment{`0})">
            <summary>
             Computes the intersection point between this segment and another one.
            </summary>
            <param name="factory">factory to compute intersection point</param> 
            <param name="otherLs">a segment</param>
            <returns>the intersection point, or <value>null</value> if there is none</returns>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.Start">
            <summary>
             Gets the start coordinate of the segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.End">
            <summary>
             Gets the end TCoordinate of the segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.StartX">
            <summary>
              Gets the start X ordinate of the segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.StartY">
            <summary>
              Gets the start Y ordinate of the segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.StartZ">
            <summary>
              Gets the start Z ordinate of the segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.EndX">
            <summary>
              Gets the end X ordinate of the segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.EndY">
            <summary>
              Gets the end Y ordinate of the segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.EndZ">
            <summary>
              Gets the end Z ordinate of the segment
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.LineSegment">
            <summary>
             Gets a <see cref="!:LineSegment&lt;TCoordinate&gt;"/> modelling this segment.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Triangulate.Segment`1.Data">
            <summary>
             Gets/Sets the external _data associated with this segment
            </summary>
        </member>
        <member name="T:NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder`1">
            <summary>
             A strategy for finding constraint split points which attempts to maximise the length of the split
             segments while preventing further encroachment. (This is not always possible for narrow angles).
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder`1.#ctor(GeoAPI.Coordinates.ICoordinateFactory{`0})">
            <summary>
             creates an instance of this class
            </summary>
            <param name="coordinateFactory"></param>
        </member>
        <member name="M:NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder`1.FindSplitPoint(NetTopologySuite.Triangulate.Segment{`0},`0)">
            <summary>
             A basic strategy for finding split points when nothing extra is known about the geometry of the situation.
            </summary>
            <param name="seg">the encroached segment</param>
            <param name="encroachPt">the encroaching point</param>
            <returns>the point at which to split the encroached segment</returns>
        </member>
        <member name="M:NetTopologySuite.Triangulate.NonEncroachingSplitPointFinder`1.ProjectedSplitPoint(NetTopologySuite.Triangulate.Segment{`0},`0,GeoAPI.Coordinates.ICoordinateFactory{`0})">
            <summary>
             Computes a split point which is the projection of the encroaching point on the segment
            </summary>
            <param name="seg"></param>
            <param name="encroachPt"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="T:NetTopologySuite.Planargraph.DirectedEdgeStar`1">
            <summary>
            A sorted collection of <see cref="T:NetTopologySuite.Planargraph.DirectedEdge`1"/>s 
            which leave a <see cref="T:NetTopologySuite.Planargraph.Node`1"/>
            in a <see cref="T:NetTopologySuite.Planargraph.PlanarGraph`1"/>.
            </summary>
        </member>
        <member name="F:NetTopologySuite.Planargraph.DirectedEdgeStar`1._outEdges">
            <summary>
            The underlying list of outgoing DirectedEdges.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar`1.GetEnumerator">
            <summary>
            Returns an Iterator over the DirectedEdges, in ascending order by 
            angle with the positive x-axis.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar`1.Add(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Adds a new member to this DirectedEdgeStar.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar`1.Remove(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Drops a member of this DirectedEdgeStar.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar`1.GetIndex(NetTopologySuite.Planargraph.Edge{`0})">
            <summary>
            Returns the zero-based index of the given Edge, after sorting in 
            ascending order by angle with the positive x-axis.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar`1.GetIndex(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Returns the zero-based index of the given DirectedEdge, after sorting in ascending order
            by angle with the positive x-axis.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar`1.GetIndex(System.Int32)">
            <summary> 
            Returns the remainder when i is divided by the number of edges in this
            DirectedEdgeStar. 
            </summary>
        </member>
        <member name="M:NetTopologySuite.Planargraph.DirectedEdgeStar`1.GetNextEdge(NetTopologySuite.Planargraph.DirectedEdge{`0})">
            <summary>
            Returns the DirectedEdge on the left-hand side of the given DirectedEdge (which
            must be a member of this DirectedEdgeStar). 
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdgeStar`1.Degree">
            <summary>
            Returns the number of edges around the Node associated with this 
            DirectedEdgeStar.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdgeStar`1.Coordinate">
            <summary>
            Returns the coordinate for the node at wich this star is based.
            </summary>
        </member>
        <member name="P:NetTopologySuite.Planargraph.DirectedEdgeStar`1.Edges">
            <summary>
            Returns the DirectedEdges, in ascending order by angle with the positive 
            x-axis.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Predicate.SegmentIntersectionTester`1">
            <summary>
            Tests if any line segments in two sets of 
            <see cref="T:GeoAPI.Coordinates.ICoordinateSequence`1"/> intersect.
            Optimized for small geometry size.
            Short-circuited to return as soon an intersection is found.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Snap.SnapOverlayOp`1">
            Performs an overlay operation using snapping and enhanced precision
            to improve the robustness of the result.
            This class <i>always</i> uses snapping.  
            This is less performant than the standard JTS overlay code, 
            and may even introduce errors which were not present in the original data.
            For this reason, this class should only be used 
            if the standard overlay code fails to produce a correct result. 
             
            @author Martin Davis
            @version 1.7
            <summary>
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper`1">
            <summary>
            Snaps the vertices and segments of a <see cref="T:GeoAPI.Geometries.IGeometry`1"/> to another Geometry's vertices.
            Improves robustness for overlay operations, by eliminating
            nearly parallel edges (which cause problems during noding and intersection calculation).
            
            @author Martin Davis
            @version 1.7
            </summary>
            <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper`1.ComputeOverlaySnapTolerance(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Estimates the snap tolerance for a Geometry, taking into account its precision model.
            </summary>
            <param name="g">a Geometry</param>
            <returns>the estimated snap tolerance</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper`1.Snap(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0},System.Double)" -->
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper`1.#ctor(GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Creates a new snapper acting on the given geometry
            </summary>
            <param name="srcGeom">the geometry to snap</param>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper`1.ComputeSnapTolerance(GeoAPI.Coordinates.ICoordinateSequence{`0})">
            <summary>
             Computes the snap tolerance based on the input geometries.
            </summary>
            <param name="ringPts"></param>
             <returns></returns>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.Snap.GeometrySnapper`1.SnapTo(GeoAPI.Geometries.IGeometry{`0},System.Double)">
             Snaps the vertices in the component {@link LineString}s
             of the source geometry
             to the vertices of the given snap geometry.
            
             @param snapGeom a geometry to snap the source to
             @return a new snapped Geometry
        </member>
        <member name="T:NetTopologySuite.Operation.Overlay.LineBuilder`1">
            <summary>
            Forms NTS LineStrings out of a the graph of <c>DirectedEdge</c>s
            created by an <c>OverlayOp</c>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder`1.Build(NetTopologySuite.Operation.Overlay.SpatialFunctions)">
            <summary>
            Returns a list of the <see cref="T:GeoAPI.Geometries.ILineString`1"/>s 
            in the result of the specified overlay operation.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder`1.findCoveredLineEdges">
            <summary>
            Find and mark L edges which are "covered" by the result area (if any).
            L edges at nodes which also have A edges can be checked by checking
            their depth at that node.
            L edges at nodes which do not have A edges can be checked by doing a
            point-in-polygon test with the previously computed result areas.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Operation.Overlay.LineBuilder`1.collectBoundaryTouchEdge(NetTopologySuite.GeometriesGraph.DirectedEdge{`0},NetTopologySuite.Operation.Overlay.SpatialFunctions)">
            <summary>
            Collect edges from Area inputs which should be in the result but
            which have not been included in a result area.
            This happens ONLY:
            during an intersection when the boundaries of two
            areas touch in a line segment
            OR as a result of a dimensional collapse.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Index.Quadtree.Root`2">
            <summary>
            QuadRoot is the root of a single Quadtree.  
            It is centered at the origin,
            and does not have a defined extent.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Root`2.Insert(`1)">
            <summary> 
            Insert an item into the quadtree this is the root of.
            </summary>
        </member>
        <member name="M:NetTopologySuite.Index.Quadtree.Root`2.insertContained(NetTopologySuite.Index.Quadtree.Node{`0,`1},GeoAPI.Geometries.IExtents{`0},`1)">
            <summary> 
            Insert an item which is known to be contained in the tree rooted at
            the given QuadNode root.  Lower levels of the tree will be created
            if necessary to hold the item.
            </summary>
        </member>
        <member name="T:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1">
            <summary>
            A list of edge intersections along an <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.#ctor(GeoAPI.Geometries.IGeometryFactory{`0},NetTopologySuite.GeometriesGraph.Edge{`0})">
            <summary>
            Creates a new <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1"/>.
            </summary>
            <param name="geoFactory">
            An <see cref="T:GeoAPI.Geometries.IGeometryFactory`1"/> instance.
            </param>
            <param name="edge">
            The containing <see cref="T:NetTopologySuite.GeometriesGraph.Edge`1"/>.
            </param>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.GetEnumerator">
            <summary> 
            Returns an iterator of EdgeIntersections.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.IsIntersection(`0)">
            <summary>
            Searches all of the contained <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/>
            entries to find if an itersection exists at <paramref name="point"/>.
            </summary>
            <param name="point">The coordinate to search for an intersection at.</param>
            <returns>
            <see langword="true"/> if the <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1"/>
            contains an <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/> at 
            <paramref name="point"/>.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.AddEndpoints">
            <summary>
            Adds entries for the first and last points of the edge to the list.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.GetSplitEdges">
            <summary> 
            Generates and returns new edges for all the 
            edges that the intersections in this list split the parent edge into.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.CreateSplitEdge(NetTopologySuite.GeometriesGraph.EdgeIntersection{`0},NetTopologySuite.GeometriesGraph.EdgeIntersection{`0})">
            <summary>
            Create a new "split edge" with the section of points between
            (and including) the two intersections.
            The label for the new edge is the same as the label for the parent edge.
            </summary>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.Add(`0,System.Int32,System.Double)">
            <summary> 
            Adds an intersection into the list, if it isn't already there.
            The input segmentIndex and dist are expected to be normalized.
            </summary>
            <returns>
            The <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/> found or added.
            </returns>
        </member>
        <member name="M:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.Clear">
            <summary>
            Clears the <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1"/> of all
            <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/>s.
            </summary>
        </member>
        <member name="P:NetTopologySuite.GeometriesGraph.EdgeIntersectionList`1.Count">
            <summary>
            Gets the number of <see cref="T:NetTopologySuite.GeometriesGraph.EdgeIntersection`1"/>s
            in the list.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.MonoValentEndPointBoundaryNodeRule">
            <summary>
             A <see cref="T:NetTopologySuite.Algorithm.IBoundaryNodeRule"/> which determines that only
             endpoints with valency of exactly 1 are on the boundary.
             This corresponds to the boundary of a <see cref="T:GeoAPI.Geometries.IMultiLineString"/>
             being all the "unattached" endpoints.
            </summary>
        </member>
        <member name="T:NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure`1">
             <summary>
             Measures the degree of similarity between two <see cref="T:GeoAPI.Geometries.IGeometry`1"/>s
             using the Hausdorff distance metric.
             The measure is normalized to lie in the range [0, 1].
             Higher measures indicate a great degree of similarity.
            
             The measure is computed by computing the Hausdorff distance
             between the input geometries, and then normalizing
             this by dividing it by the diagonal distance across 
             the envelope of the combined geometries.
             </summary>
             <typeparam name="TCoordinate"></typeparam>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Match.HausdorffSimilarityMeasure`1.DensifyFraction">
            <summary>
             Densify a small amount to increase accuracy of Hausdorff distance
            </summary>
        </member>
        <member name="F:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance`1._densifyFrac">
            Value of 0.0 indicates not set
        </member>
        <member name="M:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance`1.#ctor(GeoAPI.Geometries.IGeometry{`0},GeoAPI.Geometries.IGeometry{`0})">
            <summary>
             Constructs an item of this class
            </summary>
            <param name="g0">first geometry</param>
            <param name="g1">second geometry</param>
        </member>
        <member name="P:NetTopologySuite.Algorithm.Distance.DiscreteHausdorffDistance`1.DensifyFraction">
            Sets the fraction by which to densify each segment.
            Each segment will be split into a number of equal-length
            subsegments, whose fraction of the total length is closest ]
            to the given fraction.
            
            @param densifyPercent
        </member>
    </members>
</doc>
